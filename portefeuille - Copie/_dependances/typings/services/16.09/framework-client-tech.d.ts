/**
 * Generated by                   : ct-tfsbuild@SIEGCE8V2005
 * Branch                         : Socle Technique Client 1.9
 * Date                           : 20160406143238
 * Version MySys                  : v16.09
 * Version Socle Technique Client : 1.9.0
 * TFS hyperlink                  : http://tfs2013qpa.sigcesie.caisse-epargne.fr:8080/tfs/ITCEDefault/MyWay.SocleTechnique/_versionControl/changeset/286195
 * Build droplocation             : \\Vfqitcappc100\tfs_qpa_build\myway\SocleTechnique\Socle Technique Client 1.9\Socle Technique Client 1.9_20160406.1
 */

declare module MyWay {
    /**
     * Informations statiques du Socle Technique Client
     */
    class Framework {
        /**
         * Nom actuel du Socle Technique Client, utilisé dans les traces.
         * @type {string}
         */
        static NAME: string;
        /**
         * Version actuelle du Socle Technique Client, utilisé dans les traces.
         * @type {string}
         */
        static VERSION: string;
        /**
         * Informations sur le build TFS ayant généré cette version du Socle Technique Client
         * @type {string}
         */
        static BUILD: string;
    }
}


declare module MyWay.Services.Component {
    interface ICoreComponent {
        ComponentName: string;
        ZoneName: string;
        Logger: Trace.ILogger;
    }
    interface IComponent extends ICoreComponent {
        Library: IComponentLibrary;
        HandleMessage(event: MessageEvent, sendResponseCallback: ResponseCallback): any;
    }
    interface ResponseCallback {
        (event: MessageEvent, callbackContent: any, error: Erreur): void;
    }
}

declare module MyWay.Services.Component {
    interface IComponentLibrary {
        PreventMessage: boolean;
        Add(component: IComponent): any;
    }
}


declare module MyWay.Services.Component {
    class ComponentBase implements IComponent {
        ComponentName: string;
        ZoneName: string;
        Library: IComponentLibrary;
        ErreurCallback: ErreurCallback;
        Logger: Trace.ILogger;
        constructor(library: IComponentLibrary, componentName: string, zoneName: string, errorCallback: ErreurCallback);
        HandleMessage(event: MessageEvent, sendResponseCallback: ResponseCallback): void;
    }
}


declare module MyWay.Services.Component {
    class ComponentApiBase implements ICoreComponent {
        ComponentName: string;
        ZoneName: string;
        Logger: Trace.ILogger;
        constructor(componentName: string);
        WarnLocalServiceUnavailability(): void;
    }
}


declare module MyWay.Services.Component {
    class ComponentCommonBase extends ComponentBase implements IComponent {
        constructor(library: IComponentLibrary, name: string);
    }
}

declare module MyWay.Services.Component {
    class ComponentLibraryBase implements IComponentLibrary {
        PreventMessage: boolean;
        Add(component: IComponent): void;
    }
}

declare module MyWay.Services.Component {
    class TempLibrary implements IComponentLibrary {
        PreventMessage: boolean;
        Add(component: IComponent): void;
    }
}


declare module MyWay.Services {
    /**
     * Fournit un contrat d'utilisation des promesses MyWay.
     *
     * Utilise le service de promesses d'AngularJS s'il est disponible ($q) et le service externe Q dans le cas contraire.
     *
     */
    interface IServiceDePromesse {
        /**
         * ~~~ts
         * var promises: MyWay.Services.IPromesse<any>[] = [];
         * promises.push(serviceAgent.Context.AddToContext('foo', 'toto'));
         * promises.push(serviceAgent.Context.AddToContext('bar', "titi"));
         * MyWay.Services.CoreCommon.ServiceDePromesse.all(promises).then(() => {
         *     // actions à effectuer si les 2 promesses sont tenues
         *     ...
         * });
         * ~~~
         */
        all<T>(promises: IPromesse<T>[]): IPromesse<T[]>;
        all<T>(promises: any[]): IPromesse<T[]>;
        /**
         * Créé un objet permettant de valider ou rejeter la promesse demandée.
         *
         * ~~~ts
         * var deferred: IDeferred<string> = CoreCommon.ServiceDePromesse.defer<string>();
         * this.SendMessage(
         *     "GetFromContext",
         *     { key: key },
         *     (value: string) => { deferred.resolve(value); },
         *     (error?: Erreur) => { deferred.reject(error); }
         * );
         * return deferred.promise;
         * ~~~
         */
        defer<T>(erreurCallback?: ErreurCallback): IDeferred<T>;
        /**
         * Retourne une promesse qui est rejetée avec comme raison le paramètre passé.
         *
         */
        reject<T>(reason?: Erreur): IPromesse<T>;
        /**
         * Encapsule un objet qui peut être soit une valeur soit une promesse "chainable" dans une promesse $q ou Q.
         *
         * Cela peut être utile lorsque on a affaire à un objet qui peut (ou ne pas) être une promesse, ou si la promesse provient d'une source qui ne peut pas être certifiée.
         */
        when<T>(value: T): IPromesse<T>;
    }
    interface IPromesse<T> {
        /**
         * La méthode "then" fournit les callbacks qui recoivent
         *
         * - soit la valeur actuelle (ou éventuelle) d'une promesse (fulfill),
         *
         * - soit la raison pour laquelle cette promesse ne peut pas être tenue (reject).
         *
         * ~~~ts
         *serviceAgent.Context.GetFromContext('toto').then((value: string) => {
         *    // traitement du retour de promesse tenue (value)
         *    ...
         * });
         * ~~~
         *
         */
        then<TResult>(onFulfill: (value: T) => IPromesse<TResult>, onReject?: (reason: Erreur) => any, onProgress?: Function): IPromesse<TResult>;
        then<TResult>(onFulfill: (value: T) => IPromesse<TResult>, onReject?: (reason: Erreur) => TResult, onProgress?: Function): IPromesse<TResult>;
        then<TResult>(onFulfill: (value: T) => TResult, onReject?: (reason: Erreur) => TResult, onProgress?: Function): IPromesse<TResult>;
        /**
         * Cette méthode est un alias du callback "onReject" de la méthode "then": promise.then(null, errorCallback)
         *
         * ~~~ts
         * serviceAgent.Context.GetFromContext('toto').then((value: string) => {
         *     // traitement du retour de promesse tenue
         *     ...
         * }).catch((erreur: MyWay.Services.Erreur) => {
         *     // traitement du retour de promesse non tenue (erreur)
         *     ...
         * });
         * ~~~
         */
        catch<TResult>(onRejected: (reason: Erreur) => TResult): IPromesse<TResult>;
        catch<TResult>(onRejected: (reason: Erreur) => IPromesse<TResult>): IPromesse<TResult>;
        /**
         * Permet d'observer le succès ou le rejet d'une promesse, mais sans modifier la valeur finale.
         *
         * Cette méthode est utile pour libérer des resources ou effectuer un nettoyage peu importe le résultat de la promesse.
         *
         * ~~~ts
         * serviceAgent.Context.GetFromContext('toto').then((value: string) => {
         *     // traitement du retour de promesse tenue
         *     ...
         * }).catch((erreur: MyWay.Services.Erreur) => {
         *     // traitement du retour de promesse non tenue (erreur)
         *     ...
         * }).finally(() => {
         *     // cleanup
         *     serviceAgent.Dispose();
         *     serviceAgent = null;
         * });
         * ~~~
         */
        finally(finallyCallback: () => any): IPromesse<T>;
    }
    /**
     * Objet retourné par la méthode "defer" permettant de valider ou rejeter la promesse demandée.
     */
    interface IDeferred<T> {
        /**
         * Cette méthode controle l'état de la propriété "promise" dans le cas où la promesse est tenue.
         *
         * Dans le cas où une promesse est tenue, sa résolution est permanente et ne peut pas être résolue une seconde fois.
         *
         * ~~~ts
         * var deferred: IDeferred<string> = CoreCommon.ServiceDePromesse.defer<string>();
         * this.SendMessage(
         *     "GetFromContext",
         *     { key: key },
         *     (value: string) => {
         *         deferred.resolve(value);
         *     },
         *     null
         * );
         * return deferred.promise;
         * ~~~
         */
        resolve(value?: T): void;
        /**
         * Cette méthode controle l'état de la propriété "promise" dans le cas où la promesse n'est pas tenue.
         *
         * On peut donner une raison de refus lors de l'appel à cette méthode. Dans notre cas une raison de type "Erreur".
         *
         * ~~~ts
         * var deferred: IDeferred<string> = CoreCommon.ServiceDePromesse.defer<string>();
         * this.SendMessage(
         *     "GetFromContext",
         *     { key: key },
         *     (value: string) => {
         *         deferred.resolve(value);
         *     }, // resolve
         *     (error?: Erreur) => {
         *         deferred.reject(error);
         *     }
         * );
         * return deferred.promise;
         * ~~~
         */
        reject(reason?: Erreur): void;
        /**
         * L'appel à cette méthode avec une valeur va notifier la promesse de cette valeur.
         *
         * Tout handler de type "onProgress" abonné à notre promesse réceptionnera cette valeur de progression (ou d'état).
         *
         */
        notify(state?: any): void;
        promise: IPromesse<T>;
    }
    class MonServiceDePromesse implements IServiceDePromesse {
        private innerService;
        lastReason: Erreur;
        constructor(innerService: IServiceDePromesse);
        all<T>(promises: IPromesse<T>[]): IPromesse<T[]>;
        all<T>(promises: any[]): IPromesse<T[]>;
        defer<T>(erreurCallback?: ErreurCallback): IDeferred<T>;
        reject<T>(reason?: Erreur): IPromesse<T>;
        when<T>(value: T): IPromesse<T>;
    }
    class MaPromesse<T> implements IPromesse<T> {
        private innerPromesse;
        private erreurCallback;
        lastReason: Erreur;
        private _catchHappened;
        constructor(innerPromesse: IPromesse<T>, erreurCallback?: ErreurCallback);
        then<TResult>(onFulfill: (value: T) => IPromesse<TResult>, onReject?: (reason: Erreur) => any, onProgress?: Function): IPromesse<TResult>;
        then<TResult>(onFulfill: (value: T) => IPromesse<TResult>, onReject?: (reason: Erreur) => TResult, onProgress?: Function): IPromesse<TResult>;
        then<TResult>(onFulfill: (value: T) => TResult, onReject?: (reason: Erreur) => TResult, onProgress?: Function): IPromesse<TResult>;
        catch<TResult>(onRejected: (reason: Erreur) => TResult): IPromesse<TResult>;
        catch<TResult>(onRejected: (reason: Erreur) => IPromesse<TResult>): IPromesse<TResult>;
        finally(finallyCallback: () => any): IPromesse<T>;
    }
    class MonDeferred<T> implements IDeferred<T> {
        private innerDeferred;
        private erreurCallback;
        promesse: MaPromesse<T>;
        constructor(innerDeferred: IDeferred<T>, erreurCallback?: ErreurCallback);
        resolve: (value?: T) => void;
        reject: (reason?: Erreur) => void;
        notify: (state?: any) => void;
        promise: IPromesse<T>;
    }
}


declare module MyWay.Services {
    class CoreCommon extends Component.ComponentCommonBase {
        private _supportIndexed;
        private _serviceLocalDisponible;
        static ServiceDePromesse: IServiceDePromesse;
        static PreventMultipleJSONCalls: boolean;
        constructor(library: Component.IComponentLibrary);
        static init(): void;
        FindKeysToReplace(rawPathData: any): string[];
        GetBrowser(): any;
        static GetBrowserStatic(): any;
        GetBrowserVersion(): any;
        static GetBrowserVersionStatic(): any;
        static IsMobileBrowser(): boolean;
        SerializeScope(scope: any): string;
        /**
        * Récupère les propriétés de l'objet object
        * Retourne un tableau d'objet (Clé/Valeur) correspondant aux propriétés de l'objet object
        */
        static ObjectToArray(object: any): Context.IContextKeyValuePair[];
        ApplyProperties(from: any, to: any): void;
        static IsFunction(functionToCheck: any): boolean;
        /**
        * Détermine si le navigateur utilisé est IE ou non
        */
        static checkIsIE(): boolean;
        /**
        * Détermine si le service local est disponible ou non
        */
        serviceLocalDisponible(): boolean;
        /**
        * Retourne la version d'Internet Explorer
        */
        private static getInternetExplorerVersion();
        SwapArrayElements(arrayObject: any[], index_a: number, index_b: number): void;
        static SendRequestWithPromise(settings: IRequestSettings): IPromesse<any>;
        static SendRequest(settings: IRequestSettingsExtended, success: (data) => void, error: ErreurCallback): IXMLHttpRequest;
        static FixedEncodeURIComponent(str: string): string;
        static GetParams(params: any): string;
        private static AddMyWayHeaders(ixhr, settings);
        private static SavedJSON;
        private static Send(ixhr, logger, withCredentials);
        private static GetResponse(xhr, responseType);
        private static traiterErreur(xhr, ixhr, logger, error?);
        private static CheckSettings(settings);
        static creerChaineAleatoire(taille: number): string;
        static applyProperties(source: any, target: any, propName: any): void;
        /**
        * Permet le chargement dynamique d'un script présent dans le repertoire service du cdn
        * @param {string}   path
        * nom du fichier à charger
        */
        static loadCdnServiceScript(path: any): void;
        /**
        * Permet le chargement dynamique d'un script JS
        * @param {string}   path
        * chemin du fichier à charger
        */
        static loadScript(path: any): void;
        /**
         * Permet d'encoder certains caractères d'une string dont ~!*()' pour les passer en paramètres d'une URL
         * @param  {string} str Chaine de caractères à encoder
         * @return {string}     Chaine de caractères encodée
         */
        static encoderURL(str: string): string;
        static promesseTryCatch<T>(pCallback: (pDefer: IDeferred<T>) => any, pCallbackErreur?: (pErreur: Erreur, pDefer: IDeferred<T>) => any): IPromesse<T>;
        /**
         * Utilitaires pour le traitement des strings
         */
        static StringUtils: {
            leftPad: (pMorceauAFormater: string | number, pMorceauARajouter: string, pLongueurDesiree: any) => string;
            rightPad: (pMorceauAFormater: string | number, pMorceauARajouter: string, pLongueurDesiree: any) => string;
        };
        /**
         * Utilitaires pour les tableaux
         */
        static ArrayUtils: {
            remove: (pArray: any[], pCompare: (pElement: any) => boolean) => any[];
        };
    }
    interface IMessage {
        Type?: string;
        Message: string;
        Duree?: number;
    }
    class ExecutionAppliExt {
        CodeRetour: string;
        MessageRetour: string;
        DonneesRetour: string;
        Pid: string;
        constructor(codeRetour: string, messageRetour: string, donneesRetour: string, pid: string);
    }
    interface ErreurCallback {
        (erreur: Erreur): void;
    }
    class Erreur {
        codeLibelle: string;
        valeurs: string[];
        error: Error;
        codeHttp: number;
        libelle: string;
        causes: Erreur[];
        constructor(codeLibelle: string, valeurs?: string[], causes?: Erreur[]);
    }
    class ErreurClient extends Erreur {
        constructor(codeLibelle: string, valeurs?: string[], error?: Error);
    }
    class ErreurServeur extends Erreur {
        constructor(codeHttp: number, codeLibelle: string, libelle: string, valeurs?: string[], causes?: ErreurServeur[]);
    }
    interface IRequestSettings {
        method?: MethodEnum;
        url?: string;
        params?: any;
        data?: any;
        async?: boolean;
        contentType?: ContentTypeEnum;
        accept?: AcceptEnum;
        cache?: boolean;
        withHeaders?: boolean;
        responseType?: ResponseTypeEnum;
        oldHeader?: boolean;
        timeout?: number;
    }
    interface IRequestSettingsExtended extends IRequestSettings {
        authentificationInfo?: Context.AuthentificationInfo;
        parametresComptables?: Context.ParametresComptables;
        stepInfo?: Context.StepInfoExtended;
        logger?: Trace.ILogger;
        additionalHeaders?: {
            [key: string]: string;
        };
        type?: string;
    }
    enum ContentTypeEnum {
        NONE = 0,
        URL_ENCODED = 1,
        JSON = 2,
    }
    enum ResponseTypeEnum {
        BLOB = 0,
        JSON = 1,
        EMPTY = 2,
        NOT_DEFINED = 3,
    }
    enum AcceptEnum {
        ALL = 0,
        JSON = 1,
    }
    enum MethodEnum {
        DELETE = 0,
        GET = 1,
        POST = 2,
        PUT = 3,
    }
    interface IXMLHttpRequest {
        url?: string;
        headers?: Context.IContextKeyValuePair[];
        method?: string;
        async?: boolean;
        data?: string;
        responseType?: string;
        success?: (data) => void;
        timeout?: number;
        error?: ErreurCallback;
    }
}
interface JSON {
    pruned(value: any, depthDecr?: any, arrayMaxLength?: any): any;
}

declare module MyWay.Services {
    class NotificationMessage {
        Sujet: string;
        Contenu: any;
    }
}


declare module MyWay.Services.Aide {
    interface IAideFlash {
        titre: string;
        contenu: string;
    }
    interface IAideResult {
        ChampsDeSaisie: ChampDeSaisieResult[];
        ModalePush: ModalePushResult;
        Totem: TotemResult[];
        InfobullesAffichees: InfobulleAfficheeResult[];
        DetailInfobulleAffichee: DetailInfobulleAfficheeResult;
    }
    class AideResult implements IAideResult {
        ChampsDeSaisie: ChampDeSaisieResult[];
        ModalePush: ModalePushResult;
        Totem: TotemResult[];
        InfobullesAffichees: InfobulleAfficheeResult[];
        DetailInfobulleAffichee: DetailInfobulleAfficheeResult;
        constructor(data: IAideResult);
    }
    class ChampDeSaisieResult {
        Id: string;
        IdChamp: string;
        MessageCommunautaire: string;
        MessageEtablissement: string;
        EstUneNouveaute: boolean;
        constructor(data: any);
    }
    class ModalePushResult {
        Message: string;
        constructor(data: any);
    }
    class TotemResult {
        Categorie: string;
        Titre: string;
        FormatDocument: string;
        Lien: string;
        EstUneNouveaute: boolean;
        constructor(data: any);
    }
    class Infobulle {
    }
    class InfobulleAfficheeResult extends Infobulle {
        private _nomChampLie;
        private _estNouveaute;
        constructor(nomChamp: any, nouveaute?: boolean);
        getNomChampLie(): string;
        getEstNouveaute(): boolean;
    }
    class DetailInfobulleAfficheeResult extends InfobulleAfficheeResult {
        private _message;
        private _image;
        constructor(nomChamp: any, nouveaute?: boolean, message?: string, img?: string);
        getNomChampLie(): string;
        getEstNouveaute(): boolean;
        getMessage(): string;
        getImage(): string;
    }
}


declare module MyWay.Services.Context {
    enum LEVEL {
        GLOBAL,
        PROCESS,
        PROCESS_STEP,
    }
    enum PATH_PART {
        MAIN_PROCESS_ID = 0,
        LAST_PROCESS_ID = 1,
        PREVIOUS_PROCESS_ID = 2,
        STEP_ID = 3,
    }
    interface IContext {
        globalStorage: IContextKeyValuePair[];
        sharedStorage: IContextKeyValuePair[];
        portals: IPortalContext[];
        waitingProcesses: IProcess[];
    }
    interface IPortalContext {
        temporayContextStorage: IContextKeyValuePair[];
        processes: IProcess[];
        currentPath: string;
        isSingle: boolean;
        GetProcess(processId: string): MyWay.Services.Context.IProcess;
        GetProcessByPathPart(path: string, pathPart: PATH_PART): MyWay.Services.Context.IProcess;
        GetCurrentProcess(): IProcess;
        GetCurrentMainProcess(): IProcess;
        GetCurrentStep(process: IProcess): IProcessStep;
    }
    interface IContextKeyValuePair {
        Key: string;
        Value: string;
    }
    interface IProcessElement {
        id: string;
        contextStorage: IContextKeyValuePair[];
        type: string;
        codeEtape: string;
        getPath(): string;
        authorizedOutputs: number[];
    }
    interface IProcess extends IProcessElement {
        icon: string;
        displayName: string;
        putInWaitTime: number;
        subElements: IProcessElement[];
        knownSteps: string[];
        codeProcess: string;
        currentInnerElementPath: string;
        typeProcess: string;
        creationDate: number;
        estApplicationExterne: boolean;
        outputContracts: string[];
        isSubProcess: boolean;
    }
    interface IProcessStep extends IProcessElement {
        codeMetier: string;
        parentPath: string;
        codeApplication: string;
        nomApplication: string;
        url: string;
        boundId: string;
        isEnd: boolean;
        nextStep: IProcessStep;
        actions: IStepAction[];
        valeurEntree: number;
        contrats: IStepContrat[];
        processusMaitre: boolean;
        processName: string;
        maintienIFrame: boolean;
        nouvelleIFrame: boolean;
    }
    class IStepAction {
        Nom: string;
        CodeEtape: string;
        ValeurSortie: number;
        SurchargeValeurEntree: number;
        NouvelleActivite: boolean;
        EstExterne: boolean;
        Options: string;
    }
    class IStepContrat {
        Code: string;
        Type: string;
        Longueur: number;
        Nullable: boolean;
        Mode: string;
    }
    interface IStepOption {
        ProcessusMaitre?: boolean;
        ChangeTypeProcess?: string;
        MaintienIFrame?: boolean;
        NouvelleIFrame?: boolean;
        OutputContracts?: string[];
        Mappage?: string[];
    }
    interface IProcessOption {
        Icon?: string;
        ForeColor?: string;
        BackColor?: string;
        TypeProcess?: string;
        EstApplicationExterne?: boolean;
    }
    class AnalyseResult {
        TotalWatchers: number;
        TotalWatchers2: number;
        TotalWatchers3: number;
        WatcherByScope: AnalyseScope[];
        constructor();
        ToString(): string;
    }
    class AnalyseScope {
        Name: string;
        WatcherCount: number;
        constructor(Name: string, WatcherCount: number);
    }
}


declare module MyWay.Services.Context {
    class StepInfo {
        StepCode: string;
        BusinessCode: string;
        ProcessCode: string;
        ValeurEntree: number;
        Contrats: ContratInfo[];
        AuthorizedOutputs: number[];
        ProcessType: string;
        ScopeInitialise: boolean;
        constructor();
    }
    class StepInfoExtended extends StepInfo {
        CurrentStepId: string;
        CurrentProcessId: string;
        CurrentParentProcessId: string;
        NomComposant: string;
        NiveauTrace: number;
        Aide: MyWay.Services.Aide.AideResult;
        constructor();
    }
    class ContratInfo {
        NomData: string;
        /**
         * Correspond au nom de la donnée du contexte
         *
         */
        Mode: string;
    }
    class DonneesLocales {
        AuthentificationInfo: AuthentificationInfo;
        ParametresComptables: ParametresComptables;
        ParametresNumerisation: ParametresNumerisation;
        ParametresServeurPoste: ParametresServeurPoste;
    }
    class AuthentificationInfo {
        codeEtablissement: string;
        /**
         * Correspond au nom du poste de l'utilisateur
         *
         * Transmis à travers le header X-identifiantPoste des requêtes envoyées à travers le [[CoreCommon.SendRequest]]
         */
        numeroStationTravail: string;
        ENVIRON: string;
        agentConnecte: AgentConnecte;
        guichetAgent: GuichetAgent;
        constructor();
    }
    class ParametresComptables {
        codeGuichetInterbancaire: string;
        edsInterneGuichetComptable: string;
        /**
         * Correspond à l'identifiant de guichet opération
         *
         * Transmis à travers le header X-identifiantGuichetOperation des requêtes envoyées à travers le [[CoreCommon.SendRequest]]
         */
        edsExterneGuichetComptable: string;
        edsTypeGuichetComptable: string;
        edsInterneRattachementGuichetComptable: string;
        edsExterneRattachementGuichetComptable: string;
        edsTypeRattachementGuichetComptable: string;
        dateOperationJourneeComptable: string;
        typeCA: string;
        libelleEdsRattachementGuichetComptable: string;
        NumTelEdsRattachementGuichetComptable: string;
    }
    class ParametresNumerisation {
        ModeNumr: string;
    }
    class ParametresServeurPoste {
        NomServeur: string;
    }
    class AgentConnecte {
        referenceExterneAgent: string;
        typeFonction: string;
        numeroInterneEds: string;
        typeEds: string;
        numeroEdsSuperieur: string;
        typeEdsRattachement: string;
        referenceExterneEdsRattachemen: string;
        LICEE1: string;
        numeroExterneEds: string;
        libelleEds: string;
        designationLongueAgent: string;
        libelleTypeEds: string;
        designationPosteFonctionnel: string;
        codeCivilite: string;
        nomFamillePersonnePhysique: string;
        prenom: string;
        nomUsagePersonnePhysique: string;
        adresseMessagerie: string;
        identifiantInterneSite: string;
        ligne2Adresse: string;
        ligne3Adresse: string;
        ligne4Adresse: string;
        ligne5Adresse: string;
        ligne6Adresse: string;
        NODATP: string;
        codeInseePays: string;
        dateDebutValidite: string;
        dateFinValidite: string;
        codeQualiteAgent: string;
        codeIndicateurFinStructure: string;
        dateDebutValiditeReferentiel: string;
        constructor();
    }
    class GuichetAgent {
        codeGuichetInterbancaire: string;
        numeroEdsGuichet: string;
        referenceExterneEdsGuichet: string;
        typeEdsGuichet: string;
        DAGXOP: string;
    }
}

declare module MyWay.Services.Controle {
    /**
    * Classe statique de contrôle du type any (classe utilisée depuis les managers)
    * @classe StaticAnyControle
    * fonction : isNotUndefinedAndNotNull – public - Permet de contrôler que le paramètre en entrée n'est ni null ni undefined
    */
    class StaticAnyControle {
        /**
        * Contrôle que le paramètre en entrée n'est ni undefined ni null
        * @param value {any} valeur à contrôler
        */
        static isNotUndefinedAndNotNull(value: any): boolean;
    }
    /**
    * Classe de contrôle du type any (classe utilisée depuis les agents)
    * @classe AnyControle
    * fonction : isNotUndefinedAndNotNull – public - Permet de contrôler que le paramètre en entrée n'est ni null ni undefined
    */
    class AnyControle {
        /**
        * Contrôle que le paramètre en entrée n'est ni undefined ni null
        * @param value {any} valeur à contrôler
        */
        isNotUndefinedAndNotNull(value: any): boolean;
    }
}

declare module MyWay.Services.Controle {
    /**
    * Classe statique de contrôle des tableaux (classe utilisée depuis les managers)
    * @classe StaticArrayControle
    * fonction : isArray – public - Contrôle que le paramètre en entrée est un tableau
    */
    class StaticArrayControle {
        /**
        * Contrôle que le paramètre en entrée est un tableau
        * @param value {any} valeur à contrôler
        */
        static isArray(value: any): boolean;
    }
    /**
    * Classe statique de contrôle des tableaux (classe utilisée depuis les agents)
    * @classe ArrayControle
    * fonction : isArray – public - Contrôle que le paramètre en entrée est un tableau
    */
    class ArrayControle {
        /**
        * Contrôle que le paramètre en entrée est un tableau
        * @param value {any} valeur à contrôler
        */
        isArray(value: any): boolean;
    }
}

declare module MyWay.Services.Controle {
    /**
    * Classe statique de contrôle du type any (classe utilisée depuis les managers)
    * @classe StaticDateControle
    * fonction : isDate – public - Contrôle que le paramètre en entrée est une date
    */
    class StaticDateControle {
        /**
        * Contrôle que le paramètre en entrée est une date
        * @param value {any} valeur à contrôler
        */
        static isDate(value: any): boolean;
    }
    /**
    * Classe de contrôle du type any (classe utilisée depuis les agents)
    * @classe DateControle
    * fonction : isDate – public - Contrôle que le paramètre en entrée est une date
    */
    class DateControle {
        /**
        * Contrôle que le paramètre en entrée est une date
        * @param value {any} valeur à contrôler
        */
        isDate(value: any): boolean;
    }
}


declare module MyWay.Services.Controle {
    /**
    * Classe statique de contrôle des enum (classe utilisée depuis les managers)
    * @classe StaticEnumControle
    * fonction : isAnEnumValueOrNullOrUndefined - public - Contrôle que la valeur est bien une valeur de l'enum ou null ou undefined
    * fonction : isAnEnumValue – public - Contrôle que la valeur est bien une valeur de l'enum
    * fonction : isAnEnumMember – public - Contrôle que le membre est bien un membre de l'enum
    */
    class StaticEnumControle {
        /**
        * Contrôle que la valeur est bien une valeur de l'enum ou null ou undefined
        * @param value {any} valeur à contrôler
        * @param enumObject {any} l'enum
        */
        static isAnEnumValueOrNullOrUndefined(value: any, enumObject: any): boolean;
        /**
        * Contrôle que la valeur est bien une valeur de l'enum
        * @param value {any} valeur à contrôler
        * @param enumObject {any} l'enum
        */
        static isAnEnumValue(value: any, enumObject: any): boolean;
        /**
        * Contrôle que le membre est bien un membre de l'enum
        * @param member {any} membre à contrôler
        * @param enumObject {any} l'enum
        */
        static isAnEnumMember(member: any, enumObject: any): boolean;
    }
    /**
    * Classe de contrôle des enum (classe utilisée depuis les agents)
    * @classe EnumControle
    * fonction : isAnEnumValueOrNullOrUndefined - public - Contrôle que la valeur est bien une valeur de l'enum ou null ou undefined
    * fonction : isAnEnumValue – public - Contrôle que la valeur est bien une valeur de l'enum
    * fonction : isAnEnumMember – public - Contrôle que le membre est bien un membre de l'enum
    */
    class EnumControle {
        /**
        * Contrôle que la valeur est bien une valeur de l'enum ou null ou undefined
        * @param value {any} valeur à contrôler
        * @param enumObject {any} l'enum
        */
        isAnEnumValueOrNullOrUndefined(value: any, enumObject: any): boolean;
        /**
        * Contrôle que la valeur est bien une valeur de l'enum
        * @param value {any} valeur à contrôler
        * @param enumObject {any} l'enum
        */
        isAnEnumValue(value: any, enumObject: any): boolean;
        /**
        * Contrôle que le membre est bien un membre de l'enum
        * @param member {any} membre à contrôler
        * @param enumObject {any} l'enum
        */
        isAnEnumMember(member: any, enumObject: any): boolean;
    }
}

declare module MyWay.Services.Controle {
    /**
    * Classe statique de contrôle des fonctions (classe utilisée depuis les managers)
    * @classe StaticFunctionControle
    * fonction : isFunction – public - Contrôle que le paramètre en entrée est une fonction
    * fonction : isFunctionOrNull – public - Contrôle que le paramètre en entrée est une fonction ou null
    */
    class StaticFunctionControle {
        /**
        * Contrôle que le paramètre en entrée est une fonction
        * @param value {any} valeur à contrôler
        */
        static isFunction(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une fonction ou null
        * @param value {any} valeur à contrôler
        */
        static isFunctionOrNull(value: any): boolean;
    }
    /**
    * Classe de contrôle des fonctions (classe utilisée depuis les agents)
    * @classe FunctionControle
    * fonction : isFunction – public - Contrôle que le paramètre en entrée est une fonction
    * fonction : isFunctionOrNull – public - Contrôle que le paramètre en entrée est une fonction ou null
    */
    class FunctionControle {
        /**
        * Contrôle que le paramètre en entrée est une fonction
        * @param value {any} valeur à contrôler
        */
        isFunction(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une fonction ou null
        * @param value {any} valeur à contrôler
        */
        isFunctionOrNull(value: any): boolean;
    }
}

declare module MyWay.Services.Controle {
    /**
    * Classe statique de contrôle des nombres (classe utilisée depuis les managers)
    * @classe StaticNumberControle
    * fonction : isNumber – public - Contrôle que le paramètre en entrée est un nombre
    * fonction : isInt – public - Contrôle que le paramètre en entrée est un nombre entier
    */
    class StaticNumberControle {
        /**
        * Contrôle que le paramètre en entrée est un nombre
        * @param value {any} valeur à contrôler
        */
        static isNumber(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un nombre entier
        * @param value {any} valeur à contrôler
        */
        static isInt(value: any): boolean;
    }
    /**
    * Classe de contrôle des nombres (classe utilisée depuis les managers)
    * @classe NumberControle
    * fonction : isNumber – public - Contrôle que le paramètre en entrée est un nombre
    * fonction : isInt – public - Contrôle que le paramètre en entrée est un nombre entier
    */
    class NumberControle {
        /**
        * Contrôle que le paramètre en entrée est un nombre
        * @param value {any} valeur à contrôler
        */
        isNumber(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un nombre entier
        * @param value {any} valeur à contrôler
        */
        isInt(value: any): boolean;
    }
}

declare module MyWay.Services.Controle {
    /**
    * Classe statique permettant d'appliquer un contrôle sur les objets (classe utilisée depuis les managers)
    * @classe StaticObjectControle
    * fonction : isObject – public - Contrôle que le paramètre en entrée est un objet de type Object
    * fonction : isObjectOrNull – public - Contrôle que le paramètre en entrée est un objet ou null
    * fonction : isObjectOrNullOrUndefined – public - Contrôle que le paramètre en entrée est un objet ou null ou undefined
    * fonction : isObjectSpecified – public - Contrôle que le paramètre en entrée est un objet correspondant au type spécifié
    */
    class StaticObjectControle {
        /**
        * Contrôle que le paramètre en entrée est un objet de type Object
        * @param value {any} valeur à contrôler
        */
        static isObject(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un objet ou null
        * @param value {any} valeur à contrôler
        */
        static isObjectOrNull(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un objet ou null ou undefined
        * @param value {any} valeur à contrôler
        */
        static isObjectOrNullOrUndefined(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un objet correspondant au type spécifié
        * @param value {any} valeur à contrôler
        * @param objectType {string} type auquel doit correspondre la valeur
        */
        static isObjectSpecified(value: any, objectType: string): boolean;
    }
    /**
    * Classe permettant d'appliquer un contrôle sur les objets (classe utilisée depuis les agents)
    * @classe ObjectControle
    * fonction : isObject – public - Contrôle que le paramètre en entrée est un objet de type Object
    * fonction : isObjectOrNull – public - Contrôle que le paramètre en entrée est un objet ou null
    * fonction : isObjectOrNullOrUndefined – public - Contrôle que le paramètre en entrée est un objet ou null ou undefined
    * fonction : isObjectSpecified – public - Contrôle que le paramètre en entrée est un objet correspondant au type spécifié
    */
    class ObjectControle {
        /**
        * Contrôle que le paramètre en entrée est un objet de type Object
        * @param value {any} valeur à contrôler
        */
        isObject(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un objet ou null
        * @param value {any} valeur à contrôler
        */
        isObjectOrNull(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un objet ou null ou undefined
        * @param value {any} valeur à contrôler
        */
        isObjectOrNullOrUndefined(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un objet correspondant au type spécifié
        * @param value {any} valeur à contrôler
        * @param objectType {string} type auquel doit correspondre la valeur
        */
        isObjectSpecified(value: any, objectType: string): boolean;
    }
}

declare module MyWay.Services.Controle {
    /**
    * Classe statique de contrôle des chaines de caractères (classe utilisée depuis les managers)
    * @classe StaticStringControle
    * fonction : isString – public - Contrôle que le paramètre en entrée est une chaine de caractères
    * fonction : isStringOrNull – public - Contrôle que le paramètre en entrée est une chaine de caractères ou null
    * fonction : isStringOrNullOrUndefined – public - Contrôle que le paramètre en entrée est une chaine de caractères ou null ou undefined
    * fonction : isStringNotEmpty – public - Contrôle que le paramètre en entrée est une chaine de caractères non vide
    * fonction : isStringNotEmptyOrNull – public - Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null
    * fonction : isStringNotEmptyOrNullOrUndefined – public - Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null ou undefined
    */
    class StaticStringControle {
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères
        * @param value {any} valeur à contrôler
        */
        static isString(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères ou null
        * @param value {any} valeur à contrôler
        */
        static isStringOrNull(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères ou null ou undefined
        * @param value {any} valeur à contrôler
        */
        static isStringOrNullOrUndefined(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères non vide
        * @param value {any} valeur à contrôler
        */
        static isStringNotEmpty(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null
        * @param value {any} valeur à contrôler
        */
        static isStringNotEmptyOrNull(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null ou undefined
        * @param value {any} valeur à contrôler
        */
        static isStringNotEmptyOrNullOrUndefined(value: any): boolean;
    }
    /**
    * Classe de contrôle des chaines de caractères (classe utilisée depuis les agents)
    * @classe StringControle
    * fonction : isString – public - Contrôle que le paramètre en entrée est une chaine de caractères
    * fonction : isStringOrNull – public - Contrôle que le paramètre en entrée est une chaine de caractères ou null
    * fonction : isStringOrNullOrUndefined – public - Contrôle que le paramètre en entrée est une chaine de caractères ou null ou undefined
    * fonction : isStringNotEmpty – public - Contrôle que le paramètre en entrée est une chaine de caractères non vide
    * fonction : isStringNotEmptyOrNull – public - Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null
    * fonction : isStringNotEmptyOrNullOrUndefined – public - Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null ou undefined
    */
    class StringControle {
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères
        * @param value {any} valeur à contrôler
        */
        isString(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères ou null
        * @param value {any} valeur à contrôler
        */
        isStringOrNull(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères ou null ou undefined
        * @param value {any} valeur à contrôler
        */
        isStringOrNullOrUndefined(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères non vide
        * @param value {any} valeur à contrôler
        */
        isStringNotEmpty(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null
        * @param value {any} valeur à contrôler
        */
        isStringNotEmptyOrNull(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null ou undefined
        * @param value {any} valeur à contrôler
        */
        isStringNotEmptyOrNullOrUndefined(value: any): boolean;
    }
}

declare module MyWay.Services.Controle {
    /**
    * Classe statique de contrôle des booléens (classe utilisée depuis les managers)
    * @classe StaticBooleanControle
    * fonction : isBoolean – public - Contrôle que le paramètre en entrée est un booléen
    */
    class StaticBooleanControle {
        /**
        * Contrôle que le paramètre en entrée est un booléen
        * @param value {any} valeur à contrôler
        */
        static isBoolean(value: any): boolean;
    }
    /**
    * Classe de contrôle des booléens (classe utilisée depuis les agents)
    * @classe BooleanControle
    * fonction : isBoolean – public - Contrôle que le paramètre en entrée est un booléen
    */
    class BooleanControle {
        /**
        * Contrôle que le paramètre en entrée est un booléen
        * @param value {any} valeur à contrôler
        */
        isBoolean(value: any): boolean;
    }
}

declare module MyWay.Services.Controle {
    /**
    * Classe statique de contrôle de parametres (classe utilisée depuis les managers)
    * @classe StaticParametresControle
    * fonction : checkParameters – public - Permet de contrôler un ensemble de paramétres
    */
    class StaticParametresControle {
        /**
        * Permet de contrôler un ensemble de paramétres
        * Retourne une chaine de caractères correspondant à la description de l'ensemble des erreurs rencontrées (séparées par '/')
        * Si tous les contrôles sont OK, la chaine retournée est vide
        * @param parametres {parametre[]} Tableau de parametres à contrôler
        */
        static checkParameters(parametres: Parametre[]): string;
    }
    /**
    * Interface permettant de définir un paramétre à contrôler
    * @interface Controle.Parametre
    */
    interface Parametre {
        name: string;
        value: any;
        controle: CONTROLES;
        enumObject?: any;
        enumName?: any;
        objectType?: string;
    }
    /**
    * Enumération correspondant aux différents contrôles applicables sur une valeur
    * @enum Controle.CONTROLES
    */
    enum CONTROLES {
        isNotUndefinedAndNotNull = 0,
        isArray = 100,
        isBoolean = 200,
        isDate = 300,
        isAnEnumValue = 400,
        isAnEnumMember = 401,
        isAnEnumValueOrNullOrUndefined = 402,
        isFunction = 500,
        isFunctionOrNull = 501,
        isNumber = 600,
        isInt = 601,
        isObject = 700,
        isObjectOrNull = 701,
        isObjectOrNullOrUndefined = 702,
        isObjectSpecified = 703,
        isString = 800,
        isStringOrNull = 801,
        isStringOrNullOrUndefined = 802,
        isStringNotEmpty = 803,
        isStringNotEmptyOrNull = 804,
        isStringNotEmptyOrNullOrUndefined = 805,
    }
}


declare module MyWay.Services.Dates {
    enum FORMATS_DATE {
        aaaammjj = 10,
    }
    class DatesCommon extends Component.ComponentCommonBase {
        constructor(library: Component.IComponentLibrary);
        getDateDuJour(format: FORMATS_DATE): string;
        private isBissextile();
        private getNbJoursMois(annee, mois);
        CompareDates(date1: Date, date2: Date, Periode: string): number;
        addDate(d: Date, jours: number, mois?: number, annees?: number): Date;
    }
}


declare module MyWay.Services.Donnees {
    class DonneesCommon extends Component.ComponentCommonBase {
        constructor(library: Component.IComponentLibrary);
        Enum: EnumExtension;
        Array: ArrayExtension;
        Object: ObjectExtension;
        String: StringExtension;
    }
}


/**
* Module qui fournit des méthodes utilitaires sur les enum
* @module MyWay.Donnees
* classe : StaticEnumExtension - public - Classe statique qui fournit des méthodes utilitaires sur les enum (classe utilisée depuis les managers)
* classe : EnumExtension - public - Classe qui fournit des méthodes utilitaires sur les enum (classe utilisée depuis les agents)
*/
declare module MyWay.Services.Donnees {
    /**
    * Classe statique qui fournit des méthodes utilitaires sur les enum (classe utilisée depuis les managers)
    * @classe StaticEnumExtension
    * fonction : getNames – public - Permet de récupérer tous les membres d'un enum sous la forme d'un tableau de chaines de caractères
    * fonction : getName – public - Permet de récupérer un membre d'un enum correspondant à la valeur passée en paramètre
    * fonction : getValues – public - Permet de récupérer toutes les valeurs d'un enum sous la forme d'un tableau de nombres
    * fonction : getValue – public - Permet de récupérer une valeur d'un enum correspondant au membre passé en paramètre
    * fonction : getValuesAndNames - public - Permet de récupérer toutes les valeurs et tous les membres d'un enum sous la forme d'un tableau de valeur, membre
    */
    class StaticEnumExtension {
        /**
        * Permet de récupérer tous les membres d'un enum sous la forme d'un tableau de chaines de caractères
        * @param e {any} enum pour lequel on veut récupérer les différents membres
        * @return {Array<string>} Retourne les membres de l'enum
        */
        static getNames(e: any): Array<string>;
        /**
        * Permet de récupérer un membre d'un enum correspondant à la valeur passée en paramètre
        * @param e {any} enum pour lequel on veut récupérer le membre
        * @param value {number} valeur pour laquelle on veut récupérer le membre de l'enum
        * @return {string} Retourne le membre de l'enum correspondant à la valeur passée en paramètre
        */
        static getName(e: any, value: number): string;
        /**
        * Permet de récupérer toutes les valeurs d'un enum sous la forme d'un tableau de nombres
        * @param e {any} enum pour lequel on veut récupérer les différentes valeurs
        * @return {Array<number>} Retourne les valeurs de l'enum
        */
        static getValues(e: any): Array<number>;
        /**
        * Permet de récupérer une valeur d'un enum correspondant au membre passé en paramètre
        * @param e {any} enum pour lequel on veut récupérer la valeur
        * @param name {string} membre pour lequel on veut récupérer la valeur
        * @return {number} Retourne la valeur de l'enum correspondant au membre passé en paramètre
        */
        static getValue(e: any, name: string): number;
        /**
        * Permet de récupérer toutes les valeurs et tous les membres d'un enum sous la forme d'un tableau d'objets contenant les membres et les valeurs de l'enum
        * @param e {any} enum pour lequel on veut récupérer les différents membres et les différentes valeurs
        * @return {number} Retourne toutes les valeurs et tous les membres de l'enum
        */
        static getValuesAndNames(e: any): any[];
    }
    /**
    * Classe qui fournit des méthodes utilitaires sur les enum (classe utilisée depuis les agents)
    * @classe EnumExtension
    * fonction : getNames – public - Permet de récupérer tous les membres d'un enum sous la forme d'un tableau de chaines de caractères
    * fonction : getName – public - Permet de récupérer un membre d'un enum correspondant à la valeur passée en paramètre
    * fonction : getValues – public - Permet de récupérer toutes les valeurs d'un enum sous la forme d'un tableau de nombres
    * fonction : getValue – public - Permet de récupérer une valeur d'un enum correspondant au membre passé en paramètre
    * fonction : getValuesAndNames - public - Permet de récupérer toutes les valeurs et tous les membres d'un enum sous la forme d'un tableau de valeur, membre
    */
    class EnumExtension {
        /**
        * Permet de récupérer tous les membres d'un enum sous la forme d'un tableau de chaines de caractères
        * @param e {any} enum pour lequel on veut récupérer les différents membres
        * @return {Array<string>} Retourne les membres de l'enum
        */
        getNames(e: any): Array<string>;
        /**
        * Permet de récupérer un membre d'un enum correspondant à la valeur passée en paramètre
        * @param e {any} enum pour lequel on veut récupérer le membre
        * @param value {number} valeur pour laquelle on veut récupérer le membre de l'enum
        * @return {string} Retourne le membre de l'enum correspondant à la valeur passée en paramètre
        */
        getName(e: any, value: number): string;
        /**
        * Permet de récupérer toutes les valeurs d'un enum sous la forme d'un tableau de nombres
        * @param e {any} enum pour lequel on veut récupérer les différentes valeurs
        * @return {Array<number>} Retourne les valeurs de l'enum
        */
        getValues(e: any): Array<number>;
        /**
        * Permet de récupérer une valeur d'un enum correspondant au membre passé en paramètre
        * @param e {any} enum pour lequel on veut récupérer la valeur
        * @param name {string} membre pour lequel on veut récupérer la valeur
        * @return {number} Retourne la valeur de l'enum correspondant au membre passé en paramètre
        */
        getValue(e: any, name: string): number;
        /**
        * Permet de récupérer toutes les valeurs et tous les membres d'un enum sous la forme d'un tableau d'objets contenant les membres et les valeurs de l'enum.
        * @param e {any} enum pour lequel on veut récupérer les différents membres et les différentes valeurs
        * @return {number} Retourne toutes les valeurs et tous les membres de l'enum
        */
        getValuesAndNames(e: any): any[];
    }
}


/**
* Module qui fournit des méthodes utilitaires sur les tableaux
* @module MyWay.Donnees.ArrayExtension
* classe : StaticArrayExtension - public - Classe statique qui fournit des méthodes utilitaires sur les tableaux (classe utilisée depuis les managers)
* classe : ArrayExtension - public - Classe qui fournit des méthodes utilitaires sur les tableaux (classe utilisée depuis les agents)
*/
declare module MyWay.Services.Donnees {
    /**
    * Classe statique qui fournit des méthodes utilitaires sur les tableaux (classe utilisée depuis les managers)
    * @classe StaticArrayExtension
    * fonction : filtrer – public - Permet de filtrer les éléments dans un tableau en fonction des critères définis
    */
    class StaticArrayExtension {
        /**
        * Permet de filtrer les éléments dans un tableau en fonction des critères définis
        * @param collection {Array<any>} tableau contenant les données à filtrer
        * @param predicat {function} Action de filtre à appliquer sur chaque donnée contenue dans le tableau (la donnée courante est transmise en paramètre: data)
        *                            Doit retourner true si la donnée répond aux critères, false si la données ne répond pas aux critères et null en cas d'erreur
        * @return {Array<any>} Retourne les éléments du tableau qui correspondent au filtre (null en cas d'erreur)
        */
        static filtrer(collection: Array<any>, predicat: (data: any) => boolean): Array<any>;
    }
    /**
    * Classe qui fournit des méthodes utilitaires sur les tableaux (classe utilisée depuis les agents)
    * @classe ArrayExtension
    * fonction : filtrer – public - Permet de filtrer les éléments dans un tableau en fonction des critères définis
    */
    class ArrayExtension {
        /**
        * Permet de filtrer les éléments dans un tableau en fonction des critères définis
        * @param collection {Array<any>} tableau contenant les données à filtrer
        * @param predicat {function} action de filtre à appliquer sur chaque donnée contenue dans le tableau (la donnée courante est transmise en paramètre: data)
        * @return {Array<any>} Retourne les éléments du tableau qui correspondent au filtre
        */
        filtrer(collection: Array<any>, predicat: (data: any) => boolean): Array<any>;
    }
}


/**
* Module qui fournit des méthodes utilitaires sur les objets
* @module MyWay.Donnees.ObjectExtension
* classe : StaticObjectExtension - public - Classe statique qui fournit des méthodes utilitaires sur les objets (classe utilisée depuis les managers)
* classe : ObjectExtension - public - Classe qui fournit des méthodes utilitaires sur les objets (classe utilisée depuis les agents)
*/
declare module MyWay.Services.Donnees {
    /**
    * Classe statique qui fournit des méthodes utilitaires sur les objets (classe utilisée depuis les managers)
    * @classe StaticObjectExtension
    * fonction : getTaille – public - Retourne la taille d'un objet
    */
    class StaticObjectExtension {
        /**
        * Retourne la taille d'un objet
        * @param objet {any} objet dont on veut calculer la taille
        * @return {number} Retourne la taille de l'objet
        */
        static getTaille(objet: any): number;
    }
    /**
    * Classe qui fournit des méthodes utilitaires sur les objets (classe utilisée depuis les agents)
    * @classe ObjectExtension
    * fonction : getTaille – public - Retourne la taille d'un objet
    */
    class ObjectExtension {
        /**
        * Retourne la taille d'un objet
        * @param objet {any} objet dont on veut calculer la taille
        * @return {number} Retourne la taille de l'objet
        */
        getTaille(objet: any): number;
    }
}


/**
* Module qui fournit des méthodes utilitaires sur les chaines de caractères
* @module MyWay.Donnees.StringExtension
* classe : StaticStringExtension - public - Classe statique qui fournit des méthodes utilitaires sur les string (classe utilisée depuis les managers)
* classe : StringExtension - public - Classe qui fournit des méthodes utilitaires sur les string (classe utilisée depuis les agents)
*/
declare module MyWay.Services.Donnees {
    /**
    * Classe statique qui fournit des méthodes utilitaires sur les string (classe utilisée depuis les managers)
    * @classe StaticStringExtension
    * fonction : getEmptyStringIfNotStringOrGetItSelf – public - Retourne une chaine de caractères vide si le paramètre en entrée n'est pas une chaine de caractère. Retourne le paramètre en entrée sinon.
    */
    class StaticStringExtension {
        /**
        * Retourne une chaine de caractères vide si le paramètre en entrée n'est pas une chaine de caractère. Retourne le paramètre en entrée sinon.
        * @param valueToTest {any} valeur à tester/modifer
        * @return {number} Retourne une chaine de caractères vide si le paramètre en entrée n'est pas une chaine de caractère. Retourne le paramètre en entrée sinon
        */
        static getEmptyStringIfNotStringOrGetItSelf(valueToTest: any): string;
    }
    /**
    * Classe qui fournit des méthodes utilitaires sur les objets (classe utilisée depuis les agents)
    * @classe ObjectExtension
    * fonction : getTaille – public - Retourne la taille d'un objet
    */
    class StringExtension {
        /**
        * Retourne une chaine de caractères vide si le paramètre en entrée n'est pas une chaine de caractère. Retourne le paramètre en entrée sinon.
        * @param valueToTest {any} valeur à tester/modifer
        * @return {number} Retourne une chaine de caractères vide si le paramètre en entrée n'est pas une chaine de caractère. Retourne le paramètre en entrée sinon
        */
        getEmptyStringIfNotStringOrGetItSelf(valueToTest: any): string;
    }
}


/**
* Module de gestion des données délocalisées (module commun aux agents et aux managers)
* @module MyWay.Services.DonneesDelocalisees
* enum : CRITERES_OPERATEUR - public - Enumération correspondant aux différents opérateurs applicables sur un critère
* interface : ObjectDataCritere - public - Description d'un critère de recherche pour un objet de données
*/
declare module MyWay.Services.DonneesDelocalisees {
    /**
    * Enumération correspondant aux différents opérateurs applicables sur un critère
    * @enum DonneesDelocalisees.CRITERES_OPERATEUR
    */
    enum CRITERES_OPERATEUR {
        EGAL = 0,
        CONTIENT = 1,
    }
    /**
    * Interface permettant de définir un critère de recherche pour un objet de données
    * @interface DonneesDelocalisees.ObjectDataCritere
    */
    interface ObjectDataCritere {
        propriete: string;
        valeur: string;
        operateur: CRITERES_OPERATEUR;
    }
}


declare module MyWay.Services.Fichier {
    /**
    * Enumération correspondant aux différents types de fichier
    * Les valeurs inférieures à 100 sont réservées aux types de fichier autorisés pour la génération de document (API Impression)
    * @enum Fichier.TYPE_FICHIER
    */
    enum TYPE_FICHIER {
        PDF = 0,
        PDF_EMBED = 5,
        PDFA_1A = 10,
        PDFA_1B = 15,
        PDFX_1_2001 = 20,
        PDFX_1A_2001 = 25,
        PDFX_1A_2003 = 30,
        PDFX_3_2002 = 35,
        PDFX_3_2003 = 40,
        JSON = 105,
        TAR_GZ = 110,
    }
    /**
    * Enumération correspondant aux différents types de données à sauvegarder
    * @enum Fichier.TYPE_DONNEES_A_SAUVER
    */
    enum TYPE_DONNEES_A_SAUVER {
        BLOB = 0,
        BASE64 = 1,
    }
}


/**
* Module de gestion technique des habilitations
* @module MyWay.Services.Habilitation
*/
declare module MyWay.Services.Habilitation {
    class HabilitationModel {
        [code: string]: boolean;
        constructor(_code: string, _valeur: boolean);
    }
    /**
     * DTO du service REST habilitation
     */
    class HabilitationDTOModel {
        codesHabilites: Object;
        codesNonHabilites: Object;
        constructor(_codesHabilites: string, _codesNonHabilites: string);
    }
}


/**
* Module de gestion des impressions (module commun aux agents et aux managers)
* @module MyWay.Services.Impression
* @enum RESTITUTION_VERSION - public - Enumération correspondant aux différentes versions du serveur de restitution
* @enum GENERATION_ACTION - public - Enumération correspondant aux différentes actions du service de génération
* @enum GENERATION_IMPRESSION_ACTION - public - Enumération correspondant aux différentes actions du service de génération et d'impression
* @enum TYPE_IMAGE - public - Enumération correspondant aux différentes types de données images possibles dans le flux de données d'impression
* @interface DocumentGenere - public - Interface permettant de décrire un objet document généré
* @interface GenerationParams - public - Interface permettant de définir les paramètres de génération d'un document
* @interface ParametresGenerationSysteme - public - Interface permettant de définir les paramètres système pour la génération d'un document
* @interface ParametresGenerationObligatoires - public - Interface permettant de définir les paramètres obligatoires pour la génération d'un document
* @interface ParametresGenerationFichier - public - Interface permettant de définir les paramètres nécessaires à la génération d'un fichier d'impression
* @interface ParametresGenerationOptionnels - public - Interface permettant de définir les paramètres optionnels pour la génération d'un document
* @interface MentionsLegales - public - Interface permettant de définir les mentions légales
* @interface Archivage - public - Interface permettant d’archiver lors de la génération du fichier
* @interface GceContextSoapHeader - public - Interface contenant les  informations d'entête du contexte SOAP
* @interface AQstnCreerDoc - public - Interface contenant les questions pour la création de document
* @interface DonnCntx - public - Interface contenant les données contextuelles
* @interface Document - public - Interface permettant de créer un document
* @interface ProprietesDoc - public - Interface contenant les métadonnées du document à créer
* @interface FichierDoc - public - Interface contenant les propriétés propres à la pièce-jointe du document à créer
* @interface BlocGenerique - public - Interface
* @interface ImpressionParams - public - Interface permettant de définir les paramètres d'impression d'un document
* @interface ParametresImpressionObligatoires - public - Interface permettant de définir les paramètres obligatoires pour l'impression d'un document
* @interface ParametresImpressionOptionnels - public - Interface permettant de définir les paramètres optionnels pour l'impression d'un document
* @interface GenerationImpressionParams - public - Interface permettant de définir les paramètres de génération et d'impression d'un document
* @interface ParametresGenerationImpressionObligatoires - public - Interface permettant de définir les paramètres obligatoires pour la génération et l'impression d'un document
* @interface ParametresGenerationImpressionOptionnels - public - Interface permettant de définir les paramètres optionnels pour la génération et l'impression d'un document
*/
declare module MyWay.Services.Impression {
    /**
    * Enumération correspondant aux différentes versions du serveur de restitution
    * @enum Impression.RESTITUTION_VERSION
    */
    enum RESTITUTION_VERSION {
        /** Version 180 du serveur de restitution */
        V180 = 180,
    }
    /**
    * Enumération correspondant aux différentes actions de génération possibles
    * @enum Impression.GENERATION_ACTION
    */
    enum GENERATION_ACTION {
        /** Permet d'archiver le document généré en GED */
        archiver = 10,
        /** Permet d'archiver en GED et d'obtenir le fichier généré */
        archiverAndGetFichier = 20,
        /** Permet d'obtenir le fichier généré */
        getFichier = 30,
    }
    /**
    * Enumération correspondant aux différentes actions de génération et d'impression possibles
    * @enum Impression.GENERATION_IMPRESSION_ACTION
    */
    enum GENERATION_IMPRESSION_ACTION {
        /** Permet d'archiver en GED et d'obtenir le fichier généré et imprimé */
        archiverAndGetFichier = 20,
        /** Permet d'obtenir le fichier généré et imprimé */
        getFichier = 30,
    }
    /**
    * Enumération correspondant aux différentes types de données images possibles dans le flux de données d'impression
    * @enum Impression.TYPE_IMAGE
    */
    enum TYPE_IMAGE {
        /** Nom de l'image */
        Id = 0,
        /** Image en Base 64 */
        Flux = 1,
    }
    /**
    * Interface permettant de décrire un objet document généré
    * @interface Impression.DocumentGenere
    */
    interface DocumentGenere {
        /**
        * L'identifiant d'archivage en GED sous forme de chaine de caractères<br />
        * <i>null</i> si l'archivage n’a pas été demandé
        */
        IdntPJ: any;
        /**
        * Le fichier généré sous forme de chaine de caractères (BASE64)<br />
        * <i>null</i> si aucun retour de fichier n’a été demandé
        */
        Fichier: any;
        /**
        * Date de la création du document généré<br />
        * NE PAS UTILISER, VA ETRE SUPPRIME
        */
        DateCrtn: string;
    }
    /**
    * Interface permettant de définir les paramètres de génération d'un document
    * @interface Impression.GenerationParams
    */
    interface GenerationParams {
        /** Permet de définir les paramètres système pour la génération d'un document */
        systeme: ParametresGenerationSysteme;
        /** Permet de définir les paramètres obligatoires pour la génération d'un document */
        obligatoires: ParametresGenerationObligatoires;
        /** Permet de définir les paramètres optionnels pour la génération d'un document */
        optionnels: ParametresGenerationOptionnels;
    }
    /**
    * Interface permettant de définir les paramètres système pour la génération d'un document
    * @interface Impression.ParametresGenerationSysteme
    */
    interface ParametresGenerationSysteme {
        /** Permet de définir le nom de la classe d'impression */
        typeName: string;
        /** Permet de définir le nom complet de la classe d'impression */
        typeFullName: string;
        /** Permet de définir la librairie d'impression */
        librairie: string;
    }
    /**
    * Interface permettant de définir les paramètres obligatoires pour la génération d'un document
    * @interface Impression.ParametresGenerationObligatoires
    */
    interface ParametresGenerationObligatoires {
        /**
        * Permet de définir l'action à réaliser lors de la génération<br />
        * Si ces actions impliquent l’obtention d’un fichier généré alors le paramètre optionnel <i>nomFichier</i> doit être renseigné
        */
        action: GENERATION_ACTION;
        /** Permet de définir les paramètres nécessaires à la génération d'un fichier d'impression */
        parametresGenerationFichier: ParametresGenerationFichier;
    }
    /**
    * Interface permettant de définir les paramètres nécessaires à la génération d'un fichier d'impression
    * @interface Impression.ParametresGenerationFichier
    */
    interface ParametresGenerationFichier {
        /** Permet de définir les différents types de fichier (PDF uniquement) */
        typeFichier: MyWay.Services.Fichier.TYPE_FICHIER;
        /** Permet de définir les différentes versions du serveur de restitution */
        restitutionVersion: RESTITUTION_VERSION;
        /**
        * Permet de définir le chemin relatif du sous répertoire contenant le modèle à utiliser<br />
        * Valoriser à "" pour utiliser le répertoire racine
        */
        sousRepModele: string;
    }
    /**
    * Interface permettant de définir les paramètres optionnels pour la génération d'un document
    * @interface Impression.ParametresGenerationOptionnels
    */
    interface ParametresGenerationOptionnels {
        /**
        * Permet de définir les paramètres nécessaires à la génération du fichier d’impression<br />
        * Si non défini, c’est le flux XML avant génération qui est archivé
        */
        nomFichier?: string;
        /**
        * Permet de définir les paramètres nécessaires à l’alimentation automatique des mentions légales : la data correspondant au nom passé en paramètre sera automatiquement alimentée<br />
        * Si non défini, les mentions légales ne seront pas automatiquement injectées lors de la génération du flux XML
        */
        mentionsLegales?: MentionsLegales;
        /**
        * Permet de définir les paramètres nécessaires à l'archivage en GED d'un document généré<br />
        * Ne pas oublier de mettre <i>action</i> de <i>ParametresGenerationObligatoires</i> à <i>GENERATION_ACTION.archiver</i> ou <i>GENERATION_ACTION.archiverAndGetFichier</i>
        */
        archivage?: Archivage;
        /**  */
        blocGenerique?: BlocGenerique;
    }
    /**
    * Interface permettant de définir les mentions légales
    * @interface Impression.MentionsLegales
    */
    interface MentionsLegales {
        /**  */
        numEtablissement: string;
    }
    /**
    * Interface permettant d’archiver lors de la génération du fichier.
    * @interface Impression.Archivage
    */
    interface Archivage {
        /** Permet de définir les paramètres contenant les informations d'entête du contexte SOAP */
        gceContextSoapHeader?: GceContextSoapHeader;
        /** Permet de définir les paramètres contenant les questions pour la création d'un document */
        aQstnCreerDoc: AQstnCreerDoc;
    }
    /**
    * Interface contenant les informations d'entête du contexte SOAP
    * @interface Impression.GceContextSoapHeader
    */
    interface GceContextSoapHeader {
        /**  */
        codePrflAgnt?: string;
        /**  */
        codeTypeIdntExtn?: string;
        /**  */
        extendedProperties?: string;
        /**  */
        idntAgnt?: string;
        /**  */
        idntAgntAcces?: string;
        /**  */
        idntAgntTech?: string;
        /**  */
        idntEtabEntt?: string;
        /**  */
        idntExtnConx?: string;
        /**  */
        idntInteEdsAgnt?: string;
        /**  */
        refrExtnAgnt?: string;
        /**  */
        refrPosteFoncAgnt?: string;
        /**  */
        typeCanlAcces?: string;
        /**  */
        typePrflAgnt?: string;
    }
    /**
    * Interface contenant les questions pour la création de document
    * @interface Impression.AQstnCreerDoc
    */
    interface AQstnCreerDoc {
        /** Permet de définir les paramètres contenant les données contextuelles du document à archiver */
        donnCntx: DonnCntx;
        /** Permet de définir les paramètres du document à archiver */
        document: Document;
    }
    /**
    * Interface contenant les données contextuelles
    * @interface Impression.DonnCntx
    */
    interface DonnCntx {
        /**
        * Permet de définir le code Banque sous lequel l'établissement est répertorié par la Banque de France<br />
        * Si pas renseigné, récupérer dans le contexte
        */
        codeEtablissement?: string;
        /** Identifiant de l'application à l'origine de la demande */
        idntCmpstApplf: string;
    }
    /**
    * Interface permettant de créer un document
    * @interface Impression.Document
    */
    interface Document {
        /** Permet de définir les paramètres contenant les métadonnées du document à archiver */
        proprietesDoc: ProprietesDoc;
        /** Permet de définir les paramètres contenant les propriétés propres à la pièce jointe du document à archiver */
        fichierDoc: FichierDoc;
    }
    /**
    * Interface contenant les métadonnées du document à créer
    * @interface Impression.ProprietesDoc
    */
    interface ProprietesDoc {
        /** Permet de définir l'identifiant du lot */
        idntLot?: string;
        /**
        * Permet de définir le mode d'acquisition du document. Prend les valeurs :
        * <ol>
        *     <li>Signature Agence</li>
        *     <li>Signature à distance </li>
        *     <li>RAD-LAD CE</li>
        *     <li>Numérisation CE </li>
        *     <li>Reprise de masse </li>
        *     <li>Flux de masse </li>
        *     <li>Numérisation externe</li>
        *     <li>Injection Temps Réel</li>
        * </ol>
        * Valoriser à 8 si ActionDocument = 4<br />
        * Ce paramètre devient obligatoire si l'archivage se fait en GED définitive (codeTypeStck = "A")
        */
        codeTypeModeAcqs?: string;
        /**
        * Permet de définir le moyen d'acquisition du document. Prend les valeurs:
        * <ol>
        *     <li>Fax</li>
        *     <li>E-mail</li>
        *     <li>Editique </li>
        *     <li>Numérique</li>
        *     <li>Papier</li>
        * </ol>
        * Valoriser à 3 si ActionDocument = 4<br />
        * Ce paramètre devient obligatoire si l'archivage se fait en GED définitive
        */
        codeTypeOrigAcqs?: string;
        /** Permet de définir la nature du document */
        codeTypeNatrDoc: string;
        /**
        * Permet de définir le type d'attributaire :
        * <ol>
        *    <li>Attributaire type contrat</li>
        *    <li>Attributaire type personne particulier</li>
        *    <li>Attributaire type personne Professionnel</li>
        *    <li>Attributaire type personne Morale </li>
        *    <li>Attributaire type relation économique </li>
        *    <li>Attributaire type demande de financement</li>
        *    <li>Attributaire type entité titulaire</li>
        *    <li>Attributaire type Sinistre assurance</li>
        *    <li>Attributaire type dossier temporaire VMC</li>
        *    <li>Attributaire type prospect BDR</li>
        *    <li>Attributaire type bénéficiaire assurance vie</li>
        *    <li>Dossier de fraude interne</li>
        *    <li>Document d'entreprise</li>
        * </ol>
        */
        codeTypeAttrb: string;
        /**
        * Si Type attributaire égal à :
        * <ol>
        *    <li>Identifiant du contrat souscrit</li>
        *    <li>Identifiant de la personne</li>
        *    <li>Identifiant de la personne</li>
        *    <li>Identifiant de la personne</li>
        *    <li>Identifiant de la relation Economique</li>
        *    <li>Identifiant de la demande de financement</li>
        *    <li>Identifiant de l'entité titulaire</li>
        *    <li>Identifiant d'un sinistre Assurance</li>
        *    <li>Identifiant d'un dossier temporaire</li>
        *    <li>Identifiant Prospect BDR</li>
        *    <li>Attributaire bénéficiaire assurance vie</li>
        *    <li>Dossier de fraude interne</li>
        *    <li>Document d'entreprise</li>
        * </ol>
        */
        idntAttrb: string;
        /**
        * Permet de définir l'identifiant secondaire de l'attributaire<br />
        * Il n'est renseigné que pour certains types d'attributaire<br />
        * Pour le code type=3 (Professionnel), contient le numéro chrono professionnel… */
        idntAttrSecn?: string;
        /**
        * Permet de définir, pour un document issu d'une numérisation, la "date de délivrance" située sur la pièce numérisée<br />
        * Sinon, défini la date de création du fichier (généré ou saisie) */
        dateDeliv: Date;
        /** Permet de définir, dans le cas d'un document issu d'une numérisation, la date à laquelle le document a été numérisé */
        dateNumr: Date;
        /** Permet de définir, dans le cas d'un document issu d'une numérisation, la date à laquelle le chargé d'affaire à pris possession du document origine */
        dateColt?: Date;
        /**
        * Permet de définir la date à laquelle le document pourra être purgé<br />
        * Si non renseignée, document non purgé */
        datePerm?: Date;
        /** Permet de définir la date d'élimination du document (date de purge) */
        dateFinVald?: Date;
        /** Permet de définir le numéro de l'archive physique */
        numUnitePhysique?: string;
        /** Permet de définir la position dans l'archive physique */
        posUnitePhysique?: number;
        /**
        * Exemples:
        * <ul style="list-style-type: none;">
        *    <li>Pour "particulier" correspond à DESIGNATION PARTICULIER</li>
        *    <li>Pour "Professionnel" correspond à NOM COMMERCIAL</li>
        *    <li>Pour "personne morale" correspond à RAISON SOCIALE</li>
        *    <li>Pour "Contrat" correspond à INTITULE ENTITE TITULAIRE</li>
        *    <li>Pour "Relation Economique" correspond à INTITULE RELATION ECONOMIQUE</li>
        *    <li>Pour "Demande de Financement" correspond OBJET DE LA DEMANDE DE FINANCEMENT</li>
        * </ul>
        */
        inttAttr: string;
        /**
        * Permet de définir la date qualifiant l'attributaire<br />
        * Exemples :
        * <ul style="list-style-type: none;">
        *    <li>Si code type attributaire = 2 (particulier) correspond à la date de naissance</li>
        *    <li>Si code attributaire = 4 (personne morale) date création entreprise</li>
        *    <li>etc.</li>
        * </ul>
        */
        dateAttr?: Date;
        /** Permet de définir le numéro d'identification du poste fonctionnel au sein d'un Etablissement */
        refrPosteFoncAcqs?: string;
        /** Permet de définir la description sommaire du document */
        descDoc?: string;
        /**
        * Permet de définir la zone de stockage où sera créé le document, à savoir :
        * <ul style="list-style-type: none;">
        *    <li>A : archivage (par défaut si rubrique non renseignée)</li>
        *    <li>T : transitoire</li>
        *    <li>L : temporaire</li>
        * </ul>
        */
        codeTypeStck?: string;
        /**
        * Code permettant le forçage du code accessibilité associé à la nature du document<br />
        * <b>!!! NON GERE ACTUELLEMENT !!!!</b>
        */
        codeForcAccs?: string;
        /**
        * Permet de définir le mode de signature. Prend les valeurs :
        * <ol start="0">
        *    <li>Non signé </li>
        *    <li>Signature papier </li>
        *    <li>Signature électronique</li>
        * </ol>
        * interface Ce paramètre devient obligatoire si l'archivage se fait en GED définitive
        */
        codeTypeSign?: string;
    }
    /**
    * Interface contenant les propriétés propres à la pièce-jointe du document à créer
    * @interface Impression.FichierDoc
    */
    interface FichierDoc {
        /** Nom du document qui sera stocké dans la GED définitive (avec l'extension) */
        nomFich: string;
    }
    /**
    * Interface
    * @interface Impression.BlocGenerique
    */
    interface BlocGenerique {
        /**  */
        idBloc?: string;
        /**  */
        dateBloc: Date;
    }
    /**
    * Interface permettant de définir les paramètres d'impression d'un document
    * @interface Impression.ImpressionParams
    */
    interface ImpressionParams {
        /** Permet de définir les paramètres obligatoires pour l'impression d'un document */
        obligatoires: ParametresImpressionObligatoires;
        /** Permet de définir les paramètres optionnels pour l'impression d'un document */
        optionnels: ParametresImpressionOptionnels;
    }
    /**
    * Interface permettant de définir les paramètres obligatoires pour l'impression d'un document
    * @interface Impression.ParametresImpressionObligatoires
    */
    interface ParametresImpressionObligatoires {
        /** Permet de définir le nom du fichier imprimé */
        nomFichier: string;
    }
    /**
    * Interface permettant de définir les paramètres optionnels pour l'impression d'un document
    * @interface Impression.ParametresImpressionOptionnels
    */
    interface ParametresImpressionOptionnels {
        /**
        * Permet de définir les paramètres de l'ActiveX d'impression
        */
        parametreActiveX?: ParametresActiveX;
    }
    /**
    * Interface permettant de définir les paramètres de génération et d'impression d'un document
    * @interface Impression.GenerationImpressionParams
    */
    interface GenerationImpressionParams {
        /** Permet de définir les paramètres système pour la génération et l'impression d'un document */
        systeme: ParametresGenerationSysteme;
        /** Permet de définir les paramètres obligatoires pour la génération et l’impression d'un document */
        obligatoires: ParametresGenerationImpressionObligatoires;
        /** Permet de définir les paramètres optionnels pour la génération et l’impression d'un document */
        optionnels: ParametresGenerationImpressionOptionnels;
    }
    /**
    * Interface permettant de définir les paramètres obligatoires pour la génération et l'impression d'un document
    * @interface Impression.ParametresGenerationImpressionObligatoires
    */
    interface ParametresGenerationImpressionObligatoires {
        /** Permet de définir les actions à réaliser lors de la génération et de l’impression */
        action: GENERATION_IMPRESSION_ACTION;
        /** Permet de définir le nom du fichier téléchargé par le navigateur si l’impression n’est pas possible (ex : exécution du service sur une tablette) */
        nomFichier: string;
        /** Permet de définir les paramètres nécessaires à la génération du fichier d’impression */
        parametresGenerationFichier: MyWay.Services.Impression.ParametresGenerationFichier;
    }
    /**
    * Interface permettant de définir les paramètres optionnels pour la génération et l'impression d'un document
    * @interface Impression.ParametresGenerationImpressionOptionnels
    */
    interface ParametresGenerationImpressionOptionnels {
        /**
        * Permet de définir le paramètre nécessaire à l'archivage en GED d'un document généré et imprimé<br />
        * Ne pas oublier de mettre <i>action</i> de <i>ParametresGenerationImpressionObligatoires</i> à <i>GENERATION_IMPRESSION_ACTION.archiverAndGetFichier</i>
        */
        archivage?: Archivage;
        /**
        * Permet de définir les paramètres de l'ActiveX d'impression
        */
        parametreActiveX?: ParametresActiveX;
        /** @DEPRECATED Permet de définir si la génération se fait en local */
        local?: boolean;
    }
    /**
    * Interface permettant de définir les paramètres de l'ActiveX d'impression
    * @interface Impression.ParametresActiveX
    */
    interface ParametresActiveX {
        /**
        * Permet d'afficher ou non le bouton <i>Annuler</i> dans l'ActiveX d'impression<br />
        * Si non défini, le bouton ne sera pas affiché
        */
        annul?: boolean;
        /**
        * Permet d'afficher ou non le bouton icône <i>Aperçu</i> dans l'ActiveX d'impression<br />
        * Si non défini, le bouton ne sera pas affiché
        */
        voir?: boolean;
        /**
        * Permet d'afficher ou non le bouton icône <i>Enregistrer</i> dans l'ActiveX d'impression<br />
        * Si non défini, le bouton ne sera pas affiché
        */
        enregistrer?: boolean;
        /**
        * Permet de définir le nombre de copies par défaut du document à imprimer
        * Si non défini, le nombre de copies est 1
        */
        nbcopiesdef?: number;
        /**
        * Permet de définir le nombre de copies minimum pour le document à imprimer
        * Si non défini, le nombre de copies minimum est 1
        */
        mincop?: number;
        /** Permet de définir le nombre de copies maximum pour le document à imprimer */
        maxcop?: number;
    }
}


declare module MyWay.Services.Interop {
    class InfoFichier {
        DateModification: Date;
        Taille: number;
        constructor();
    }
    class ExecutableWrapper {
        ExecApp: ExecApp;
        ExecTransaction: ExecTransaction;
        ExecServ: ExecServ;
        ExecWeb: ExecWeb;
        constructor(execapp: ExecApp, exectransaction: ExecTransaction, execserv: ExecServ, execweb: ExecWeb);
    }
    class ExecApp {
        Executable: string;
        constructor(executable: string);
    }
    class ExecTransaction {
        Numero: string;
        constructor(numero: string);
    }
    class ExecServ {
        CodeSortie: string;
        constructor(codesortie: string);
    }
    class ExecWeb {
        Url: string;
        Libelle: string;
        constructor(url: string, libelle: string);
    }
    class ContexteMyway {
        ProcessId: string;
        StepId: string;
        constructor(processId: string, stepId: string);
    }
    class ContexteClient {
        NumeroClient: string;
        Plan: number;
        constructor(numeroClient: string, plan: number);
    }
    class JsonStringArray {
        Valeur: string[];
        constructor(tableau: string[]);
    }
}

declare module MyWay.Services.Libelle {
    interface ILibelleService {
        afficherMessage(codeLibelle: string, typeAffichage: TYPE_AFFICHAGE, valeurs?: string[], callback?: () => void, callbackClic?: (any) => void): void;
        constituerLibelle(codeLibelle: string, callback: (any) => void, valeurs?: string[]): void;
    }
    enum TYPE_AFFICHAGE {
        ERREUR = 10,
        AVERTISSEMENT = 30,
        INFORMATION = 50,
        OUI_NON = 70,
        OUI_NON_ANNULER = 90,
        VALIDER_ANNULER = 110,
        ANNULER = 120,
        VIDE = 140,
    }
}

declare module MyWay.Services.Libelle {
    class LibelleModel {
        static COM: {
            MESSAGE_SANS_VARIABLE: string;
            RESULTATS: string;
            ERREUR_PARAMETRE_MAUVAIS_TYPE: string;
            ERREUR_PARAMETRES: string;
            ERREUR_FRAMEWORK: string;
            ERREUR_SERVEUR: string;
            ERREUR_CONFIGURATION_PAS_DE_CONFIG: string;
            ERREUR_HABILITATION_MAUVAIS_FORMAT: string;
            ERREUR_HABILITATION_CODE_INCONNU: string;
            ERREUR_HABILITATION_PARAMETRES_INSUFFISANTS: string;
            ERREUR_HABILITATION_AUTHENTIFICATION_MANQUANTE: string;
            ERREUR_INDEXED_DB_NON_SUPPORTE: string;
            ERREUR_INDEXED_DB_GENERIQUE: string;
            ERREUR_INDEXED_DB_SUPPRESSION_IMPOSSIBLE: string;
            ERREUR_INDEXED_DB_ACCES_IMPOSSIBLE: string;
            ERREUR_INDEXED_DB_LECTURE_IMPOSSIBLE: string;
            ERREUR_INDEXED_DB_AJOUT_IMPOSSIBLE: string;
            ERREUR_INDEXED_DB_MAJ_IMPOSSIBLE: string;
            ERREUR_INDEXED_DB_REQUETE_IMPOSSIBLE_INDEX: string;
            ERREUR_INDEXED_DB_REQUETE_IMPOSSIBLE_CRITERE: string;
            ERREUR_INDEXED_DB_CALCUL_TAILLE: string;
            ERREUR_CONTEXTE_RECUP_CODE_ETAB_IMPOSSIBLE: string;
            ERREUR_CONTEXTE_RECUP_ID_AGENCE_IMPOSSIBLE: string;
            ERREUR_DONNEESDELOC_OBJET_MAL_FORME: string;
            ERREUR_DONNEESDELOC_PROPRIETE_ABSENTE: string;
            ERREUR_DONNEESDELOC_RECUP_DERNMAJ_IMPOSSIBLE: string;
            ERREUR_LISA_NEXT_IMPOSSIBLE: string;
            ERREUR_LISA_START_IMPOSSIBLE: string;
            ERREUR_LISA_GETPROCESSES_IMPOSSIBLE: string;
            ERREUR_LISA_GETTOOLS_IMPOSSIBLE: string;
            ERREUR_NUMERISATION_RECUP_CODE_ETAB_IMPOSSIBLE: string;
            ERREUR_NUMERISATION_RECUP_DONNEES_DELOCALISEES_IMPOSSIBLE: string;
            ERREUR_INTEROP_SERVICE_LOCAL_APPEL_IMPOSSIBLE: string;
            ERREUR_FICHIER_PARAMETRE_DATA_VIDE: string;
            ERREUR_FICHIER_PARAMETRE_B64_VIDE: string;
            ERREUR_APPLICATION: string;
            ERREUR_APPLICATION_CODE_NON_RENSEIGNE: string;
            ERREUR_APPLICATION_TYPE_INCONNU: string;
            ERREUR_APPLICATION_DEMARRAGE_IMPO: string;
            ERREUR_APPLICATION_MAINTENANCE: string;
            ERREUR_MOBILITE_RECUP_RESEAU_IMPOSSIBLE: string;
            ERREUR_MOBILITE_RECUP_LISTE_PERIPH_IMPOSSIBLE: string;
            ERREUR_MOBILITE_RECUP_LISTE_TABLETTES_SIGNATURES_IMPOSSIBLE: string;
        };
        static TEC: {
            CHAINE_VIDE: string;
            VALIDATION_ARRAY: string;
            IMPRESSION_GENERATION_EN_COURS: string;
            IMPRESSION_IMPRESSION_EN_COURS: string;
            IMPRESSION_GENERATION_IMPRESSION_EN_COURS: string;
            NUMERISATION_EN_COURS: string;
        };
    }
}


declare module MyWay.Services.Lisa {
    class LisaCallbackResult {
        processId: string;
        codeProcessus: string;
        codeEtape: string;
        finDeProcessus: boolean;
        sousProcessusDemarre: string;
        etapeCourante: Context.IProcessStep;
        retourEtapePrecedente: boolean;
    }
    interface IInitialisationData {
        context?: MyWay.Services.Context.IContextKeyValuePair[];
        displayName?: string;
        subProcessCode?: string;
        processusAOuvrirDansUneNouvelleInstance?: boolean;
    }
    interface IInfoEtape {
        codeTechnique: string;
        codeMetier: string;
    }
    interface IInfoProcessus {
        dateExport: string;
        codeProcessus: string;
        identifiantAgent: string;
        nomProcessus: string;
        etapes: IInfoEtape[];
    }
}


/**
* Module de gestion de la mobilite (module commun aux agents et aux managers)
* @module MyWay.Services.Mobilite
*/
declare module MyWay.Services.Mobilite {
    /**
     * Liste des diférents type de connexion possible
     */
    enum TYPE_RESEAU {
        DECONNECTE = 0,
        CONNECTE = 99,
    }
    /**
     * Liste des diférents type de périphérique détecté sur le poste
     */
    enum TYPE_PERIPHERIQUE {
        TABLETTE_SIGNATURE = 0,
        CAISSE_AUTO = 1,
    }
    /**
    * Correspond aux types de périphériques renvoyés par la méthode GetPeripheriques()
    */
    var TypePeripherique: typeof TYPE_PERIPHERIQUE;
    /**
    * Interface de définition des paramètres communs des périphériques
    * @interface Mobilite.IPeripherique
    */
    interface IPeripherique {
        typePeripherique: TYPE_PERIPHERIQUE;
    }
    /**
     * Déclaration pour les caisses automatiques
     */
    interface ICaisseAuto extends IPeripherique {
    }
    class CaisseAuto implements ICaisseAuto {
        typePeripherique: TYPE_PERIPHERIQUE;
        type: string;
        constructor();
    }
    /**
    * Interface de définition des paramètres d'un périphérique "tablette de signature"<br />
    * Par défault, son typePeripherique est initialisé à 'Mobilite.TypePeripherique.TABLETTE_SIGNATURE' (ENUM Mobilite.TypePeripherique)
    * @interface Mobilite.ITabletteSignature
    */
    interface ITabletteSignature extends IPeripherique {
        type?: string;
        modele?: string;
        codeModele?: string;
    }
    /**
    *
    */
    class TabletteSignature implements ITabletteSignature {
        typePeripherique: TYPE_PERIPHERIQUE;
        type: string;
        modele: string;
        codeModele: string;
        constructor(_type: string, _modele: string, _codeModele: string);
    }
}


declare module MyWay.Services.Message {
    class MessageBase extends Component.ComponentBase {
        private _instance;
        private _targetWindow;
        private _targetDomain;
        private _authorizedDomains;
        private _currentIndex;
        private _callbackArray;
        private _recipient;
        private _sender;
        private _recipientZone;
        constructor(targetWindow: Window, targetDomain: string, authorizedDomains: string[], recipient: string, sender: string, recipientZone: string, zoneName: string, library: Component.IComponentLibrary);
        Dispose(): void;
        CreateMessage(recipient: string, subject: string, content: any, callbackIndex: number, errorCallbackIndex: number): IFrameMessage;
        SendMessage(recipient: string, subject: string, content: any, callback?: (any) => void, errorCallback?: (error: Erreur) => void, targetWindow?: Window, targetDomain?: string): void;
        private _AddCallback(callback);
        private _ReceiveMessage;
        private static _getBaseDomain(domain);
        HandleReception(event: MessageEvent): void;
        HandleResponse(event: MessageEvent): void;
        static IsDomainAuthorized(eventOrigin: string, authorizedDomains: string[]): boolean;
        private _ExecuteCallback(callbackIndex, callbackParam);
        private _RemoveCallback(callbackIndex);
        private _SendResponse;
        private ValidateMessage(message);
    }
    interface IFrameMessage {
        RecipientZone: string;
        RecipientComponent: string;
        SenderZone: string;
        SenderComponent: string;
        Subject: string;
        Content: any;
        Response: any;
        CallbackIndex: number;
        ErreurCallbackIndex: number;
        Error: Erreur;
    }
    class ResponseMessage implements IFrameMessage {
        RecipientZone: string;
        RecipientComponent: string;
        SenderZone: string;
        SenderComponent: string;
        Subject: string;
        Content: any;
        Response: any;
        CallbackIndex: number;
        ErreurCallbackIndex: number;
        Error: Erreur;
        constructor();
    }
}


declare module MyWay.Services.Message {
    interface IMessageService {
        SendMessage(recipient: string, subject: string, content: any, callback?: (any) => void, errorCallback?: (error) => void, targetWindow?: Window, targetDomain?: string): any;
        Dispose(): any;
    }
}


declare module MyWay.Services.Message {
    interface ResponseCallback {
        (event: MessageEvent, callbackContent: any, error: Erreur): void;
    }
}


/**
* Module de gestion de la numérisation (module commun aux agents et aux managers)
* @module MyWay.Services.Numerisation
* interface : NumerisationParams - public - Interface permettant de définir les paramètres de numérisation d'un document
*/
declare module MyWay.Services.Numerisation {
    /**
    * Interface permettant de définir les données nécessaires à la numérisation d'un document
    * @interface Numerisation.NumerisationData
    */
    interface NumerisationData {
        CCLI_TYP: any;
        CCLI_UTL: any;
        NATURE: any;
        data: string;
    }
    /**
    * Interface permettant de définir les données nécessaires à la numérisation d'un document avec SpiFactory Arcade
    * @interface Numerisation.NumerisationDataArcade
    */
    interface NumerisationDataArcade {
        D93F: any;
        D93G: any;
        D93J: any;
        D93K: any;
        D93M: any;
        D93T: any;
        D93V: any;
        D93Y: any;
        data: string;
    }
    /**
    * Interface permettant de définir les paramètres nécessaires à la numérisation d'un document
    * @interface Numerisation.NumerisationParams
    */
    interface NumerisationParams {
        dropZonePath: string;
        configurationFilePath: string;
    }
}


declare module MyWay.Services.Trace {
    enum NIVEAUX_TRACE {
        DEBUG = 30,
        INFO = 50,
        WARNING = 70,
        ERROR = 90,
    }
    interface ILogger {
        debug(message: string, action?: string, object?: any): void;
        info(message: string, action?: string, object?: any): void;
        warning(message: string, action?: string, object?: any): void;
        error(message: string, action?: string, object?: any): void;
    }
    class Utils {
        static gererErreur(object: any): any;
    }
}


declare module MyWay.Services.Trace {
    class Logger implements ILogger {
        private _componentName;
        private _zoneName;
        private _library;
        constructor(componentName: string, zoneName: string, library: Component.IComponentLibrary);
        debug(message: string, action?: string, detail?: any): void;
        info(message: string, action?: string, detail?: any): void;
        warning(message: string, action?: string, detail?: any): void;
        error(message: string, action?: string, detail?: any): void;
        private send(niveauTrace, message, action?, detail?);
        private createTrace(niveau, message, url, application, composant?, action?, detail?);
    }
    class TraceModel {
        datetime: number;
        niveau: NIVEAUX_TRACE;
        client: string;
        serveur: string;
        url: string;
        idProcessus: string;
        cheminInstances: string;
        application: string;
        composant: string;
        action: string;
        COCEAG: string;
        COCXBQ: string;
        CTCEAG: string;
        NOCEEL: string;
        message: string;
        details: any;
    }
}


declare module MyWay.Services.Trace {
    interface ITraceService {
        send(trace: Trace.TraceModel): void;
    }
}


declare module MyWay.Services.TraceSuivi {
    class TraceSuiviModel {
        dateUse: number;
        timezone: string;
        deviceType: string;
        deviceId: string;
        computerSi: string;
        establishment: string;
        agentEdsType: string;
        agentEdsCode: string;
        agentEdsInternalRef: string;
        agentCode: string;
        computerEdsInternalId: string;
        processIdMaster: string;
        processIdCurrent: string;
        stepIdCurrent: string;
        processIdBusiness: string;
        action: string;
        state: string;
        resultStep: string;
        data: any;
    }
}


declare module MyWay.Services {
    class RouteurAgent {
        constructor();
        StepInfo: Context.StepInfo;
        Next(valeurSortie: any): void;
        AddToContext(key: string, value: string): void;
        GetFromContext(key: string): string;
    }
}


declare module MyWay.Services.Component {
    interface IComponentAgent extends IComponent {
        Library: AgentLibrary;
    }
}


declare module MyWay.Services.Component {
    class ComponentAgentBase extends ComponentBase implements IComponentAgent {
        Library: AgentLibrary;
        constructor(library: AgentLibrary, name: string, errorCallback: ErreurCallback);
        SendMessage(subject: string, content: any, callback: (any) => void, errorCallback?: ErreurCallback): void;
    }
}


declare module MyWay.Services {
    class AgentLibrary extends Component.ComponentLibraryBase {
        Message: Message.IMessageService;
        Dates: Dates.DatesCommon;
        Core: CoreCommon;
        Trace: Trace.ITraceService;
        Lisa: Lisa.LisaAgent;
        Context: Context.IContextAgent;
        Controle: Controle.ControleAgent;
        DonneesDelocalisees: DonneesDelocalisees.DonneesDelocaliseesAgent;
        Impression: Impression.ImpressionAgent;
        Numerisation: Numerisation.NumerisationAgent;
        Donnees: Donnees.DonneesCommon;
        Fichier: Fichier.FichierAgent;
        Libelle: Libelle.LibelleAgent;
        Configuration: Configuration.ConfigurationAgent;
        Habilitation: Habilitation.HabilitationAgent;
        Preferences: Preferences.PreferencesAgent;
        Aide: Aide.AideAgent;
        TraceSuivi: TraceSuivi.TraceSuiviAgent;
        JAB: JAB.JABAgent;
        Application: Application.ApplicationAgent;
        Mobilite: Mobilite.MobiliteAgent;
        Display: Display.DisplayAgent;
        TraitementNsdk: TraitementNsdk.TraitementNsdkAgent;
        ServiceAgent: ServiceAgent;
        private static _instance;
        constructor();
        static Instance(): AgentLibrary;
        Add(component: Component.IComponent): void;
    }
}


declare module MyWay.Services {
    interface IServiceAgentInitialisation {
        codeApplication: string;
        onGlobalError?: ErreurCallback;
        onNotification?: (notification: NotificationMessage) => void;
        disableGetStepInfo?: boolean;
        /**
         * Attribut permettant la désactivation de la sauvegarde du scope
         *
         * Si disableScopeSave est à true ou n'est pas renseigné, la sauvegarde du scope ne s'effectue pas
         *
         * Si disableScopeSave est à false, la sauvegarde du scope s'effectue
         *
         * @type {boolean}
         */
        disableScopeSave?: boolean;
        donneesScopeASauvegarder?: string[];
        scopeType?: Context.ScopeType;
    }
    class ServiceAgent {
        $$framework: string;
        protected _serviceLibrary: AgentLibrary;
        private _stepInfo;
        IsInitDone: boolean;
        IsInitInProgress: boolean;
        private _serializedInitialisationValues;
        Core: CoreCommon;
        Lisa: Lisa.ILisaAgent;
        Context: Context.IContextAgent;
        Controle: Controle.ControleAgent;
        Dates: Dates.DatesCommon;
        DonneesDelocalisees: DonneesDelocalisees.IDonneesDelocaliseesAgent;
        Libelle: Libelle.LibelleAgent;
        Impression: Impression.ImpressionAgent;
        Numerisation: Numerisation.NumerisationAgent;
        Configuration: Configuration.ConfigurationAgent;
        Habilitation: Habilitation.HabilitationAgent;
        Preferences: Preferences.PreferencesAgent;
        TraceSuivi: TraceSuivi.TraceSuiviAgent;
        Donnees: Donnees.DonneesCommon;
        Fichier: Fichier.FichierAgent;
        Aide: Aide.AideAgent;
        JAB: JAB.JABAgent;
        Application: Application.ApplicationAgent;
        Mobilite: Mobilite.MobiliteAgent;
        Display: Display.DisplayAgent;
        TraitementNsdk: TraitementNsdk.TraitementNsdkAgent;
        private _logger;
        private _usableLogger;
        Trace: Trace.Logger;
        Library: AgentLibrary;
        Step: Context.StepInfo;
        constructor();
        init(serviceInit?: IServiceAgentInitialisation): IPromesse<any>;
        private _initAgents(codeApplication, onNotification?, onInitialisationTerminee?, onErreur?, disableGetStepInfo?, sauvegardeScopeParam?);
        private _initTerminee;
        private _displayError;
        DisplayMessage(message: IMessage): void;
        /**
         * Envoie une requête XHR en surchargeant par des headers MyWay
         */
        SendRequest(settings: IRequestSettings): IPromesse<any>;
        SubscribeToNotification(onNotification: (notification: NotificationMessage) => void): void;
        Dispose(): void;
    }
}


declare module MyWay.Services {
    class AppServiceParameters {
        private static _instance;
        constructor();
        static Instance(): AppServiceParameters;
        PortalDomain: string;
        MessageAgent: Message.IMessageAgent;
    }
}


declare module MyWay.Services {
    var moduleAgent: ng.IModule;
}


declare module MyWay.Services {
    class InstanceLoaderService {
        private $parse;
        static $inject: string[];
        constructor($parse: ng.IParseService);
        createInstance<T>(name: string, ...args: any[]): T;
    }
    class ServiceAgentProvider {
        private $q;
        private instanceLoaderService;
        private $timeout;
        private $rootScope;
        static $inject: string[];
        private static _serviceAgentExtended;
        constructor($q: ng.IQService, instanceLoaderService: MyWay.Services.InstanceLoaderService, $timeout: any, $rootScope: any);
        static Instance($q: ng.IQService, instanceLoaderService: MyWay.Services.InstanceLoaderService, $timeout: any, $rootScope: any): ServiceAgentExtended;
        /**
         * Initialisation du serviceAgent.
         *
         * Le provider angular fournit un objet de type [[ServiceAgentExtended]].
         *
         * Le serviceAgent, injecté dans la SPA angular, doit être initialisé pour chaque route de la SPA.
         *
         * ~~~ts
         * $routeProvider
         * .when("/", {
         *       controller: "Controleur"
         *       , templateUrl: "views/defaut.html"
         *       , controllerAs: "ctrlr"
         *       , resolve: {
         *           serviceAgent: ["serviceAgentProvider",
         *               function (serviceAgentProvider: MyWay.Services.ServiceAgentProvider) {
         *                   return serviceAgentProvider.init({ codeApplication: "CREDIT" });
         *               }]
         *        }
         * });
         * ~~~
         * @param  {IServiceAgentInitialisation}       serviceInit
         *
         * @return {ng.IPromise<ServiceAgentExtended>}
         *
         */
        init(serviceInit?: IServiceAgentInitialisation): ng.IPromise<ServiceAgentExtended>;
    }
    /**
     * @ngdoc service
     * @name moduleAgent.service:serviceAgentExtended
     * @requires $q
     * @requires moduleAgent.instanceLoaderService
     * @description
     * Ce service est une extension du serviceAgent (framework technique). Il permet d'en simplifier l'utilisation.
     */
    class ServiceAgentExtended extends ServiceAgent {
        private $q;
        private instanceLoaderService;
        private $timeout;
        private $rootScope;
        private _digestCycleCount;
        private _lastDigestTime;
        private _clearWatchListener;
        private _lastDigestTimerHandle;
        static $inject: string[];
        constructor($q: ng.IQService, instanceLoaderService: MyWay.Services.InstanceLoaderService, $timeout: any, $rootScope: any);
        /**
         * @ngdoc method
         * @name init
         * @methodOf moduleAgent.serviceAgentExtended
         * @description
         * Permet l'initialisation du ServiceAgent.
         * @param {Object} serviceInit Objet contenant le code LISA de la SPA
         *      et une fonction de rappel en cas de notification du portail vers l'application
         * @returns {Object} Result promise.
         */
        init(serviceInit: MyWay.Services.IServiceAgentInitialisation): ng.IPromise<ServiceAgentExtended>;
        private prepareTracesTechniques();
        ajouteEvenementsUtilisateurs: () => void;
        retireEvenementsUtilisateurs: () => void;
        OnPremiereAction: (ev: any) => void;
        /**
         * @ngdoc method
         * @name addToSharedContext
         * @methodOf moduleAgent.serviceAgentExtended
         * @description
         * Ajoute un objet dans le contexte global. L'opération est asynchrone et renvoie donc une promise.
         * @param {string} key clé de la donnée
         * @param {Object} value valeur de la donnée
         * @returns {Object} Result promise.
         */
        addToSharedContext(key: string, value: any): ng.IPromise<void>;
        /**
         * @ngdoc method
         * @name removeFromSharedContext
         * @methodOf moduleAgent.serviceAgentExtended
         * @description
         * Supprime un objet dans le contexte global. L'opération est asynchrone et renvoie donc une promise.
         * @param {string} key clé de la donnée
         * @returns {Object} Result promise.
         */
        removeFromSharedContext(key: string): ng.IPromise<void>;
        /**
         * @ngdoc method
         * @name addToContext
         * @methodOf moduleAgent.serviceAgentExtended
         * @description
         * Ajoute un objet dans le contexte (local storage). L'opération est asynchrone et renvoie donc une promise.
         * @param {string} key clé de la donnée
         * @param {Object} value valeur de la donnée
         * @returns {Object} Result promise.
         */
        addToContext(key: string, value: any): ng.IPromise<void>;
        /**
         * @ngdoc method
         * @name addListToContext
         * @methodOf moduleAgent.serviceAgentExtended
         * @description
         * Ajoute une liste d'objets dans le contexte (local storage). L'opération est asynchrone et renvoie donc une promise.
         * @param {Object} data Chaque propriété de l'objet correspond à un objet à mettre dans le contexte.
         * @returns {Object} Result promise.
         */
        addListToContext(data: Object): ng.IPromise<void>;
        /**
         * @ngdoc method
         * @name getFromContext
         * @methodOf moduleAgent.serviceAgentExtended
         * @description
         * Renvoie un objet du contexte (local storage). L'opération est asynchrone et renvoie donc une promise.
         * @param {string} key clé de la donnée
         * @param {string=} resultType Type explicite de l'objet à renvoyer.
         * Ce paramètre permet d'instancier un objet de type classe. Le constructeur est appelé avec la valeur en entrée.
         * @returns {Object} Promise contenant la valeur associée à la clé.
         */
        getFromContext<T>(key: string, resultType?: string): ng.IPromise<T>;
        /**
         * @ngdoc method
         * @name getListFromContext
         * @methodOf moduleAgent.serviceAgentExtended
         * @description
         * Permet de récupérer une liste de donnée depuis le contexte. L'opération est asynchrone et renvoie donc une promise.
         * @param {array} keyArray Liste de clé à récupérer
         * @returns {Object} Promise contenant un tableau d'objets de type MyWay.Services.Context.IContextKeyValuePair.
         */
        getListFromContext(keyArray: string[]): ng.IPromise<MyWay.Services.Context.IContextKeyValuePair[]>;
        /**
         * @ngdoc method
         * @name getAuthentificationInfo
         * @methodOf moduleAgent.serviceAgentExtended
         * @description
         * Récupère les données d'authentification. L'opération est asynchrone et renvoie donc une promise.
         * @returns {Object} Promise contenant un objet de type AuthentificationInfo.
         */
        getAuthentificationInfo(): ng.IPromise<Context.AuthentificationInfo>;
        /**
         * @ngdoc method
         * @name getParametresComptables
         * @methodOf moduleAgent.serviceAgentExtended
         * @description
         * Permet de récupérer un objet de données (rubrique ou table délocalisée) pour l'établissement de l'utilisateur connecté.
         * L'opération est asynchrone et renvoie donc une promise.
         * @param {void}
         * @returns {Object} Promise contenant l'objet de données wrappé (dans la propriété donnees).
         */
        getParametresComptables(): ng.IPromise<Context.ParametresComptables>;
        /**
         * @ngdoc method
         * @name getDonneesDelocalisees
         * @methodOf moduleAgent.serviceAgentExtended
         * @description
         * Permet de récupérer un objet de données (rubrique ou table délocalisée) pour l'établissement de l'utilisateur connecté.
         *  L'opération est asynchrone et renvoie donc une promise.
         * @param {string} numEtablissement Numéro d'établissement.
         * @param {string} objectDataName Nom de l'objet de données à récupérer.
         * @returns {Object} Promise contenant l'objet de données wrappé (dans la propriété donnees).
         */
        getDonneesDelocalisees(numEtablissement: string, objectDataName: string): ng.IPromise<any>;
        /**
         * @ngdoc method
         * @name getListDonneesDelocalisees
         * @methodOf moduleAgent.serviceAgentExtended
         * @description
         * Permet de récupérer une liste de données (rubrique ou table délocalisée) pour l'établissement de l'utilisateur connecté.
         * Les objets instanciés sont fortement typés à partir du type fourni. L'opération est asynchrone et renvoie donc une promise.
         * @param {string} objectDataName Nom de l'objet de données à récupérer.
         * @param {string=} resultType Type explicite de l'objet à renvoyer. Ce paramètre permet d'instancier un objet de type classe.
         *  Le constructeur est appelé avec l'objet de données en entrée.
         * @returns {Object} Promise contenant l'objet de données wrappé (dans la propriété donnees).
         */
        getListDonneesDelocalisees<T>(objectDataName: string, resultType?: string): ng.IPromise<T[]>;
        /**
         * @ngdoc method
         * @name sendRequest
         * @methodOf moduleAgent.serviceAgentExtended
         * @description
         * Envoi une requête pour consommer une ressource.
         * L'objet retourné peut être instancié par un type si fourni. L'opération est asynchrone et renvoie donc une promise.
         * @param {Object} settings interface de définition des paramètres d'envoi d'une requête REST.
         * @param {string=} resultType Type explicite de l'objet à renvoyer. Ce paramètre permet d'instancier un objet de type classe.
         * @returns {Object} Promise contenant la réponse de la requête.
         */
        sendRequest<T>(settings: IRequestSettings, resultType?: string): ng.IPromise<T>;
        LogDemarrage(): void;
    }
}


declare module MyWay.Services.Context {
    interface IContextAgent {
        AddToContext(key: string, value: string): IPromesse<any>;
        AddToMainProcessContext(key: string, value: string): IPromesse<any>;
        AddListToContext(kvp: MyWay.Services.Context.IContextKeyValuePair[]): IPromesse<any>;
        GetFromContext(key: string): IPromesse<string>;
        GetObjectFromContext<T>(keyArray: string[]): IPromesse<any>;
        GetTypedObjectFromContext<T>(template: T): IPromesse<T>;
        GetListFromContext(keyArray: string[]): IPromesse<MyWay.Services.Context.IContextKeyValuePair[]>;
        GetAuthentificationInfo(): IPromesse<AuthentificationInfo>;
        GetParametresComptables(): IPromesse<ParametresComptables>;
        Redirect(url?: string, previousUrl?: string): IPromesse<any>;
        GetWaitingProcesses(): IPromesse<MyWay.Services.Context.IProcess[]>;
        PutProcessInPortalContext(processId: string): IPromesse<any>;
        PutTaskInPortalContext(taskId: string): IPromesse<any>;
        GetCurrentProcessId(): IPromesse<string>;
        GetCurrentStepId(): IPromesse<string>;
        GetCurrentStepInfo(): IPromesse<Context.StepInfoExtended>;
        SetMyWayCompatible(): IPromesse<boolean>;
        SubscribeToNotification(onNotification: (notification: NotificationMessage) => void, serviceAgent: ServiceAgent): IPromesse<any>;
        AnalyseApp(): AnalyseResult;
        ChangeMainProcessName(name: string): IPromesse<any>;
        AddToSharedContext(key: string, value: string): IPromesse<any>;
        RemoveFromSharedContext(key: string): IPromesse<any>;
        StepInfo: StepInfoExtended;
        ErreurCallback: ErreurCallback;
    }
}


declare module MyWay.Services.Context {
    enum ScopeType {
        View = 1,
        Root = 2,
        Service = 3,
    }
    interface ISauvegardeScopeParam {
        donneesScopeASauvegarder?: string[];
        disableScopeSave?: boolean;
        scopeType?: ScopeType;
    }
    class ScopeData {
        id: number;
        data: any;
        children: ScopeData[];
    }
    class ServiceData {
        name: string;
        data: any;
        constructor(name: string, data: any);
    }
    class ContextAgent extends Component.ComponentAgentBase implements IContextAgent {
        sauvegardeScopeParam: ISauvegardeScopeParam;
        protected _onNotification: (notification: NotificationMessage, agent: ServiceAgent) => void;
        private _serviceAgent;
        StepInfo: StepInfoExtended;
        constructor(agentLibrary: AgentLibrary, sauvegardeScopeParam: ISauvegardeScopeParam, errorCallback: ErreurCallback);
        AddToContext(key: string, value: string): IPromesse<any>;
        AddToSharedContext(key: string, value: string): IPromesse<any>;
        RemoveFromSharedContext(key: string): IPromesse<any>;
        AddToMainProcessContext(key: string, value: string): IPromesse<any>;
        AddListToContext(kvp: MyWay.Services.Context.IContextKeyValuePair[]): IPromesse<any>;
        GetFromContext(key: string): IPromesse<string>;
        GetObjectFromContext(keyArray: string[]): IPromesse<any>;
        GetTypedObjectFromContext<T>(template: T): IPromesse<T>;
        GetListFromContext(keyArray: string[]): IPromesse<MyWay.Services.Context.IContextKeyValuePair[]>;
        GetAuthentificationInfo(): IPromesse<AuthentificationInfo>;
        GetParametresComptables(): IPromesse<ParametresComptables>;
        Redirect(url?: string, previousUrl?: string): IPromesse<any>;
        GetWaitingProcesses(): IPromesse<MyWay.Services.Context.IProcess[]>;
        PutProcessInPortalContext(processId: string): IPromesse<any>;
        PutTaskInPortalContext(taskId: string): IPromesse<any>;
        GetCurrentProcessId(): IPromesse<string>;
        GetCurrentStepId(): IPromesse<string>;
        GetCurrentStepInfo(): IPromesse<Context.StepInfoExtended>;
        SetMyWayCompatible(): IPromesse<boolean>;
        SubscribeToNotification(onNotification: (notification: NotificationMessage, agent: ServiceAgent) => void, serviceAgent: ServiceAgent): IPromesse<any>;
        ChangeMainProcessName(name: string): IPromesse<any>;
        getAllElementsWithAttribute(attribute: any): any[];
        SauvegarderDonneesScope(): any;
        private _addToProcessStepContext(key, value, processStepId);
        private _getAngularScope();
        private _getOverallScopeContent(scope);
        private _getScopeData(currentScope, parentScopeData);
        private _setScope(rootScope, scopeData);
        private _getServiceData(donnesASauvegarder);
        private _setServices(servicesData);
        private _getScopeById(scope, id);
        private _getScopeContent(scope);
        getId(element: any): string;
        getClasses(element: any): string;
        InitialiserDonneesScope(stepInfo: StepInfoExtended): IPromesse<boolean>;
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
        AnalyseApp(): AnalyseResult;
        CountWatcher2(): number;
        CountWatcher3(): number;
    }
}

declare module MyWay.Services.Controle {
    class ControleAgent extends Component.ComponentAgentBase {
        constructor(library: AgentLibrary);
        Any: AnyControle;
        Array: ArrayControle;
        Boolean: BooleanControle;
        Date: DateControle;
        Enum: EnumControle;
        Function: FunctionControle;
        Number: NumberControle;
        Object: ObjectControle;
        String: StringControle;
    }
}


declare module MyWay.Services.DonneesDelocalisees {
    interface IDonneesDelocaliseesAgent {
        getDonneesDelocalisees(numEtablissement: string, objectDataName: string): IPromesse<any>;
        getListeDonneesDelocalisees(numEtablissement: string, objectDataNames: string[]): IPromesse<any[]>;
        getRubriqueLibelle(numEtablissement: string, objectDataName: string, code: string): IPromesse<string>;
        getDonneesParCriteres(numEtablissement: string, objectDataName: string, criteres: Array<ObjectDataCritere>): IPromesse<any>;
    }
}


/**
* Module de gestion des données délocalisées
* @module MyWay.Services.DonneesDelocalisees
* classe : DonneesDelocaliseesAgent - public - Classe permettant la gestion des données délocalisées
*/
declare module MyWay.Services.DonneesDelocalisees {
    /**
    * Classe permettant la gestion des données délocalisées
    * @classe DonneesDelocaliseesAgent
    * fonction : getDonneesDelocalisees – public - Permet de récupérer des données délocalisées
    * fonction : getRubriqueLibelle - public - Permet de récupérer le libellé du code d'une rubrique
    */
    class DonneesDelocaliseesAgent extends Component.ComponentAgentBase implements IDonneesDelocaliseesAgent {
        private _errorCallback;
        /**
        * Constructeur de la classe DonneesDelocaliseesAgent
        * @param messageAgent {MessageAgent}
        * @param errorCallback {ErreurCallback}
        */
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        /**
        * Permet de récupérer des données délocalisées
        * @param numEtablissement {string} identifiant de la Table des tables (numéro d'établissement). Si null, c'est celui du contexte qui est utilisé.
        * @param objectDataName {string} nom de l'objet de données
        */
        getDonneesDelocalisees(numEtablissement: string, objectDataName: string): IPromesse<any>;
        /**
        * Permet de récupérer une liste de données délocalisées
        * @param numEtablissement {string} Numéro d'établissement. Si null, c'est celui du contexte qui est utilisé.
        * @param objectDataNames {Array<string>} Liste des noms d'objets de données
        */
        getListeDonneesDelocalisees(numEtablissement: string, objectDataNames: string[]): IPromesse<any[]>;
        /**
        * Permet de récupérer le libellé du code d'un objet de données
        * @param numEtablissement {string} identifiant de la Table des tables (numéro d'établissement)
        * @param objectDataName {string} nom de l'objet de données
        * @param code {string} code pour lequel on veut obtenir le libellé
        */
        getRubriqueLibelle(numEtablissement: string, objectDataName: string, code: string): IPromesse<string>;
        /**
        * Permet de récupérer les données d'un objet de données correspondant aux critères choisis
        * @param numEtablissement {string} identifiant de la Table des tables (numéro d'établissement)
        * @param objectDataName {string} nom de l'objet de données
        * @param criteres {Array<ObjectDataCritere>} critères de recherche des données
        */
        getDonneesParCriteres(numEtablissement: string, objectDataName: string, criteres: Array<ObjectDataCritere>): IPromesse<any>;
    }
}


declare module MyWay.Services.Aide {
    interface IAideAgent {
        GetContenuInfobulle(idChamp: string, utilisationHorsProcessus?: boolean, codeProcessusVoulu?: string, codeEtapeVoulu?: string): IPromesse<DetailInfobulleAfficheeResult>;
        GetInfobullesAffichables(utilisationHorsProcessus?: boolean, codeProcessusVoulu?: string, codeEtapeVoulu?: string): IPromesse<InfobulleAfficheeResult[]>;
    }
    /**
    * Classe permettant la gestion de l'aide
    */
    class AideAgent extends Component.ComponentAgentBase implements IAideAgent {
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        GetContenuInfobulle(idChamp: string, utilisationHorsProcessus?: boolean, codeProcessusVoulu?: string, codeEtapeVoulu?: string): IPromesse<DetailInfobulleAfficheeResult>;
        GetInfobullesAffichables(utilisationHorsProcessus?: boolean, codeProcessusVoulu?: string, codeEtapeVoulu?: string): IPromesse<InfobulleAfficheeResult[]>;
    }
}


/**
* Module de gestion des applications
* @module MyWay.Services.Application
*/
declare module MyWay.Services.Application {
    /**
    * Classe permettant la gestion des applications
    */
    class ApplicationAgent extends Component.ComponentAgentBase {
        /**
         * Constructeur de la classe ApplicationAgent
         * @param {AgentLibrary}   agentLibrary  [description]
         * @param {ErreurCallback} errorCallback [description]
         */
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        /**
         * Permet de démarrer une application à partir d'un code application.
         *
         * A ce jour, seules les applications de type 1 (URL) sont implémentées.
         *
         * Les habilitations ne sont pour l'instant pas vérifiées car les habilitations IAM sont indisponibles au niveau du portail.
         *
         * ~~~ts
         * // Démarrage de l'application AC1
         * serviceAgent.Application.Demarrer('AC1').then((result: boolean) => {
         * ...
         * }).catch((erreur: MyWay.Services.Erreur) => {
         * ...
         * });
         * ~~~
         *
         * @param  {string}             codeApplication
         * Correspond au code de l'application
         *
         * @return {IPromesse<boolean>}
         * Promesse indiquant si oui(true) ou non(false) l'application a correctement démarrée sinon retourne une **erreur**
         *
         * #### Listes des erreurs
         * | codeLibelle                               | libelle                                                        |
         * | ----------------------------------------- |:-------------------------------------------------------------- |
         * | ERREUR_APPLICATION_TYPE_INCONNU           | Le type de l'application n'est pas pris en charge              |
         * | ERREUR_APPLICATION_DEMARRAGE_IMPOSSIBLE   | L'application n'a pas pu être démarrée                         |
         * | ERREUR_APPLICATION_CODE_NON_RENSEIGNE     | Le code de l'application n'est pas renseigné                   |
         * | ERREUR_APPLICATION_MAINTENANCE            | L'application est indisponible temporairement pour maintenance |

         */
        Demarrer(codeApplication: string): IPromesse<boolean>;
    }
}


/**
* Module de gestion des configurations
* @module MyWay.Services.Configuration
* classe : ConfigurationAgent - public - Classe permettant la gestion de configuration
*/
declare module MyWay.Services.Configuration {
    /**
    * Classe permettant la gestion de la configuration
    */
    class ConfigurationAgent extends Component.ComponentAgentBase {
        /**
        * Constructeur de la classe ConfigurationAgent
        * @param agentLibrary {AgentLibrary}
        * @param errorCallback {ErreurCallback}
        */
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        LireConfiguration(): IPromesse<any>;
    }
}


declare module MyWay.Services.Display {
    class DisplayAgent extends Component.ComponentAgentBase {
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
        Refresh(): void;
    }
}


declare module MyWay.Services.Fichier {
    /**
    * Classe gestion des fichiers
    * @classe FichierAgent
    * fonction : saveAs – public - Permet de sauvegarder un fichier sur le filesystem
    */
    class FichierAgent extends Component.ComponentAgentBase implements Component.IComponentAgent {
        Library: AgentLibrary;
        private _errorCallback;
        constructor(library: AgentLibrary, errorCallback: ErreurCallback);
        /**
        * Permet de télécharger un fichier
        * @param data {any} données du fichier
        * @param type {TYPE_FICHIER} type du fichier à télécharger
        * @param nomFichier {string} nom attribué au fichier téléchargé
        * @param typeDonnees {TYPE_DONNEES_A_SAUVER} type de données à enregistrer (Optionnel: par défaut TYPE_DONNEES_A_SAUVER.BLOB)
        */
        saveAs(data: any, type: TYPE_FICHIER, nomFichier: string, typeDonnees?: TYPE_DONNEES_A_SAUVER): IPromesse<any>;
    }
}


/**
* Module de gestion des habilitations
* @module MyWay.Services.Habilitation
* classe : HabilitationAgent - public - Classe permettant la gestion des habilitations
*/
declare module MyWay.Services.Habilitation {
    /**
    * Classe permettant la gestion des habilitations
    */
    class HabilitationAgent extends Component.ComponentAgentBase {
        /**
         * Constructeur de la classe HabilitationAgent
         * @param {AgentLibrary}   agentLibrary  [description]
         * @param {ErreurCallback} errorCallback [description]
         */
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        /**
         * Permet de récupérer une habilitation pour un utilisateur.
         *
         * Cette méthode ne prend qu'un seul code habilitation en paramètre.
         *
         * ~~~ts
         *
         * // Récupération de l'habilitation 'SHOP24' pour l'utilisateur authentifié
         * serviceAget.Habilitation.EstHabilite('SHOP24').then((result: boolean) => {
         * ...
         * }).catch((rreur: MyWay.Services.Erreur) => {
         * ...
         * });
         * ~~~
         *
         * @param  {string}             codeHabilitation
         *
         * Code de la fonction, du processus,... exemple : SHOP24
         *
         * @return {IPromesse<boolean>}
         *
         * Promesse indiquant si oui(true) ou non(false) l'utilisateur est habilité au code habilitation passé en paramètre
         *
         */
        EstHabilite(codeHabilitation: string): IPromesse<boolean>;
        /**
         * Permet de récupérer plusieurs habilitations pour un utilisateur (Méthode à privilégier pour la récupération de plusieurs codes dans un même traitement)
         *
         * ~~~ts
         *
         * // Récupération des habilitations 'SHOP24', 'SHOMW1', 'SHOMW2' pour l'utilisateur authentifié
         * serviceAgent.Habilitation.EstHabilite(['SHOP24','SHOMW1','SHOMW2']).then((result: boolean []) => {
         * ...
         * }).catch((erreur: MyWay.Services.Erreur) => {
         * ...
         * });
         * ~~~
         *
         * @param  {string[]}             codesHabilitation
         *
         * Codes des fonctions, des processus,... exemple : [‘SHOP24’,’SHOMW1’]
         *
         * @return {IPromesse<boolean[]>}
         *
         * Promesse indiquant si oui(true) ou non(false) l'utilisateur est habilité à chaque code habilitation passé en paramètre
         *
         */
        EstHabilite(codesHabilitation: string[]): IPromesse<boolean[]>;
    }
}


/**
* Module de gestion des jab
* @module MyWay.Services.JAB
* classe : JABAgent - public - Classe permettant la gestion des Journaux d'Archivage Bancaires
*/
declare module MyWay.Services.JAB {
    /**
    * Classe permettant la gestion des Journaux d'Archivage Bancaires
    */
    class JABAgent extends Component.ComponentAgentBase {
        /**
         * Constructeur de la classe JABAgent
         * @param {AgentLibrary}   agentLibrary  [description]
         * @param {ErreurCallback} errorCallback [description]
         */
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        Enregistrer(data: string): IPromesse<any>;
    }
}


/**
* Module de gestion des traitement Nsdk
* @module MyWay.Services.TraitementNsdk
* classe : TraitementNsdkAgent - public - Classe permettant Le lancement de traitment NSDK depuis MyWay
*/
declare module MyWay.Services.TraitementNsdk {
    /**
    * Classe permettant la gestion des traitements NSDK depuis MyWay
    */
    class TraitementNsdkAgent extends Component.ComponentAgentBase {
        /**
         * Constructeur de la classe TraitementNsdkAgent
         * @param {AgentLibrary}   agentLibrary  [description]
         * @param {ErreurCallback} errorCallback [description]
         */
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        Lancer(traitement: string, data: string): IPromesse<any>;
    }
}


/**
* Module de gestion des impressions
* @module MyWay.Services.Impression
* classe : ImpressionAgent - public - Classe permettant la gestion impressions
*/
declare module MyWay.Services.Impression {
    /**
    * Classe permettant la gestion des impressions
    * @classe ImpressionAgent
    * @fonction generer – public - Permet de lancer la génération d'un document d'impression
    * @fonction imprimer – public - Permet de lancer une impression
    * @fonction genererImprimer – public - Permet de lancer la génération et l'impression d'un document
    */
    class ImpressionAgent extends Component.ComponentAgentBase {
        /**
        * Constructeur de la classe ImpressionAgent
        * @param agentLibrary {AgentLibrary} La librairie d'impression de l'agent
        * @param errorCallback {ErreurCallback} Action à executer en cas d'erreur lors de la génération
        */
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        /**
        * Permet de lancer la génération d'un document d'impression
        * @param data {any} Données à envoyer pour la génération du document d'impression
        * @param generationParams {GenerationParams} Paramètres de génération du document d'impression
        * @param callback {function} Action à executer une fois la génération effectuée
        * @param callbackError {function} Action à executer en cas d'erreur lors de la génération
        * @return IPromesse<any> Renvoie une promesse MyWay
        */
        generer(data: any, generationParams: MyWay.Services.Impression.GenerationParams): IPromesse<any>;
        /**
        * Permet de lancer une impression
        * @param data {any} Données à envoyer pour l'impression
        * @param impressionParams {ImpressionParams} Paramètres d'impression du document
        * @param callback {function} Action à executer une fois l'impression effectuée
        * @param callbackError {function} Action à executer en cas d'erreur lors de l'impression
        * @return IPromesse<any> Renvoie une promesse MyWay
        */
        imprimer(data: any, impressionParams: MyWay.Services.Impression.ImpressionParams): IPromesse<any>;
        /**
        * Permet de lancer la génération et l'impression d'un document
        * @param data {any} Données à envoyer pour la génération et l'impression d'un document
        * @param generationImpressionParams {GenerationImpressionParams} Paramètres de génération et d'impression d'un document
        * @param callback {function} Action à executer une fois la génération et l'impression effectuées
        * @param callbackError {function} Action à executer en cas d'erreur lors de la génération ou de l'impression
        * @return IPromesse<any> Renvoie une promesse MyWay
        */
        genererImprimer(data: any, generationImpressionParams: MyWay.Services.Impression.GenerationImpressionParams): IPromesse<any>;
        /**
         * Permet de lancer l'impression du navigateur<br />
         * Simple wrapper de window.print pour l'instant, permettra dans le futur d'ajouter des traces si nécessaires
         */
        imprimerEcran(): void;
    }
}


declare module MyWay.Services.Libelle {
    class LibelleAgent extends Component.ComponentAgentBase {
        private _errorCallback;
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        afficherMessage(codeLibelle: any, typeAffichage: TYPE_AFFICHAGE, valeurs?: string[], delai?: number): IPromesse<any>;
        constituerLibelle(codeLibelle: string, valeurs?: string[]): IPromesse<any>;
    }
}


declare module MyWay.Services.Lisa {
    interface ILisaAgent {
        Next(valeurSortie: number): IPromesse<LisaCallbackResult>;
        NextWithStep(stepCode: string, valeurSortie: number): IPromesse<any>;
    }
}


declare module MyWay.Services.Lisa {
    class LisaAgent extends Component.ComponentAgentBase implements Component.IComponentAgent, ILisaAgent {
        StepCode: string;
        private _errorCallback;
        constructor(agentLibrary: AgentLibrary, stepCode: string, errorCallback: ErreurCallback);
        Next(valeurSortie: number): IPromesse<LisaCallbackResult>;
        NextWithStep(stepCode: string, valeurSortie: number): IPromesse<LisaCallbackResult>;
    }
}


declare module MyWay.Services.Message {
    interface IMessageAgent extends IMessageService {
        Dispose(): any;
        ReplaceLibrary(library: AgentLibrary): any;
    }
    class MessageAgentBase extends MessageBase implements IMessageAgent {
        private static _instance;
        constructor(library: Component.IComponentLibrary, otherWindow: Window, uri: string);
        Dispose(): void;
        ReplaceLibrary(library: MyWay.Services.AgentLibrary): void;
        TreatError(): void;
    }
    class MessageAgent extends MessageAgentBase {
        constructor(library: Component.IComponentLibrary);
    }
    class MessageAgentFactory {
        static CreateMessageAgent(library: Component.IComponentLibrary, onTermine: () => void): void;
    }
    class SelfMessageManager extends MessageAgentBase {
        constructor(library: Component.IComponentLibrary);
        SendMessage(recipient: string, subject: string, content: any, callback?: (any) => void, errorCallback?: (error) => void, targetWindow?: Window, targetDomain?: string): void;
    }
}


/**
* Module de gestion de la mobilité
* @module MyWay.Services.Mobilite
* @author Laurie Marchaterre
*/
declare module MyWay.Services.Mobilite {
    /**
    * Classe permettant d'accéder aux données de mobilité
    */
    class MobiliteAgent extends Component.ComponentAgentBase {
        /**
         * Constructeur de la classe MobiliteAgent
         * @param {AgentLibrary}   agentLibrary  [description]
         * @param {ErreurCallback} errorCallback [description]
         */
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        /**
         * Permet de savoir à quel type de réseau on est connecté.
         * @return {IPromesse<TYPE_RESEAU>}
         *      - CONNECTE : Connecté (réseau inconnu)
         *      - OFFLINE: Déconnecté
         *
         * ~~~ts
         * serviceAgent.mobilite.getReseau().then((result: TYPE_RESEAU) => {
         * // Renvoi le type de connexion
         * ...
         * * }).catch((erreur: MyWay.Services.Erreur) => {
         * // Renvoi une erreur
         * ...
         * });
         * ~~~
         */
        getReseau(): IPromesse<TYPE_RESEAU>;
        /**
         * **DEPRECIEE:** Méthode qui récupère la liste des périphériques connectés.
         * Il faut utiliser la méthode getPeripheriques();
        **/
        GetPeripheriques(...params: any[]): any;
        /**
         * Méthode qui récupère la liste des périphériques connectés.
         * Les périphériques retournées sont :
         *     - Les caisses auto
         *     - Les tablettes de signature Wacom
         * @return {IPromesse<IPeripherique[]>} liste de IPeripherique
         * ~~~ts
         * serviceAgent.mobilite.GetPeripheriques().then((result: IPeripherique[]) => {
         *  // Renvoi un tableau de Peripherique
         * }).catch((erreur: MyWay.Services.Erreur) => {
         *  // Renvoi une erreur
         * });
         * ~~~
         */
        getPeripheriques(): IPromesse<IPeripherique[]>;
        /**
         * Méthode qui récupère la liste des caisses auto connectées.
         * @return {IPromesse<ICaisseAuto[]>} liste de caisses auto
         * ~~~ts
         * serviceAgent.mobilite.getCaissesAuto().then((result: ICaissesAuto[]) => {
         *  // Renvoi un tableau de Caisse Auto
         * }).catch((erreur: MyWay.Services.Erreur) => {
         *  // Renvoi une erreur
         * });
         * ~~~
         */
        getCaissesAuto(): IPromesse<ICaisseAuto[]>;
        /**
         * Méthode qui récupère la liste des tablettes de signature connectées.
         * @return {IPromesse<ITabletteSignature[]>} liste de tablettes de signature Wacom
         * ~~~ts
         * serviceAgent.mobilite.getTablettesSignature().then((result: ITabletteSignature[]) => {
         *  // Renvoi un tableau de tablettes de signature Wacom
         * }).catch((erreur: MyWay.Services.Erreur) => {
         *  // Renvoi une erreur
         * });
         * ~~~
         */
        getTablettesSignature(): IPromesse<ITabletteSignature[]>;
    }
}


/**
* Module de gestion de la numérisation
* @module MyWay.Services.Numerisation
* classe : NumerisationAgent - public - Classe permettant la gestion de la numérisation
*/
declare module MyWay.Services.Numerisation {
    /**
    * Classe permettant la gestion de la numérisation
    * @classe NumérisationAgent
    * fonction : numeriser – public - Permet de numériser un document
    * fonction : getSpiFactoryActivationStatut – public - Permet de savoir si le jeton d'activation SpiFactory est présent sur le serveur d'agence
    * fonction : numeriserArcade – public - Permet de numériser un document avec Spifactory Arcade
    */
    class NumerisationAgent extends Component.ComponentAgentBase {
        /**
        * Constructeur de la classe NumerisationAgent
        * @param agentLibrary {AgentLibrary}
        * @param errorCallback {ErreurCallback}
        */
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        /**
        * Permet de lancer une numérisation
        * @param data {any} données à envoyer pour la numérisation
        * @param numerisationParams {NumerisationParams} paramètres de numérisation du document
        * @param callback {function} action à executer une fois la numérisation effectuée
        * @param callbackError {function} action à executer en cas d'erreur de numérisation
        */
        numeriser(data: any, numerisationParams: MyWay.Services.Numerisation.NumerisationParams): IPromesse<any>;
        /**
        * Permet de lancer une numérisation avec Spifactory Arcade
        * @param data {any} données à envoyer pour la numérisation
        * @param numerisationParams {NumerisationParams} paramètres de numérisation du document
        * @param callback {function} action à executer une fois la numérisation effectuée
        * @param callbackError {function} action à executer en cas d'erreur de numérisation
        */
        numeriserArcade(data: any, numerisationParams: any): IPromesse<any>;
        /**
        * Permet de savoir si le jeton d'activation SpiFactory est présent sur le serveur d'agence
        * @param callback {function} action à executer une fois le statut d'activation récupéré
        * @param callbackError {function} action à executer en cas d'erreur
        */
        getSpiFactoryActivationStatut(): IPromesse<any>;
    }
}


/**
* Module de gestion des preferences
* @module MyWay.Services.Preferences
* classe : PreferencesAgent - public - Classe permettant la gestion de preferences
*/
declare module MyWay.Services.Preferences {
    /**
    * Classe permettant la gestion de la configuration
    */
    class PreferencesAgent extends Component.ComponentAgentBase {
        /**
        * Constructeur de la classe ConfigurationAgent
        * @param agentLibrary {AgentLibrary}
        * @param errorCallback {ErreurCallback}
        */
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        LirePreference(nomVariable: string): IPromesse<any>;
        EcrirePreference(nomVariable: string, valeurVariable: string): IPromesse<any>;
    }
}


declare module MyWay.Services.Trace {
    class TraceAgent extends Component.ComponentAgentBase implements ITraceService {
        private _agentLibrary;
        private _errorCallback;
        private _application;
        private _applicationVersion;
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback, application: string, applicationVersion: string);
        send(trace: TraceModel): IPromesse<any>;
    }
}


declare module MyWay.Services.TraceSuivi {
    class TraceSuiviAgent extends Component.ComponentAgentBase {
        private _errorCallback;
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        tracer(trace: MyWay.Services.TraceSuivi.TraceSuiviModel): IPromesse<any>;
    }
}


declare module MyWay.Services.Lisa {
    class ResultBase {
        ProchaineEtape: EtapeResult;
        ProcessDemarre: ProcessResult;
        constructor(data: any);
    }
    class NextResult extends ResultBase {
        CodeEtape: string;
        ValeurSortie: number;
        FinProcess: boolean;
        ValeurFinProcess: number;
        constructor(nextData: any);
    }
    class StartResult extends ResultBase {
        CodeProcessus: string;
        constructor(startData: any);
    }
    class ProcessResult {
        Code: string;
        Nom: string;
        EtapesConnues: string[];
        CodeEtape: string;
        OptionsProcess: string;
        OptionsProcessAsEtape: string;
        Actions: ActionResult[];
        constructor(processData: any);
    }
    class EtapeResult {
        TypeApplication: string;
        ValeurEntree: number;
        CodeApplication: string;
        NomApplication: string;
        CodeEtape: string;
        CodeMetier: string;
        Icone: string;
        LocalisationAbsolue: string;
        LocalisationRelative: string;
        Contrats: ContratResult[];
        Actions: ActionResult[];
        OptionsEtape: string;
        OptionsPointEntree: string;
        constructor(etapeData: any);
    }
    class ContratResult {
        Code: string;
        Type: string;
        Longueur: number;
        Nullable: boolean;
        Mode: string;
        OptionsContrat: string;
        constructor(contratData: any);
    }
    class ActionResult {
        ValeurSortie: number;
        EstExterne: boolean;
        NomExterne: string;
        OptionsAction: string;
        ValeursFinProcessPossibles: number[];
        constructor(actionData: any);
    }
    class ApplicationResult {
        Nom: string;
        Icone: string;
        Url: string;
        constructor(Nom: string, Icone: string, Url: string);
    }
}


/**
* Module de gestion technique des habilitations
* @module MyWay.Services.Habilitation
* classe : HabilitationTechAgent - public - Classe permettant l'administration des habilitations
*/
declare module MyWay.Services.Habilitation {
    /**
    * Classe permettant la gestion des habilitations
    */
    class HabilitationTechAgent extends Component.ComponentAgentBase {
        /**
        * Constructeur de la classe HabilitationTechAgent
        * @param {AgentLibrary}   agentLibrary  [description]
        * @param {ErreurCallback} errorCallback [description]
        */
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        /**
         * Renvoie toutes les habilitations disponibles, dans un tableau d'habilitations
         * @return {IPromesse<HabilitationModel[]>} [description]
         */
        ObtenirHabilitations(): IPromesse<any>;
        /**
         * Permet de récupérer une habilitation au format HabilitationModel
         * @param  {string}                       code [description]
         * @return {IPromesse<HabilitationModel>}                  [description]
         */
        ObtenirHabilitation(code: string): IPromesse<HabilitationModel>;
        /**
         * Ajoute ou modifie une habilitation
         * @param  {string}                       code Le code de l'habilitation à insérer / modifier
         * @param  {boolean}                      valeur           La valeur true/false de l'habilitation
         * @return {IPromesse<HabilitationModel>}                  [description]
         */
        ModifierHabilitation(code: string, valeur: boolean): IPromesse<HabilitationModel>;
        /**
         * Charge les habilitations en écrasant toutes les modifications faites par l'utilisateur
         * @return {IPromesse<HabilitationModel[]>} [description]
         */
        ChargerHabilitations(): IPromesse<HabilitationModel[]>;
    }
}


declare module MyWay.Services.Context {
    class ContextTechAgent extends Component.ComponentAgentBase {
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        /**
         * Renvoie toutes les variables partagées
         * @return {} [description]
         */
        GetSharedStorage(): IPromesse<any>;
        /**
         * Renvoie toutes les variables processus hors portail
         * @return {} [description]
         */
        GetWaitingProcesses(): IPromesse<any>;
        /**
         * Renvoie toutes les variables du portail
         * @return {} [description]
         */
        GetPortals(): IPromesse<any>;
        /**
         * Renvoie toutes les variables du global storage
         * @return {} [description]
         */
        GetGlobalStorage(): IPromesse<IContextKeyValuePair[]>;
        /**
         * Efface le contexte
         * @return {} [description]
         */
        ClearContext(): IPromesse<any>;
        /**
        * Efface le bus interop
        * @return {} [description]
        */
        ClearBus(): IPromesse<any>;
        AddToGlobalContext(kvp: MyWay.Services.Context.IContextKeyValuePair[]): IPromesse<any>;
        AddToTempoContext(kvp: MyWay.Services.Context.IContextKeyValuePair[]): IPromesse<any>;
        AddToMainProcessContext(key: string, value: string): IPromesse<any>;
        GetFromMainProcessContext(key: string): IPromesse<string>;
        GetCurrentMainProcess(): IPromesse<Context.IProcess>;
        AddToProcessStepContext(key: string, value: string, processStepId: string): IPromesse<any>;
    }
}


declare module MyWay.Services.DonneesDelocalisees {
    /**
    * Classe encapsulant les outils de debug et de diagnostics des données délocalisées
    * @classe TechDonneesDelocaliseesTools
    * fonction : deleteDbDonneesDelocalisees – private - Permet de supprimer la base de données IndexedDb des données délocalisées
    * fonction : getTDTById – private - Permet de récupérer l'objet TDT correspondant à l'identifiant passé en paramètre dans le storeTDT
    * fonction : deleteTDTById – private - Permet de supprimer l'objet TDT correspondant à l'identifiant passé en paramètre dans le storeTDT
    */
    class DonneesDelocaliseesTechAgent {
        private _messageService;
        /**
        * Constructeur de la classe TechDonneesDelocaliseesTools
        * @param messageAgent {MessageAgent}
        */
        constructor(messageService: Message.IMessageService);
        /**
         * Permet de supprimer et de réinitialiser la base de données IndexedDB des données délocalisées
         * @param callback {function} action à exécuter une fois les données supprimées
         * @param callbackError {function} action à exécuter en cas d'erreur (le message d'erreur est transmis en paramètre: messageErreur)
         */
        reInitDbDonneesDelocalisees(callback: () => void, callbackError: (erreur: Erreur) => void): void;
        /**
        * Permet de récupérer l'objet TDT correspondant à l'identifiant passé en paramètre dans le storeTDT
        * @param idTDT {string} identifiant du TDT à récupérer dans le storeTDT
        * @param callback {function} action à exécuter une fois que l'objet TDT a été récupérer (l'objet TDT récupéré est transmis en paramètre: objectTDT)
        * @param callbackError {function} action à exécuter en cas d'erreur (le message d'erreur est transmis en paramètre: messageErreur)
        */
        getTDTById(idTDT: string, callback: (objectTDT: any) => void, callbackError: (erreur: Erreur) => void): void;
        /**
        * Permet de supprimer l'objet TDT correspondant à l'identifiant passé en paramètre dans le storeTDT
        * @param idTDT {string} identifiant du TDT à supprimer dans le storeTDT
        * @param callback {function} action à exécuter une fois que l'objet TDT a été supprimé
        * @param callbackError {function} action à exécuter en cas d'erreur (le message d'erreur est transmis en paramètre: messageErreur)
        */
        deleteTDTById(idTDT: string, callback: () => void, callbackError: (erreur: Erreur) => void): void;
    }
}


declare module MyWay.Services.Interop {
    class InteropTechAgent extends Component.ComponentAgentBase {
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        Lancer(executableWrapper: Interop.ExecutableWrapper, contexte: Interop.ContexteMyway, parametres: string[], sync: boolean, errorCallback: ErreurCallback): void;
        AddToContextInterop(level: string, key: string, value: string, callback: (any) => void, errorCallback: ErreurCallback): void;
        AddListToContextInterop(level: string, datas: MyWay.Services.Context.IContextKeyValuePair[], callback: (any) => void, errorCallback: ErreurCallback): void;
        GetListFromContextInterop(level: string, datas: string[], callback: (returnDatas: MyWay.Services.Context.IContextKeyValuePair[]) => void, errorCallback: ErreurCallback): void;
        GetFromContextInterop(level: string, key: string, value: string, callback: (returnData: string) => void, errorCallback: ErreurCallback): void;
        EndStep(): void;
        AfficherWindow(handle: string, affiche: boolean): void;
        AfficherSynthese(numeroClient: string): void;
    }
}


declare module MyWay.Services.Lisa {
    class LisaTechAgent extends Component.ComponentAgentBase implements Component.IComponentAgent {
        constructor(agentLibrary: AgentLibrary, errorCallback: ErreurCallback);
        StartProcess(processCode: string, initData: MyWay.Services.Lisa.IInitialisationData, valeurDepart?: number): void;
        StartSubProcess(processCode: string, valeurDepart?: number): void;
        StartExternalApp(name: string, url: string): void;
        GetProcesses(): IPromesse<Lisa.ProcessResult[]>;
        GetTools(): IPromesse<Lisa.ApplicationResult[]>;
        /**
        * Récupère les codes des processus LISA
        */
        GetCodesProcessus(): IPromesse<string[]>;
        /**
        * Récupère les infos d'un processus LISA
        * @param {string}   codeProcessus
        * code du processus
        */
        GetInfoProcessus(codeProcessus: string): IPromesse<Lisa.IInfoProcessus>;
    }
}


declare module MyWay.Services.Trace {
    class TraceTechAgent {
        private _messageService;
        /**
        * Constructeur de la classe TechDonneesDelocaliseesTools
        * @param messageAgent {MessageAgent}
        */
        constructor(messageService: Message.IMessageService);
        getIntervallePurge(callback: (intervallePurge: number) => void, callbackError: (erreur: Erreur) => void): void;
        getQuotaPurge(callback: (quotaPurge: number) => void, callbackError: (erreur: Erreur) => void): void;
        getEnregistrerTracesDansBD(callback: (enregistrerTracesDansBD: boolean) => void, callbackError: (erreur: Erreur) => void): void;
        setNiveauMinimumTraceConsole(niveauMinimumTraceConsole: Trace.NIVEAUX_TRACE, callback: () => void, callbackError: (erreur: Erreur) => void): void;
        getNiveauMinimumTraceConsole(callback: (niveauMinimumTraceConsole: Trace.NIVEAUX_TRACE) => void, callbackError: (erreur: Erreur) => void): void;
        setNiveauMinimumTraceBD(niveauMinimumTraceBD: Trace.NIVEAUX_TRACE, callback: () => void, callbackError: (erreur: Erreur) => void): void;
        getNiveauMinimumTraceBD(callback: (niveauMinimumTraceBD: Trace.NIVEAUX_TRACE) => void, callbackError: (erreur: Erreur) => void): void;
        getAfficherTracesDansConsole(callback: (afficherTracesDansConsole: boolean) => void, callbackError: (erreur: Erreur) => void): void;
        reInitDbTraces(callback: () => void, callbackError: (erreur: Erreur) => void): void;
        addOldTraces(nbJours: number, callback: () => void, callbackError: (erreur: Erreur) => void): void;
        purgeTrace(dbRecordLimitInDays: number, callback: () => void, callbackError: (erreur: Erreur) => void): void;
        getTracesByLevel(niveau: Trace.NIVEAUX_TRACE, callback: (traces: any[]) => void, callbackError: (erreur: Erreur) => void): void;
    }
}


declare module MyWay.Services {
    class TechAgentProvider {
        constructor();
        init(serviceInit?: IServiceAgentInitialisation): IPromesse<TechAgent>;
    }
    class TechAgent extends ServiceAgent {
        private _contextTechAgent;
        private _donneesDelocaliseesTechAgent;
        private _habilitationTechAgent;
        private _interopTechAgent;
        private _lisaTechAgent;
        private _traceTechAgent;
        private _errorCallback;
        constructor();
        init(serviceInit?: IServiceAgentInitialisation): IPromesse<any>;
        ContextTechAgent: Context.ContextTechAgent;
        InteropTechAgent: Interop.InteropTechAgent;
        LisaTechAgent: Lisa.LisaTechAgent;
        Lancer(executableWrapper: Interop.ExecutableWrapper, contexte: Interop.ContexteMyway, parametres: string[], sync: boolean, errorCallback: ErreurCallback): void;
        AddToContextInterop(level: string, key: string, value: string, callback: (any) => void, errorCallback: ErreurCallback): void;
        AddListToContextInterop(level: string, datas: MyWay.Services.Context.IContextKeyValuePair[], callback: (any) => void, errorCallback: ErreurCallback): void;
        GetListFromContextInterop(level: string, datas: string[], callback: (returnDatas: MyWay.Services.Context.IContextKeyValuePair[]) => void, errorCallback: ErreurCallback): void;
        GetFromContextInterop(level: string, key: string, value: string, callback: (returnData: string) => void, errorCallback: ErreurCallback): void;
        EndStep(): void;
        AfficherWindow(handle: string, affiche: boolean): void;
        AfficherSynthese(numeroClient: string): void;
        DonneesDelocaliseesTechAgent: DonneesDelocalisees.DonneesDelocaliseesTechAgent;
        TraceTechAgent: Trace.TraceTechAgent;
        HabilitationTechAgent: Habilitation.HabilitationTechAgent;
        StartProcess(processCode: string, initData: MyWay.Services.Lisa.IInitialisationData, valeurDepart?: number): void;
        StartSubProcess(processCode: string, valeurDepart?: number): void;
        StartExternalApp(name: string, url: string): void;
        AddToGlobalContext(kvp: MyWay.Services.Context.IContextKeyValuePair[]): IPromesse<any>;
        AddToTempoContext(kvp: MyWay.Services.Context.IContextKeyValuePair[]): IPromesse<any>;
        AddToMainProcessContext(key: string, value: string): IPromesse<any>;
        GetFromMainProcessContext(key: string): IPromesse<string>;
        GetProcesses(): IPromesse<Lisa.ProcessResult[]>;
        GetTools(): IPromesse<Lisa.ApplicationResult[]>;
        purgerTraces(): IPromesse<any>;
        GetCurrentMainProcess(): IPromesse<Context.IProcess>;
        SendRequest(settings: IRequestSettingsExtended): IPromesse<any>;
        /**
        * Récupère les codes des processus LISA
        */
        GetCodesProcessus(): IPromesse<string[]>;
        /**
        * Récupère les infos d'un processus LISA
        * @param {string}   codeProcessus
        * code du processus
        */
        GetInfoProcessus(codeProcessus: string): IPromesse<Lisa.IInfoProcessus>;
    }
    class TechAgentExtended extends TechAgent {
        private $q;
        private instanceLoaderService;
        static $inject: string[];
        constructor($q: ng.IQService, instanceLoaderService: MyWay.Services.InstanceLoaderService);
    }
}
