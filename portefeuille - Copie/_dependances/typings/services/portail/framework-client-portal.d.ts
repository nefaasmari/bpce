/**
 * Generated by                   : ct-tfsbuild@SIEGCE8V2006
 * Branch                         : STC Main
 * Date                           : 20170621131936
 * Version MySys                  : v18.01
 * Version Socle Technique Client : 2018A
 * TFS hyperlink                  : http://tfs2013qpa.sigcesie.caisse-epargne.fr:8080/tfs/ITCEDefault/fwkManager.SocleTechnique/_versionControl/changeset/386567
 * Build droplocation             : \\Vfqitcappc100\tfs_qpa_build\myway\SocleTechnique\STC Main\STC Main_20170621.4
 */

declare module fwkManager {
    /**
     * Informations statiques du Socle Technique Client
     */
    class Framework {
        /**
         * Nom actuel du Socle Technique Client, utilisé dans les traces.
         * @type {string}
         */
        static NAME: string;
        /**
         * Version actuelle du Socle Technique Client, utilisé dans les traces.
         * @type {string}
         */
        static VERSION: string;
        /**
         * Informations sur le build TFS ayant généré cette version du Socle Technique Client
         * @type {string}
         */
        static BUILD: string;
    }
}

declare module fwkManager.Services {
    interface IServiceAgentInitialisation {
        codeApplication: string;
        onGlobalError?: ErreurCallback;
        onNotification?: (notification: NotificationMessage, serviceAgent?: IServiceAgent) => void;
        disableGetStepInfo?: boolean;
        /**
         * Attribut permettant la désactivation de la sauvegarde du scope
         *
         * Si disableScopeSave est à true ou n'est pas renseigné, la sauvegarde du scope ne s'effectue pas
         *
         * Si disableScopeSave est à false, la sauvegarde du scope s'effectue
         *
         * @type {boolean}
         */
        disableScopeSave?: boolean;
        donneesScopeASauvegarder?: string[];
        scopeType?: Context.ScopeType;
        listenedContextKey?: string;
        capacitesChat?: boolean;
    }
    interface IServiceAgent {
        Core: CoreCommon;
        Lisa: Lisa.ILisaAgent;
        Context: Context.IContextAgent;
        Dates: Dates.DatesCommon;
        DonneesDelocalisees: DonneesDelocalisees.IDonneesDelocaliseesAgent;
        Habilitation: Habilitation.IHabilitationAgent;
        Communication: Communication.ICommunicationAgent;
        Trace: Trace.Logger;
        init(serviceInit?: IServiceAgentInitialisation): IPromesse<any>;
        DisplayMessage(message: IMessage): void;
        SendRequest(settings: IRequestSettings): IPromesse<any>;
        SubscribeToNotification(onNotification: (notification: NotificationMessage, serviceAgent?: IServiceAgent) => void): any;
        Dispose(): any;
        OnNotification(notification: NotificationMessage, serviceAgent?: IServiceAgent): any;
    }
}

declare module fwkManager.Services {
    interface NotificationEvent<T> extends NotificationMessage {
        type: CommonEventType;
        Contenu: T;
    }
    export const enum CommonEventType {
        BriqueCommunication = 1,
    }
}


declare module fwkManager.Services.Loggers {
    interface IConfig {
        appenders: IConfigAppender[];
        loggers: IConfigLogger[];
    }
    interface IConfigAppender {
        type: string;
        level: LEVEL;
        class: string;
        config: any;
    }
    interface IConfigLogger {
        name: string;
        level: LEVEL;
        appenders: string[];
    }
    interface ILogger {
        debug: (pMessage: string, ...arguments: any[]) => void;
        info: (pMessage: string, ...arguments: any[]) => void;
        warn: (pMessage: string, ...arguments: any[]) => void;
        error: (pMessage: string, ...arguments: any[]) => void;
        tracer: (ILoggerWithContext) => void;
    }
    export const enum LEVEL {
        DEBUG,
        INFO,
        WARN,
        ERROR,
    }
    interface IAppender {
        name: string;
        level: LEVEL;
        class: string;
        append(pMessage: ILoggerWithContext): void;
        getConfig: () => any;
    }
    interface ILoggerCategorie {
        name: string;
        level: LEVEL;
        appenders: IAppender[];
    }
    interface IConsoleAppenderConfig {
        format: string;
    }
    interface IFormater {
        format(pMessage: ILoggerWithContext): string;
    }
    interface ILoggerWithContext {
        packageName: string;
        niveau: LEVEL;
        message: string;
        arguments: any[];
        date: number;
        context: {
            [key: string]: any;
        };
    }
}


declare module fwkManager.Services.Loggers {
    class LoggerFactory {
        static LOGGER_PORTAIL: string;
        static LOGGER_AGENTS: string;
        isInit: boolean;
        private LOGGER_ACTUEL;
        static _INSTANCE: LoggerFactory;
        static INSTANCE: LoggerFactory;
        constructor();
        private getClassByName(pName);
        getClass(pClass: string): ILogger;
        private addAppender(pAppender);
        private addLogger(pLogger);
        private appenderToConfigAppender(pAppender);
        private loggerToConfigLogger(pLogger);
        private rechargerConfigurationsLoggers();
        setConfigActual(pConfig: IConfig): void;
        setConfigDB(pNom: string, pConfig: IConfig): void;
        getConfigurationActual(): IConfig;
        getConfigurationDB(pNom: string): IConfig;
        saveConfiguration(pNom: string): void;
        loadConfiguration(pNom?: string): void;
        getNomConfigActuelle(): string;
        getAllLogggersNames(): string[];
        supprimerConfiguration(pNom: string): void;
        clearConfigurations(): void;
    }
}


declare module fwkManager.Services.Loggers {
    var appenders: IAppender[];
    var categories: ILoggerCategorie[];
    var loggers: Logger[];
    var loggersParNom: {
        [key: string]: ILogger;
    };
    class LoggerHelper {
        static _INSTANCE: LoggerHelper;
        static INSTANCE: LoggerHelper;
        testLevel(pLevelMessage: LEVEL, pLevelSortie: LEVEL): boolean;
        getAppenders(pPackageName: string): {
            appender: IAppender;
            levelMin: LEVEL;
        }[];
        getContext(): {
            [key: string]: IKeyValuePair<string, any>;
        };
    }
}


declare module fwkManager.Services.Loggers {
    class Logger implements ILogger {
        private packageName;
        private levelMinimum;
        private appenders;
        private _cache;
        constructor(classe: string);
        private internalLog(pLevel, pMessage, args);
        tracer(pTrace: ILoggerWithContext): void;
        debug(pMessage: string, ...args: any[]): void;
        info(pMessage: string, ...args: any[]): void;
        warn(pMessage: string, ...args: any[]): void;
        error(pMessage: string, ...args: any[]): void;
        verifierNiveauMinimum(): void;
        private clearCache();
    }
}


declare module fwkManager.Services.Loggers {
    class MDC {
        private mdc;
        private stringify;
        static _INSTANCE: MDC;
        static INSTANCE: MDC;
        setValue(pCle: string, pValeur: any): void;
        getValue(pCle: string): any;
        remove(pCle: string): void;
        getAll(): {
            [key: string]: any;
        };
    }
}


declare module fwkManager.Services.Loggers {
    class FLASH {
        private flash;
        static _INSTANCE: FLASH;
        static INSTANCE: FLASH;
        setValue(pCle: string, pValeur: any): void;
        getValue(pCle: string): any;
        setAll(pFlashs: {
            [key: string]: any;
        }): void;
        getAll(): {
            [key: string]: any;
        };
    }
}


declare module fwkManager.Services.Loggers.Appenders {
    class AbstractAppender implements IAppender {
        name: string;
        level: LEVEL;
        private config;
        class: string;
        constructor(name: string, pClass: string, level: LEVEL, config: any);
        getConfig(): any;
        append(pMessage: ILoggerWithContext): void;
        protected onAppend(pMessage: ILoggerWithContext): void;
    }
}


declare module fwkManager.Services.Loggers.Appenders {
    class ConsoleAppender extends AbstractAppender {
        static CLASSNAME: string;
        private format;
        constructor(pNom: string, level: LEVEL, config: IConsoleAppenderConfig);
        onAppend(pMessage: ILoggerWithContext): void;
        private parse(pFormat);
    }
}


declare module fwkManager.Services.Loggers.Formaters {
    class DateFormater implements IFormater {
        private formatter;
        constructor(pConfig?: string);
        format(pMessage: ILoggerWithContext): string;
        private parse(pConfig?);
    }
}


declare module fwkManager.Services.Loggers.Formaters {
    class MessageFormater implements IFormater {
        format(pMessage: ILoggerWithContext): string;
    }
}


declare module fwkManager.Services.Loggers.Messages {
    var NOM_BIBLIOTHEQUE: string;
    export const enum TYPE {
        GET_CONFIG_ACTUAL,
        SET_CONFIG_ACTUAL,
        GET_CONFIG_DB,
        SET_CONFIG_DB,
        SAVE_CONFIG,
        LOAD_CONFIG,
        GET_LOGGERS,
        GET_NOM_CONFIG_ACTUELLE,
        IS_CLASS_EXISTS,
        RESET,
    }
    interface IGetConfigDBRequest {
        nom: string;
    }
    interface IGetConfigDBResponse {
        config: IConfig;
    }
    interface IGetConfigActualResponse {
        config: IConfig;
    }
    interface IGetLoggersResponse {
        loggers: string[];
    }
    interface ISetConfigDBRequest {
        nom: string;
        config: IConfig;
    }
    interface ISetConfigActualRequest {
        config: IConfig;
    }
    interface ILoadConfigRequest {
        nom: string;
    }
    interface ISaveConfigRequest {
        nom: string;
    }
    interface IGetNomConfigActuelleResponse {
        nom: string;
    }
    interface IIsClassExistsRequest {
        nom: string;
    }
    interface IIsClassExistsResponse {
        isExists: boolean;
    }
}


declare module fwkManager.Services.Component {
    interface ICoreComponent {
        ComponentName: string;
        ZoneName: string;
    }
    interface IComponent extends ICoreComponent {
        Library: IComponentLibrary;
        HandleMessage(event: MessageEvent, sendResponseCallback: ResponseCallback): any;
    }
    interface ResponseCallback {
        (event: MessageEvent, callbackContent: any, error: Erreur): void;
    }
}

declare module fwkManager.Services.Component {
    interface IComponentLibrary {
        PreventMessage: boolean;
        Add(component: IComponent): any;
    }
}


declare module fwkManager.Services.Component {
    class ComponentBase implements IComponent {
        private static CLASS_NAMEBase;
        private static loggerBase;
        ComponentName: string;
        ZoneName: string;
        Library: IComponentLibrary;
        ErreurCallback: ErreurCallback;
        constructor(library: IComponentLibrary, componentName: string, zoneName: string, errorCallback: ErreurCallback);
        HandleMessage(event: MessageEvent, sendResponseCallback: ResponseCallback): void;
    }
}


declare module fwkManager.Services.Component {
    class ComponentApiBase implements ICoreComponent {
        private static CLASS_NAMEBase;
        private static loggerBase;
        ComponentName: string;
        ZoneName: string;
        constructor(componentName: string);
        WarnLocalServiceUnavailability(): void;
    }
}


declare module fwkManager.Services.Component {
    class ComponentCommonBase extends ComponentBase implements IComponent {
        constructor(library: IComponentLibrary, name: string);
    }
}

declare module fwkManager.Services.Component {
    class ComponentLibraryBase implements IComponentLibrary {
        PreventMessage: boolean;
        Add(component: IComponent): void;
    }
}

declare module fwkManager.Services.Component {
    class TempLibrary implements IComponentLibrary {
        PreventMessage: boolean;
        Add(component: IComponent): void;
    }
}


declare module fwkManager.Services {
    /**
     * Fournit un contrat d'utilisation des promesses fwkManager.
     *
     * Utilise le service de promesses d'AngularJS s'il est disponible ($q) et le service externe Q dans le cas contraire.
     *
     */
    interface IServiceDePromesse {
        /**
         * ~~~ts
         * var promises: fwkManager.Services.IPromesse<any>[] = [];
         * promises.push(serviceAgent.Context.AddToContext('foo', 'toto'));
         * promises.push(serviceAgent.Context.AddToContext('bar', "titi"));
         * fwkManager.Services.CoreCommon.ServiceDePromesse.all(promises).then(() => {
         *     // actions à effectuer si les 2 promesses sont tenues
         *     ...
         * });
         * ~~~
         */
        all<T>(promises: IPromesse<T>[]): IPromesse<T[]>;
        all<T>(promises: any[]): IPromesse<T[]>;
        /**
         * Créé un objet permettant de valider ou rejeter la promesse demandée.
         *
         * ~~~ts
         * var deferred: IDeferred<string> = CoreCommon.ServiceDePromesse.defer<string>();
         * this.SendMessage(
         *     "GetFromContext",
         *     { key: key },
         *     (value: string) => { deferred.resolve(value); },
         *     (error?: Erreur) => { deferred.reject(error); }
         * );
         * return deferred.promise;
         * ~~~
         */
        defer<T>(erreurCallback?: ErreurCallback): IDeferred<T>;
        /**
         * Retourne une promesse qui est rejetée avec comme raison le paramètre passé.
         *
         */
        reject<T>(reason?: Erreur): IPromesse<T>;
        /**
         * Encapsule un objet qui peut être soit une valeur soit une promesse "chainable" dans une promesse $q ou Q.
         *
         * Cela peut être utile lorsque on a affaire à un objet qui peut (ou ne pas) être une promesse, ou si la promesse provient d'une source qui ne peut pas être certifiée.
         */
        when<T>(value: T): IPromesse<T>;
    }
    interface IPromesse<T> {
        /**
         * La méthode "then" fournit les callbacks qui recoivent
         *
         * - soit la valeur actuelle (ou éventuelle) d'une promesse (fulfill),
         *
         * - soit la raison pour laquelle cette promesse ne peut pas être tenue (reject).
         *
         * ~~~ts
         *serviceAgent.Context.GetFromContext('toto').then((value: string) => {
         *    // traitement du retour de promesse tenue (value)
         *    ...
         * });
         * ~~~
         *
         */
        then<TResult>(onFulfill: (value: T) => IPromesse<TResult>, onReject?: (reason: Erreur) => any, onProgress?: Function): IPromesse<TResult>;
        then<TResult>(onFulfill: (value: T) => IPromesse<TResult>, onReject?: (reason: Erreur) => TResult, onProgress?: Function): IPromesse<TResult>;
        then<TResult>(onFulfill: (value: T) => TResult, onReject?: (reason: Erreur) => TResult, onProgress?: Function): IPromesse<TResult>;
        /**
         * Cette méthode est un alias du callback "onReject" de la méthode "then": promise.then(null, errorCallback)
         *
         * ~~~ts
         * serviceAgent.Context.GetFromContext('toto').then((value: string) => {
         *     // traitement du retour de promesse tenue
         *     ...
         * }).catch((erreur: fwkManager.Services.Erreur) => {
         *     // traitement du retour de promesse non tenue (erreur)
         *     ...
         * });
         * ~~~
         */
        catch<TResult>(onRejected: (reason: Erreur) => TResult): IPromesse<TResult>;
        catch<TResult>(onRejected: (reason: Erreur) => IPromesse<TResult>): IPromesse<TResult>;
        /**
         * Permet d'observer le succès ou le rejet d'une promesse, mais sans modifier la valeur finale.
         *
         * Cette méthode est utile pour libérer des resources ou effectuer un nettoyage peu importe le résultat de la promesse.
         *
         * ~~~ts
         * serviceAgent.Context.GetFromContext('toto').then((value: string) => {
         *     // traitement du retour de promesse tenue
         *     ...
         * }).catch((erreur: fwkManager.Services.Erreur) => {
         *     // traitement du retour de promesse non tenue (erreur)
         *     ...
         * }).finally(() => {
         *     // cleanup
         *     serviceAgent.Dispose();
         *     serviceAgent = null;
         * });
         * ~~~
         */
        finally(finallyCallback: () => any): IPromesse<T>;
    }
    /**
     * Objet retourné par la méthode "defer" permettant de valider ou rejeter la promesse demandée.
     */
    interface IDeferred<T> {
        /**
         * Cette méthode controle l'état de la propriété "promise" dans le cas où la promesse est tenue.
         *
         * Dans le cas où une promesse est tenue, sa résolution est permanente et ne peut pas être résolue une seconde fois.
         *
         * ~~~ts
         * var deferred: IDeferred<string> = CoreCommon.ServiceDePromesse.defer<string>();
         * this.SendMessage(
         *     "GetFromContext",
         *     { key: key },
         *     (value: string) => {
         *         deferred.resolve(value);
         *     },
         *     null
         * );
         * return deferred.promise;
         * ~~~
         */
        resolve(value?: T): void;
        /**
         * Cette méthode controle l'état de la propriété "promise" dans le cas où la promesse n'est pas tenue.
         *
         * On peut donner une raison de refus lors de l'appel à cette méthode. Dans notre cas une raison de type "Erreur".
         *
         * ~~~ts
         * var deferred: IDeferred<string> = CoreCommon.ServiceDePromesse.defer<string>();
         * this.SendMessage(
         *     "GetFromContext",
         *     { key: key },
         *     (value: string) => {
         *         deferred.resolve(value);
         *     }, // resolve
         *     (error?: Erreur) => {
         *         deferred.reject(error);
         *     }
         * );
         * return deferred.promise;
         * ~~~
         */
        reject(reason?: Erreur): void;
        /**
         * L'appel à cette méthode avec une valeur va notifier la promesse de cette valeur.
         *
         * Tout handler de type "onProgress" abonné à notre promesse réceptionnera cette valeur de progression (ou d'état).
         *
         */
        notify(state?: any): void;
        promise: IPromesse<T>;
    }
    class MonServiceDePromesse implements IServiceDePromesse {
        private innerService;
        lastReason: Erreur;
        constructor(innerService: IServiceDePromesse);
        all<T>(promises: IPromesse<T>[]): IPromesse<T[]>;
        all<T>(promises: any[]): IPromesse<T[]>;
        defer<T>(erreurCallback?: ErreurCallback): IDeferred<T>;
        reject<T>(reason?: Erreur): IPromesse<T>;
        when<T>(value: T): IPromesse<T>;
    }
    class MaPromesse<T> implements IPromesse<T> {
        private innerPromesse;
        private erreurCallback;
        lastReason: Erreur;
        private _catchHappened;
        constructor(innerPromesse: IPromesse<T>, erreurCallback?: ErreurCallback);
        then<TResult>(onFulfill: (value: T) => IPromesse<TResult>, onReject?: (reason: Erreur) => any, onProgress?: Function): IPromesse<TResult>;
        then<TResult>(onFulfill: (value: T) => IPromesse<TResult>, onReject?: (reason: Erreur) => TResult, onProgress?: Function): IPromesse<TResult>;
        then<TResult>(onFulfill: (value: T) => TResult, onReject?: (reason: Erreur) => TResult, onProgress?: Function): IPromesse<TResult>;
        catch<TResult>(onRejected: (reason: Erreur) => TResult): IPromesse<TResult>;
        catch<TResult>(onRejected: (reason: Erreur) => IPromesse<TResult>): IPromesse<TResult>;
        finally(finallyCallback: () => any): IPromesse<T>;
    }
    class MonDeferred<T> implements IDeferred<T> {
        private innerDeferred;
        private erreurCallback;
        promesse: MaPromesse<T>;
        constructor(innerDeferred: IDeferred<T>, erreurCallback?: ErreurCallback);
        resolve: (value?: T) => void;
        reject: (reason?: Erreur) => void;
        notify: (state?: any) => void;
        promise: IPromesse<T>;
    }
}


declare module fwkManager.Services {
    interface ICommonLibrary {
        Core: CoreCommon;
        Context: Context.IContextCommon;
    }
}


declare module fwkManager.Services {
    class InstanceLoaderService {
        private $parse;
        static $inject: string[];
        constructor($parse: ng.IParseService);
        createInstance<T>(name: string, ...args: any[]): T;
    }
    class CoreCommon extends Component.ComponentCommonBase {
        private static CLASS_NAME;
        private static logger;
        private _supportIndexed;
        private _serviceLocalDisponible;
        static ServiceDePromesse: IServiceDePromesse;
        static PreventMultipleJSONCalls: boolean;
        static VersionMySys: string;
        constructor(library: Component.IComponentLibrary);
        static init(): void;
        static executePromisesSequentially(pPromises: Array<() => IPromesse<any>>): IPromesse<void>;
        FindKeysToReplace(rawPathData: any): string[];
        /**
        * Permet de connaître le navigateur utilisé
        * @return {string}   nom du navigateur
        */
        GetBrowser(): string;
        static GetBrowserStatic(): string;
        /**
        * Permet de connaître la version du navigateur utilisé
        * @return {string}   nom du navigateur
        */
        GetBrowserVersion(): string;
        static GetBrowserVersionStatic(): string;
        /**
        * Permet si le navigateur utilisé est un navigateur mobile ou non
        * @return {boolean}   oui : c'est un navigateur mobile
        */
        static IsMobileBrowser(): boolean;
        SerializeScope(scope: any): string;
        ApplyProperties(from: any, to: any): void;
        static IsFunction(functionToCheck: any): boolean;
        /**
        * Détermine si le navigateur utilisé est IE ou non
        */
        static checkIsIE(): boolean;
        /**
        * Détermine si le service local est disponible ou non
        */
        serviceLocalDisponible(): boolean;
        /**
        * Retourne la version d'Internet Explorer
        */
        private static getInternetExplorerVersion();
        SwapArrayElements(arrayObject: any[], index_a: number, index_b: number): void;
        static SendRequestWithPromise(settings: IRequestSettingsExtended): IPromesse<any>;
        static SendRequest(settings: IRequestSettingsExtended, success: (data) => void, error: ErreurCallback): IXMLHttpRequest;
        static FixedEncodeURIComponent(str: string): string;
        static GetParams(params: any): string;
        private static AddMyWayHeaders(ixhr, settings);
        private static SavedJSON;
        private static Send(ixhr, logger, withCredentials);
        private static GetResponse(xhr, responseType, logger);
        private static traiterErreur(xhr, ixhr, logger, error?, isTimeout?);
        private static CheckSettings(settings);
        static creerChaineAleatoire(taille: number): string;
        creerChaineAleatoire(taille: number): string;
        static applyProperties(source: any, target: any, propName: any): void;
        /**
        * Permet le chargement dynamique d'un script présent dans le repertoire services du cdn
        * @param {string}   path
        * nom du fichier à charger
        */
        static loadCdnServiceScript(path: any): void;
        /**
        * Permet le chargement dynamique d'un script présent dans le repertoire services-addons du cdn
        * @param {string}   path
        * nom du fichier à charger
        */
        static loadCdnAddonsServiceScript(path: any): void;
        /**
        * Permet le récuperer le chemin d'un fichier de framework
        * @param {string}   path
        * nom du fichier à charger
        */
        static getBaseFolder(path: any): string;
        /**
        * Permet le chargement dynamique d'un script JS
        * @param {string}   path
        * chemin du fichier à charger
        */
        static loadScript(path: any): void;
        /**
         * Permet d'encoder certains caractères d'une string dont ~!*()' pour les passer en paramètres d'une URL
         * @param  {string} str Chaine de caractères à encoder
         * @return {string}     Chaine de caractères encodée
         */
        static encoderURL(str: string): string;
        static promesseTryCatch<T>(pCallback: (pDefer: IDeferred<T>) => any, pCallbackErreur?: (pErreur: Erreur, pDefer: IDeferred<T>) => any): IPromesse<T>;
        promesseTryCatch<T>(pCallback: (pDefer: IDeferred<T>) => any, pCallbackErreur?: (pErreur: Erreur, pDefer: IDeferred<T>) => any): IPromesse<T>;
        /**
         * Utilitaires pour le traitement des strings
         */
        static StringUtils: {
            leftPad: (pMorceauAFormater: string | number, pMorceauARajouter: string, pLongueurDesiree: number) => string;
            rightPad: (pMorceauAFormater: string | number, pMorceauARajouter: string, pLongueurDesiree: number) => string;
        };
        StringUtils: {
            leftPad: (pMorceauAFormater: string | number, pMorceauARajouter: string, pLongueurDesiree: number) => string;
            rightPad: (pMorceauAFormater: string | number, pMorceauARajouter: string, pLongueurDesiree: number) => string;
        };
        /**
         * Test si la valeur passé en paramètre est un objet
         *
         * @param {any} item la valeur à tester
         *
         * @return {boolean} true si c'est un objet sinon false
         */
        static isObject(item: any): boolean;
        /**
         * Utilitaires pour les tableaux
         */
        static ArrayUtils: {
            remove: (pArray: any[], pCompare: (pElement: any) => boolean) => any[];
            keyExists: (key: any, search: any) => boolean;
            getOne(pArray: any[], pCompare: (pElement: any) => boolean): any;
        };
        /**
         * Utilitaires pour les enums
         */
        static EnumUtils: {
            getNamesAndValues<T extends number>(e: any): {
                name: string;
                value: T;
            }[];
            getNames(e: any): string[];
            getValues<T extends number>(e: any): T[];
            getObjValues(e: any): (number | string)[];
            listerEnums<T>(enumClass: any): T[];
            getName(enumClass: any, value: number): string;
        };
        /**
         * Utilitaires pour les objets
         */
        static ObjectUtils: {
            hasKeys: (keys: string[], object: Object, strict?: boolean) => boolean;
            objectExistsByKeyValueList: <T extends Object>(keyValueList: IKeyValuePair<string, any>[], search: T[]) => T;
            hasKeyValuePairList: (obj: Object, keyValueList: IKeyValuePair<string, any>[]) => boolean;
            objectToArray: (object: Object) => IKeyValuePair<string, any>[];
            merge: (destination: Object, source: Object) => Object;
            deepEquals: (pObject1: any, pObject2: any) => boolean;
        };
        ObjectUtils: {
            hasKeys: (keys: string[], object: Object, strict?: boolean) => boolean;
            objectExistsByKeyValueList: <T extends Object>(keyValueList: IKeyValuePair<string, any>[], search: T[]) => T;
            hasKeyValuePairList: (obj: Object, keyValueList: IKeyValuePair<string, any>[]) => boolean;
            objectToArray: (object: Object) => IKeyValuePair<string, any>[];
            merge: (destination: Object, source: Object) => Object;
            deepEquals: (pObject1: any, pObject2: any) => boolean;
        };
        static getAdresseIP(): IPromesse<string>;
        /**
         * Utilitaires pour les adresses IP
         */
        static AdresseIPUtils: {
            getAdresseIP: () => IPromesse<string>;
            convertirIPEnBinaire: (adresseIp: string) => string;
            recupererSousReseau: (pAdresseIp: string, pMasque: string) => string;
        };
    }
    interface IKeyValuePair<K, V> {
        Key: K;
        Value: V;
    }
    /**
     * Interface de définition d'un message pour l'affichage
    *
    * @param Type {string} optionnel : Le type de message (nom de la classe Bootstrap)
    * @param Message {string} : Le message à afficher
    * @param Duree {number} optionel :
    */
    interface IMessage {
        Type?: string;
        Message: string;
        Duree?: number;
    }
    class ExecutionAppliExt {
        CodeRetour: string;
        MessageRetour: string;
        DonneesRetour: string;
        Pid: string;
        constructor(codeRetour: string, messageRetour: string, donneesRetour: string, pid: string);
    }
    interface ErreurCallback {
        (erreur: Erreur): void;
    }
    class Erreur {
        codeLibelle: string;
        valeurs: string[];
        error: Error;
        codeHttp: number;
        libelle: string;
        causes: Erreur[];
        constructor(codeLibelle: string, valeurs?: string[], causes?: Erreur[]);
    }
    class ErreurClient extends Erreur {
        constructor(codeLibelle: string, valeurs?: string[], error?: Error);
    }
    class ErreurServeur extends Erreur {
        constructor(codeHttp: number, codeLibelle: string, libelle: string, valeurs?: string[], causes?: ErreurServeur[]);
    }
    /**
        * Interface de définition des paramètres d'envoi d'une requête REST
        *
        * @param method  {MethodEnum} optionnel : Methode de la requête (valeur par défaut : GET si data est vide, POST si data est un non vide)
        * @param url  {string} optionnel : Url de la ressource
        * @param params  {any} optionnel : Paramètre d'appel de la resource. C'est un objet dont les noms des champs seront utilisés pour créer les paramètres de l'url
        * @param data  {any} optionnel : Donnée contenue dans le corps de la requête
        * @param async  {boolean} optionnel : Permet de définir des requetes synchrones/asynchrones (valeur par défaut : true)
        * @param contentType  {ContentTypeEnum} optionnel : Type du contenu (valeur par défaut : NONE si data est vide, JSON si data est non vide)
        * @param accept {AcceptEnum} optionnel : Contenu accepté en retour (valeur par défaut : ALL)
        * @param cache {boolean} optionnel : Utilisation du cache (valeur par défaut : false)
        * @param withHeaders {boolean} optionnel : Ajoute à la requête les headers MyWay si vrai (valeur par défaut : false)
        * @param responseType {ResponseTypeEnum} optionnel : Type de réponse attendue (valeur par défaut : NOT_DEFINED)
        * @param oldHeader {boolean} optionnel
        * @param timeout {number} optionnel
        */
    interface IRequestSettings {
        method?: MethodEnum;
        url?: string;
        params?: any;
        data?: any;
        async?: boolean;
        contentType?: ContentTypeEnum;
        accept?: AcceptEnum;
        cache?: boolean;
        withHeaders?: boolean;
        responseType?: ResponseTypeEnum;
        oldHeader?: boolean;
        timeout?: number;
    }
    interface IRequestSettingsExtended extends IRequestSettings {
        authentificationInfo?: Context.AuthentificationInfo;
        parametresComptables?: Context.ParametresComptables;
        stepInfo?: Context.StepInfoExtended;
        logger?: Trace.ILogger;
        additionalHeaders?: {
            [key: string]: string;
        };
        type?: string;
        versionComposant?: string;
    }
    export const enum ContentTypeEnum {
        NONE = 0,
        URL_ENCODED = 1,
        JSON = 2,
    }
    export const enum ResponseTypeEnum {
        BLOB = 0,
        JSON = 1,
        EMPTY = 2,
        NOT_DEFINED = 3,
    }
    export const enum AcceptEnum {
        ALL = 0,
        JSON = 1,
    }
    export const enum MethodEnum {
        DELETE = 0,
        GET = 1,
        POST = 2,
        PUT = 3,
    }
    interface IXMLHttpRequest {
        url?: string;
        headers?: {
            [key: string]: string;
        };
        method?: string;
        async?: boolean;
        data?: string;
        responseType?: string;
        success?: (data) => void;
        timeout?: number;
        error?: ErreurCallback;
    }
    /**
     * Information de diagnostic du demarrage d'une application
     *    Les jalons de démarrage d'une SPA sont:
     *     - previousStepEndTime : fin de l'étape précédente
     *       * si première étape, temps de démarrage du processus
     *       * si étape précédente est routeur, temps de fin de l'étape précédente
     *     - stepStartTime : début de l'étape
     *     - displayTime: début de l'affichage SPA
     *     - initTime: init service agent
     *     - lastDigestCycleTime: dernier cycle de digestion angular
     *
     *     Les temps de démarrage d'une SPA sont calculés à partir des jalons suivants:
     *     - stepStartDuration : entre fin de l'étape précédente et début affichage SPA
     *     - displayDuration : entre début affichage SPA et init serviceAgent
     *     - digestDuration : entre init serviceAgent et dernier cycle de digestion
     *
     *    Le temps d'analyse sont:
     *     - totalDisplayDuration : displayDuration + digestDuration
     *     - totalStartDuration: stepStartDuration + totalDisplayDuration
     */
    class ApplicationDiagnostic {
        /**
         * Code Application
         */
        codeApplication: string;
        /**
         * Id de l'étape
         */
        stepId: string;
        /**
         * Jalon de fin d'étape précédente
         */
        private _previousStepEndTime;
        /**
         * Jalon de début d'étape
         */
        private _stepStartTime;
        /**
         * Jalon de début d'affichage de la SPA
         */
        private _displayTime;
        /**
         * Jalon de début initialisation du serviceAgent
         */
        private _initTime;
        /**
         * Jalon du ressenti utilisateur (utilisation du listenedContextKey par les applications)
         */
        private _userTime;
        /**
         * Jalon du dernier cycle de digestion angular
         */
        private _lastDigestCycleTime;
        /**
         * Nombre de watchers dans l'application
         */
        watchers: number;
        /**
         * Nombre de cycles de digestion angular
         */
        digestCycles: number;
        /**
         * Taille du contexte
         */
        contextSize: number;
        constructor();
        /**
         * Jalon de fin d'étape précédente
         */
        previousStepEndTime: number;
        /**
         * Jalon de début d'étape
         */
        stepStartTime: number;
        /**
         * Jalon de début d'affichage de la SPA
         */
        displayTime: number;
        /**
         * Jalon de début initialisation du serviceAgent
         */
        initTime: number;
        /**
         * Jalon du ressenti utilisateur (utilisation du listenedContextKey par les applications)
         */
        userTime: number;
        /**
         * Jalon du dernier cycle de digestion angular
         */
        lastDigestCycleTime: number;
        /**
         * Temps de démarrage entre fin de l'étape précédente et début affichage SPA
         */
        stepStartDuration: number;
        /**
         * Temps de démarrage entre début affichage SPA et init serviceAgent
         */
        staticFilesLoadDuration: number;
        /**
         * Temps de démarrage entre init serviceAgent et dernier cycle de digestion
         */
        digestDuration: number;
        /**
         * Temps de démarrage entre début affichage SPA et jalon du ressenti utilisateur (utilisation du listenedContextKey par les applications)
         */
        userDuration: number;
        /**
         * Durée totale de l'affichage de l'application
         */
        totalDisplayDuration: number;
        /**
         * Durée totale du démarrage de l'application
         */
        totalStartDuration: number;
        /**
         * Durée totale du démarrage de l'application ressenti par l'utilisateur
         */
        totalUserDuration: number;
        userDurationEnabled: boolean;
        /**
         * Status du démarrage
         */
        startStatus: string;
        /**
         * Status du nombre de watchers
         */
        watchersStatus: string;
        /**
         * Status du nombre de cycles de digestion
         */
        digestStatus: string;
        /**
         * Status de la quantité de données de contexte
         */
        contextStatus: string;
        /**
         * Clone les valeurs d'un diagnostic
         */
        clone(source: ApplicationDiagnostic): void;
    }
}
interface JSON {
    pruned(value: any, depthDecr?: any, arrayMaxLength?: any): any;
}

declare module fwkManager.Services {
    class NotificationMessage {
        Sujet: string;
        Contenu: any;
    }
}


declare module fwkManager.Services.Common {
    class ArbreBinaire<T> {
        private _racine;
        private _fonctionCompare;
        private _doublonsPossibles;
        private _nombreElements;
        constructor(pFonctionCompare: (pEl1: T, pEl2: T) => number, pDoublonsPossibles: boolean);
        testerElements(pEl1: T, pEl2: T): number;
        doublonsPossibles: boolean;
        nombreElements: number;
        ajouter(pNouveauElement: T): boolean;
        retirer(pFonctionTest: (pElement: T) => boolean): void;
        inferieurAAsc(pElementSuperieur: T, pInclureElement: boolean, pCallback: (pElement: T) => void): void;
        inferieurADesc(pElementSuperieur: T, pInclureElement: boolean, pCallback: (pElement: T) => void): void;
        superieurAAsc(pElementSuperieur: T, pInclureElement: boolean, pCallback: (pElement: T) => void): void;
        superieurADesc(pElementSuperieur: T, pInclureElement: boolean, pCallback: (pElement: T) => void): void;
        entreBornesAsc(pElementInferieur: T, pInclureElementInferieur: boolean, pElementSuperieur: T, pInclureElementSuperieur: boolean, pCallback: (pElement: T) => void): void;
        entreBornesDesc(pElementInferieur: T, pInclureElementInferieur: boolean, pElementSuperieur: T, pInclureElementSuperieur: boolean, pCallback: (pElement: T) => void): void;
        toutParcourir(pCallback: (pElement: T) => void): void;
        getParCritere(pFonctionTest: (pElement: T) => boolean, pCallback: (pElement: T) => void): void;
        isExists(pElement: T): boolean;
        getElement(pElement: T): T;
        private getElementInternal(pElement, pNoeud);
        private getPlusGrandInferieurA(pElementBorne, pInclureBorne, pNoeud);
        private getPlusPetitSuperieurA(pElementBorne, pInclureBorne, pNoeud);
        private getMinimum(pNoeud);
        private getMaximum(pNoeud);
        private getSuivant(pNoeud);
        private getPrecedent(pNoeud);
        private placerElement(pNouveauElement, pNoeudCourant);
        private retirerElement(pNoeudCourant);
    }
}


/**
* Module de gestion de la numérisation (module commun aux agents et aux managers)
* @module fwkManager.Services.Acquisition
*/
declare module fwkManager.Services.Acquisition {
    /**
     * Enumération correspondant aux différents types de fichiers
     *
     * @export const enum Acquisition.ROTATION_VALUES
     */
    export const enum FILE_FORMAT {
        BMP = 0,
        PNG = 1,
        GIF = 2,
        JPG_JPEG = 3,
        PDF = 4,
        TIF_TIFF = 5,
    }
    /**
     * Enumération correspondant aux différentes valeurs de rotation de document possible
     *
     * @export const enum Acquisition.ROTATION_VALUES
     */
    export const enum ROTATION_VALUES {
        ANGLE_90 = 90,
        ANGLE_180 = 180,
        ANGLE_270 = 270,
    }
    /**
    * Enumération correspondant aux différent types de document envoyés à la RADLAD
    *
    * @export const enum Acquisition.ACQUISITION_TYPE
    */
    export const enum ACQUISITION_TYPE {
        BINARY = 0,
        BASE64 = 1,
    }
    /**
     * Interface permettant de définir les informations des fichiers
     *
     * @interface Acquisition.IFileInformation
     */
    interface IFileInformation {
        url: string;
        type: ACQUISITION_TYPE;
        format?: FILE_FORMAT;
    }
    /**
    * Interface permettant de définir l'url d'une image et sa base64
    *
    * @interface Acquisition.IResultatRecuperationImageKofax
    */
    interface IBase64 {
        url: string;
        base64: string;
    }
    interface IMergeFileInformation extends IFileInformation {
        rotation?: ROTATION_VALUES;
    }
    /**
    * Enumération correspondant aux différentes methodes de binarization supportées
    *
    * @export const enum Acquisition.BINARIZE_METHOD
    */
    export const enum BINARIZE_METHOD {
        SIMPLE_THRESHOLD = 0,
        GLOBAL_THRESHOLD = 1,
        ADAPTIVE_THRESHOLD = 2,
        DYNAMIC_THRESHOLD = 3,
    }
    /**
     * Interface permettant de définir les paramètres de l'appel RADLAD
     *
     * @interface Acquisition.IRadladParams
     */
    class IRadladParams {
        activationVRS: boolean;
        activationLAD: boolean;
        save: boolean;
        binarizeMethod: BINARIZE_METHOD;
    }
    /**
     * Interface permettant de définir les paramètres de conversion d'un fichier
     *
     * @param dpi la résolution
     * @param quality la qualité de l'image normal
     * @param thumbQuality la qualité de l'image miniature
     *
     * @interface Acquisition.IConvertFileParams
     */
    class IConvertFileParams {
        dpi: number;
        quality: number;
        thumbQuality: number;
    }
    /**
    * Interface permettant de définir les paramètres de création bitonale
    *
    * @param dpibase64List la liste des images en base 64
    * @param save sauvegarde ou non de l'image
    * @param binarizeMethod méthode de binarization
    *
    * @interface Acquisition.IConvertPdfParams
    */
    class ICreerImageBitonalParams {
        save: boolean;
        binarizeMethod: BINARIZE_METHOD;
    }
    interface IPutDocumentInput {
        codeEtablissement: string;
        idntCmpstApplf: string;
        codeTypeNatrDoc: string;
        idAgntTech: string;
        agenceUtilisateur: string;
        nomFichier: string;
        docElect: string;
        dateDelivrance: Date;
        donneesRadLad: string;
        dureeAvantPurge: number;
        typeAttributaire: string;
        idntAttributaire1: string;
        idntAttributaire2: string;
        descriptionDocument: string;
        dateNumerisation: Date;
        dateCollecte: Date;
        datePeremption: Date;
        modeAcquisition: string;
        origineAcquisition: string;
        typeSignature: string;
        statutDocument: string;
        isTransitoire: boolean;
    }
}


declare module fwkManager.Services.Aide {
    interface IAideFlash {
        titre: string;
        contenu: string;
        id: number;
    }
    interface IAideResult {
        ChampsDeSaisie: ChampDeSaisieResult[];
        ModalePush: ModalePushResult;
        Totem: TotemResult[];
        InfobullesAffichees: InfobulleAfficheeResult[];
        DetailInfobulleAffichee: DetailInfobulleAfficheeResult;
    }
    class AideResult implements IAideResult {
        ChampsDeSaisie: ChampDeSaisieResult[];
        ModalePush: ModalePushResult;
        Totem: TotemResult[];
        InfobullesAffichees: InfobulleAfficheeResult[];
        DetailInfobulleAffichee: DetailInfobulleAfficheeResult;
        constructor(data: IAideResult);
    }
    class ChampDeSaisieResult {
        Id: string;
        IdChamp: string;
        MessageCommunautaire: string;
        MessageEtablissement: string;
        EstUneNouveaute: boolean;
        constructor(data: any);
    }
    class ModalePushResult {
        Message: string;
        constructor(data: any);
    }
    class TotemResult {
        Categorie: string;
        Titre: string;
        FormatDocument: string;
        Lien: string;
        EstUneNouveaute: boolean;
        constructor(data: any);
    }
    class Infobulle {
    }
    class InfobulleAfficheeResult extends Infobulle {
        private _nomChampLie;
        private _estNouveaute;
        constructor(nomChamp: any, nouveaute?: boolean);
        getNomChampLie(): string;
        getEstNouveaute(): boolean;
    }
    class DetailInfobulleAfficheeResult extends InfobulleAfficheeResult {
        private _message;
        private _image;
        constructor(nomChamp: any, nouveaute?: boolean, message?: string, img?: string);
        getNomChampLie(): string;
        getEstNouveaute(): boolean;
        getMessage(): string;
        getImage(): string;
    }
}


declare module fwkManager.Services.BriqueCommunication.Messages {
    export const enum EVENT_TYPE {
        CHAT = 1,
        NOTIFICATION = 2,
    }
    interface IBriqueCommunicationMessage<T> {
        mainEventType: EVENT_TYPE;
        event: T;
    }
}


declare module fwkManager.Services.BriqueCommunication.Chat.Messages {
    export const enum TYPE {
        OPEN_CHATROOM = 1,
        OPEN_CHAT = 2,
        SEND_MESSAGE = 3,
        CLOSE_CHAT = 4,
        GET_UTILISATEURS = 5,
        ENVOYER_MESSAGE_VIDEOROOM = 6,
        RECEPTION_MESSAGE_VIDEOROOM = 7,
        GET_CHATROOMS = 8,
        GET_CHATROOM = 16,
        PRENDRE_LA_MAIN_VIDEOROOM = 9,
        DEMARRER_VIDEO_CHATROOM = 10,
        ARRETER_VIDEO_CHATROOM = 11,
        ACCEPTER_DEMANDE_EXPERT = 12,
        INVITER_PERSONNES_A_UNE_CHATROOM = 13,
        SET_STATUT = 14,
        ADD_CHAT_CAPACITY = 15,
    }
    interface OpenChatRequest {
        destinataire: string;
    }
    interface OpenChatResponse {
        id: string;
        membres: string[];
        framePrincipale: string;
        estFramePrincipale: boolean;
        videoEstEnCours: boolean;
    }
    interface GetChatroom {
        chatroom_id: string;
    }
    interface OpenChatRoomRequest {
        idChat: string;
    }
    interface SendMessageRequest {
        idChat: string;
        message: string;
    }
    interface CloseChatRequest {
        idChat: string;
    }
    interface PrendreLaMainSurVideoroomRequest {
        idChat: string;
    }
    interface DemarrerVideoChatroomRequest {
        idChat: string;
    }
    interface ArreterVideoChatroomRequest {
        idChat: string;
    }
    interface EnvoyerMessageVideoroomRequest {
        chatroom_id: string;
        user_id: string;
        message: any;
    }
    interface AccepterDemandeExpertRequest {
        chatroom_id: string;
        domaine: string;
        prospect_id: string;
    }
    interface InviterPersonnesAUneChatroom {
        chatroom_id: string;
        users_id: string[];
    }
    interface ChangerStatut {
        statut: UTILISATEUR_STATUT;
    }
    interface IChatMessage {
        chatroom_id: string;
        user_id: string;
        message: string;
        type: string;
    }
    export const enum EVENT_TYPE {
        MESSAGE_RECU = 1,
        CHAT_FERME = 2,
        CHAT_OUVERT = 3,
        MISE_A_JOUR_LISTE_UTILISATEURS = 4,
        UTILISATEUR_CONNECTE_A_CHAT = 5,
        UTILISATEUR_DECONNECTE_A_CHAT = 6,
        CHANGEMENT_MAIN_CHATROOM = 7,
        DEMANDE_EXPERT = 8,
        FIN_DEMANDE_EXPERT = 9,
        CHAT_DIV_ELEMENT = 10,
        FIN_VIDEOROOM = 11,
    }
    interface IChatEventDetails {
        eventType: EVENT_TYPE;
    }
    interface IChatEventDetailsNouveauMessage extends IChatEventDetails {
        message: IChatMessage;
    }
    interface IChatEventDetailsChatFerme extends IChatEventDetails {
        chatroom_id: string;
    }
    interface IChatEventDetailsChatOuvert extends IChatEventDetails {
        chatroom_id: string;
        membres: string[];
        framePrincipale: string;
        estFramePrincipale: boolean;
    }
    interface IChatEventDetailsMiseAJourListeUtilisateurs extends IChatEventDetails {
        utilisateurs: IUtilisateur[];
    }
    interface IChatEventDetailsUtilisateurConnecteAChat extends IChatEventDetails {
        chatroom_id: string;
        user_id: string;
        framePrincipale: string;
        estFramePrincipale: boolean;
    }
    interface IChatEventDetailsUtilisateurDeconnecteAChat extends IChatEventDetails {
        chatroom_id: string;
        user_id: string;
    }
    interface IChatEventDetailsChangementChatroomMain extends IChatEventDetails {
        chatroom_id: string;
        framePrincipale: string;
        videoEstEnCours: boolean;
        estFramePrincipale: boolean;
    }
    interface IChatEventDetailsDemandeExpert extends IChatEventDetails {
        chatroom_id: string;
        expertise: string;
        user_id: string;
    }
    interface IChatEventDetailsFinDemandeExpert extends IChatEventDetails {
        chatroom_id: string;
        expertise: string;
        user_id: string;
    }
    interface IChatEventDetailsDemandeDivElement extends IChatEventDetails {
        chatroom_id: string;
        user_id: string;
        cestmoi: boolean;
    }
    interface IChatEventDetailsFinVideoRoom extends IChatEventDetails {
        chatroom_id: string;
        user_id: string;
    }
    interface IUtilisateur {
        nom: string;
        prenom: string;
        id: string;
        isConnected: boolean;
        type: UTILISATEUR_TYPE;
    }
    interface IUtilisateurExpert extends IUtilisateur {
        expertises: string[];
    }
    export const enum UTILISATEUR_TYPE {
        CONSEILLER = 0,
        EXPERT = 1,
        CLIENT = 2,
        PROSPECT = 3,
    }
    export const enum UTILISATEUR_STATUT {
        CONNECTE = 1,
        DECONNECTE = 2,
    }
    interface IMessageWebRTC {
        chatroom_id: string;
        user_id: string;
        content: any;
    }
}


declare module fwkManager.Services.BriqueCommunication.Notification.Messages {
    export const enum TYPE {
        ABONNEMENT = 1,
        DESABONNEMENT = 2,
        GET_LISTE_SUJETS = 3,
    }
    class INotificationMessageAbonnementRequest {
        sujet: string;
    }
    class INotificationMessageDesabonnementRequest {
        sujet: string;
    }
    class INotificationMessageListeSujetsResponse {
        sujets: ISujetDetails[];
    }
    export const enum EVENT_TYPE {
        NOUVEL_ABONNEMENT = 1,
        DESABONNEMENT = 2,
        NOTIFICATION_MESSAGE = 3,
    }
    interface INotificationEventDetails {
        eventType: EVENT_TYPE;
    }
    interface INotificationEventDetailsAbonnement extends INotificationEventDetails {
        subject: string;
    }
    interface INotificationEventDetailsDesabonnement extends INotificationEventDetails {
        subject: string;
    }
    interface INotificationEventDetailsNotification extends INotificationEventDetails {
        message: INotification;
        subject: string;
    }
    interface INotification {
        subject: string;
        messageid: string;
        title: string;
        userid: string;
        content: string;
        data?: any;
    }
    interface ISujetDetails {
        nom: string;
        estAbonne: boolean;
    }
}


/**
* Module de gestion de la cpacités (module commun aux agents et aux managers)
* @module fwkManager.Services.Capacites
*/
declare module fwkManager.Services.Capacites {
    /**
     * Liste des diférentes règles
     */
    export const enum REGLE {
        INTEROP_APPLI_BANCAIRE = 0,
        INTEROP_WINDOWS = 1,
        TABLETTE_SIGNATURE = 2,
        CAISSE_AUTO = 3,
        CONNECTE = 4,
        MODIFIER_HABILITATION = 5,
        ECRAN_COMPATIBLE_MYWAY = 6,
        RESEAU_INTERNE = 7,
        PORTAIL_MYWAY = 8,
    }
}


/**
* Module de gestion des moyens de communication (module commun aux agents et aux managers)
* @module fwkManager.Services.Communication
* @interface Mail - public - Interface permettant de décrire un objet Mail
*/
declare module fwkManager.Services.Communication {
    /**
    * Interface permettant de décrire un objet Mail
    *
    * @interface Communication.Mail
    */
    interface IMail {
        /** Le(s) destinataire(s) du mail */
        to: string;
        /** Le sujet du mail */
        subject?: string;
        /** Le corps du message du mail */
        body?: string;
        /** Le(s) destinataire(s) mis en copie du mail */
        cc?: string;
        /** Le(s) destinataire(s) mis en copie cachée du mail */
        bcc?: string;
    }
    /**
    * Interface permettant de décrire un objet Call
    *
    * @interface Communication.Call
    */
    interface ICall {
        /** Le numéro du destinataire */
        numeroDestinataire: string;
    }
    /**
     * DTO du service REST Numérotation Téléphonique
     */
    interface INumerotationTelephoniqueDTO {
    }
    /**
    * Modèle d'un mail
    */
    class Mail implements IMail {
        /** Le(s) destinataire(s) du mail */
        to: string;
        /** Le sujet du mail */
        subject: string;
        /** Le corps du message du mail */
        body: string;
        /** Le(s) destinataire(s) mis en copie du mail */
        cc: string;
        /** Le(s) destinataire(s) mis en copie cachée du mail */
        bcc: string;
        constructor(_to: string, _subject?: string, _body?: string, _cc?: string, _bcc?: string);
    }
    /**
    * Modèle d'un appel
    */
    class Call implements ICall {
        /** Le numéro du destinataire */
        numeroDestinataire: string;
        constructor(_numeroDestinataire: string);
    }
}


declare module fwkManager.Services.Context {
    export const enum ScopeType {
        View = 1,
        Root = 2,
        Service = 3,
    }
    export const enum StorageLevel {
        Global = 0,
        Process = 1,
        Step = 2,
        Shared = 3,
        Tempo = 4,
        MainProcess = 5,
    }
    export const enum PATH_PART {
        MAIN_PROCESS_ID = 0,
        LAST_PROCESS_ID = 1,
        PREVIOUS_PROCESS_ID = 2,
        STEP_ID = 3,
    }
    interface IContext {
        globalStorage: IContextKeyValuePair[];
        sharedStorage: IContextKeyValuePair[];
        portals: IPortalContext[];
        waitingProcesses: IProcess[];
    }
    interface IPortalContext {
        temporayContextStorage: IContextKeyValuePair[];
        processes: IProcess[];
        currentPath: string;
        isSingle: boolean;
        GetProcess(processId: string): fwkManager.Services.Context.IProcess;
        GetProcessByPathPart(path: string, pathPart: PATH_PART): fwkManager.Services.Context.IProcess;
        GetCurrentProcess(): IProcess;
        GetCurrentMainProcess(): IProcess;
        GetCurrentStep(process: IProcess): IProcessStep;
    }
    interface IContextKeyValuePair {
        Key: string;
        Value: string;
    }
    interface IProcessElement {
        id: string;
        contextStorage: IContextKeyValuePair[];
        type: string;
        codeEtape: string;
        getPath(): string;
        authorizedOutputs: number[];
        creationDate: number;
    }
    interface IProcess extends IProcessElement {
        icon: string;
        displayName: string;
        putInWaitTime: number;
        subElements: IProcessElement[];
        knownSteps: string[];
        codeProcess: string;
        currentInnerElementPath: string;
        typeProcess: string;
        estApplicationExterne: boolean;
        outputContracts: string[];
        isSubProcess: boolean;
        contexteClientId: string;
        lastNextTime: number;
    }
    interface IProcessStep extends IProcessElement {
        codeMetier: string;
        parentPath: string;
        codeApplication: string;
        nomApplication: string;
        url: string;
        boundId: string;
        isEnd: boolean;
        nextStep: IProcessStep;
        actions: IStepAction[];
        valeurEntree: number;
        contrats: IStepContrat[];
        processusMaitre: boolean;
        processName: string;
        maintienIFrame: boolean;
        etapeResultAsString: string;
        isRouteur: boolean;
        etatEtape: EtatEtape;
        displayTime: number;
    }
    export const enum EtatEtape {
        NONE = 0,
        STARTED = 1,
        RESET = 2,
    }
    class IStepAction {
        Nom: string;
        CodeEtape: string;
        ValeurSortie: number;
        SurchargeValeurEntree: number;
        NouvelleActivite: boolean;
        EstExterne: boolean;
        Options: string;
    }
    class IStepContrat {
        Code: string;
        Type: string;
        Longueur: number;
        Nullable: boolean;
        Mode: string;
    }
    interface IStepOption {
        ProcessusMaitre?: boolean;
        ChangeTypeProcess?: string;
        MaintienIFrame?: boolean;
        NouvelleIFrame?: boolean;
        OutputContracts?: string[];
        Mappage?: string[];
    }
    interface IProcessOption {
        Icon?: string;
        ForeColor?: string;
        BackColor?: string;
        TypeProcess?: string;
        EstApplicationExterne?: boolean;
    }
    class AnalyseResult {
        TotalWatchers: number;
        TotalWatchers2: number;
        TotalWatchers3: number;
        WatcherByScope: AnalyseScope[];
        constructor();
        ToString(): string;
    }
    class AnalyseScope {
        Name: string;
        WatcherCount: number;
        constructor(Name: string, WatcherCount: number);
    }
    interface IEventDetailsReinitialisationServiceAgent {
        idServiceAgentGenere: string;
    }
}


declare module fwkManager.Services.Context {
    interface IContextCommon {
        getAuthentificationInfo(): fwkManager.Services.IPromesse<AuthentificationInfo>;
    }
}


declare module fwkManager.Services.Context {
    class StepInfo {
        StepCode: string;
        BusinessCode: string;
        ProcessCode: string;
        ValeurEntree: number;
        Contrats: ContratInfo[];
        AuthorizedOutputs: number[];
        ProcessType: string;
        ScopeInitialise: boolean;
        constructor();
    }
    class StepInfoExtended extends StepInfo {
        CurrentStepId: string;
        CurrentProcessId: string;
        CurrentParentProcessId: string;
        NomComposant: string;
        NiveauTrace: number;
        Aide: fwkManager.Services.Aide.AideResult;
        VersionComposant: string;
        Diagnostic: boolean;
        PreviousStepEndTime: number;
        StartTime: number;
        DisplayTime: number;
        constructor();
    }
    class ContratInfo {
        /**
         * Correspond au nom de la donnée du contexte
         *
         */
        NomData: string;
        /**
        * Correspond au mode IN (entrée) ou OUT (sortie)
        *
        */
        Mode: string;
    }
    class DonneesLocales {
        AuthentificationInfo: AuthentificationInfo;
        ParametresComptables: ParametresComptables;
        ParametresNumerisation: ParametresNumerisation;
        ParametresServeurPoste: ParametresServeurPoste;
    }
    /**
     * Ensemble des données liées à l'utilisateur bancaire
     */
    class AuthentificationInfo {
        /**
         * Code Etablissement (COCXBQ)
         */
        codeEtablissement: string;
        /**
         * Correspond au nom du poste de l'utilisateur
         *
         * Transmis à travers le header X-identifiantPoste des requêtes envoyées à travers le [[CoreCommon.SendRequest]]
         */
        numeroStationTravail: string;
        /**
         * Environnement MySys (DUA, VFO, ...)
         */
        ENVIRON: string;
        /**
         * Données relatives à l'agent
         */
        agentConnecte: AgentConnecte;
        /**
         * Données relatives au guichet
         */
        guichetAgent: GuichetAgent;
        constructor();
    }
    interface ParametresComptables {
        codeGuichetInterbancaire: string;
        edsInterneGuichetComptable: string;
        /**
         * Correspond à l'identifiant de guichet opération
         *
         * Transmis à travers le header X-identifiantGuichetOperation des requêtes envoyées à travers le [[CoreCommon.SendRequest]]
         */
        edsExterneGuichetComptable: string;
        edsTypeGuichetComptable: string;
        edsInterneRattachementGuichetComptable: string;
        edsExterneRattachementGuichetComptable: string;
        edsTypeRattachementGuichetComptable: string;
        dateOperationJourneeComptable: string;
        typeCA: string;
        libelleEdsRattachementGuichetComptable: string;
        numTelEdsRattachementGuichetComptable: string;
    }
    class ParametresNumerisation {
        ModeNumr: string;
    }
    class ParametresServeurPoste {
        NomServeur: string;
    }
    class AgentConnecte {
        /**
         * Reference externe de l'agent (COCEAG)
         */
        referenceExterneAgent: string;
        /**
         * Type de fonction (CTCEAG)
         */
        typeFonction: string;
        /**
         * Numero interne EDS (NOCEEL)
         */
        numeroInterneEds: string;
        /**
         * Type d'EDS (CTCEEL)
         */
        typeEds: string;
        /**
         * Numero EDS Superieur (NOCEEL)
         */
        numeroEdsSuperieur: string;
        /**
         * Type EDS de rattachement (CECEFS)
         */
        typeEdsRattachement: string;
        /**
         * Reference externe de l'EDS de rattachement (COCEEL)
         */
        referenceExterneEdsRattachemen: string;
        /**
         * ?? (LICEE1)
         */
        LICEE1: string;
        /**
         * Numero externe Eds (COCEEL)
         */
        numeroExterneEds: string;
        /**
         * Libelle EDS (LICELI)
         */
        libelleEds: string;
        /**
         * Désignation longue Agent (LICEAG)
         */
        designationLongueAgent: string;
        /**
         * Libelle du type d'EDS (LICEEL)
         */
        libelleTypeEds: string;
        /**
         * Designation du poste fonctionnel (LNCEAG)
         */
        designationPosteFonctionnel: string;
        /**
         * Code civilité (LIDAVC)
         */
        codeCivilite: string;
        /**
         * Nom de l'agent (LIDANP)
         */
        nomFamillePersonnePhysique: string;
        /**
         * Prenom de l'agent (LIDAPP)
         */
        prenom: string;
        nomUsagePersonnePhysique: string;
        /**
         * Adresse mail (LBCEAM)
         */
        adresseMessagerie: string;
        identifiantInterneSite: string;
        /**
         * Ligne d'adresse 2 (LIDGV1)
         */
        ligne2Adresse: string;
        /**
         * Ligne d'adresse 3 (LIDGV3)
         */
        ligne3Adresse: string;
        /**
         * Ligne d'adresse 4 (LIDGV4)
         */
        ligne4Adresse: string;
        /**
         * Ligne d'adresse 5 (LIDGV5)
         */
        ligne5Adresse: string;
        /**
         * Ligne d'adresse 6 (LIDGV6)
         */
        ligne6Adresse: string;
        /**
         * ?? (NODATP)
         */
        NODATP: string;
        /**
         * Code pays (??)
         */
        codeInseePays: string;
        /**
         * Debut de validité (DDCEDS)
         */
        dateDebutValidite: string;
        /**
         * Fin de validité (DFCEDS)
         */
        dateFinValidite: string;
        /**
         * Qualité agent (CTCEQU)
         */
        codeQualiteAgent: string;
        /**
         * Indicateur de fin de structure (code)
         */
        codeIndicateurFinStructure: string;
        /**
         * Debut de validité reférentiel (?)
         */
        dateDebutValiditeReferentiel: string;
        constructor();
    }
    class GuichetAgent {
        /**
         * Code Guichet (??)
         */
        codeGuichetInterbancaire: string;
        /**
         * Numero EDS (??)
         */
        numeroEdsGuichet: string;
        /**
         * Reference externe EDS (??)
         */
        referenceExterneEdsGuichet: string;
        /**
         * Type EDS (??)
         */
        typeEdsGuichet: string;
        /**
         * ?? (DAGXOP)
         */
        DAGXOP: string;
    }
    class InfosUserPoste {
        IdentifiantUser: string;
        DomaineADUser: string;
        CodeEtabPoste: string;
        CodeEnvPoste: string;
    }
}


/**
 * Contexte client
 *
 * <uml>
 *
 * title Agents du contexte client
 *
 * class ContextClientAgent {
 *   +getContextesParClients(): string[]
 *   +getId(): string
 *   +getIdClient(): string
 *   +setIdClient(): void
 *   +getProperty(pCle: string, pValeur: any): IPromesse<string>
 *   +addToList(pCle: string, pValeur: any): IPromesse<boolean>
 *   +setProperty(pCle: string): IPromesse<boolean>
 *   +removeFromList(pCle: string): IPromesse<boolean>
 *   +deleteProperty(pCle: string): IPromesse<boolean>
 * }
 *
 * class ContexteClientTechAgent  {
 *   +getContextes(): IPromesse<string[]>
 *   +detruireContexte(pIdContexteClient: string): IPromesse<boolean>
 *   +nouveauContexte(pIdClient?: string): IPromesse<string>
 *   +changerContexteDuProcessus(pIdContexteClient: string, pCodeProcessus: string): IPromesse<void>
 *   +changerModeContexteClient(pIdContexteClient: string, pMode: Messages.ContexteClientMode): IPromesse<void>
 *   +getDetailsContexte(pIdContexte: string): IPromesse<Messages.ITechActionGetDetailsContextResponse>
 *   +setClientOfContexteSpecifique(pIdContexte: string, pClient: string): IPromesse<void>
 *   +getPropertyOfContexteSpecifique(pIdContexte: string, pCle: string): IPromesse<any>
 *   +addToListOfContexteSpecifique(pIdContexte: string, pCle: string, pValeur: any): IPromesse<boolean>
 *   +setPropertyOfContexteSpecifique(pIdContexte: string, pCle: string, pValeur: any): IPromesse<boolean>
 *   +removeFromListOfContexteSpecifique(pIdContexte: string, pCle: string): IPromesse<boolean>
 *   +deletePropertyOfContexteSpecifique(pIdContexte: string, pCle: string): IPromesse<boolean>
 * }
 *
 * ContextClientAgent <|-- ContexteClientTechAgent
 *
 * note "Classe disponible uniquement avec le framework TECH" as NoteContexteClientTechAgent
 *
 * NoteContexteClientTechAgent .. ContexteClientTechAgent
 *
 * </uml>
 */
declare module fwkManager.Services.ContexteClient {
}


declare module fwkManager.Services.ContexteClient.Messages {
    export const enum TYPE {
        GET_CONTEXTES_PAR_CLIENTS,
        GET_ID,
        GET_CLIENT,
        SET_CLIENT,
        GET_PROPERTY,
        ADD_TO_LIST,
        SET_PROPERTY,
        REMOVE_FROM_LIST,
        DELETE_PROPERTY,
        GET_CONTENU,
        SET_CONTENU,
        GET_CONTEXTES,
        DESTROY_CONTEXT,
        NEW_CONTEXT,
        CHANGE_CONTEXT_PROCESS,
        CHANGE_CONTEXT_MODE,
        DETAILS_CONTEXT,
    }
    interface IActionSetClientRequest {
        idContexteClient?: string;
        client: string;
        expediteur: string;
    }
    interface IActionGetRequest {
        idContexteClient?: string;
        cle: string;
    }
    interface IActionGetContenuRequest {
        idClient: string;
    }
    interface IActionAddRequest {
        idContexteClient?: string;
        cle: string;
        valeur: any;
        expediteur: string;
    }
    interface IActionSetRequest {
        idContexteClient?: string;
        cle: string;
        valeur: any;
        expediteur: string;
    }
    interface IActionSetContenuRequest {
        idClient: string;
        valeur: any;
        expediteur: string;
    }
    interface IActionRemoveRequest {
        idContexteClient?: string;
        cle: string;
        expediteur: string;
    }
    interface IActionDeleteRequest {
        idContexteClient?: string;
        cle: string;
        expediteur: string;
    }
    interface IActionGetContextesParClientsResponse {
        ids: string[];
    }
    interface IActionGetIdResponse {
        id: string;
    }
    interface IActionGetClientResponse {
        id: string;
    }
    interface IActionGetResponse {
        valeur: string;
    }
    interface IActionAddResponse {
        estOk: boolean;
    }
    interface IActionSetResponse {
        estOk: boolean;
    }
    interface IActionRemoveResponse {
        estOk: boolean;
    }
    interface IActionDeleteResponse {
        estOk: boolean;
    }
    export const enum ContexteClientMode {
        AUTOMATIQUE,
        MANUEL,
    }
    interface IMiseAJourContexteClient {
        contexteClientId: string;
        type: MiseAJourContexteClientType;
        cleModifie?: string;
        details?: any;
    }
    export type MiseAJourContexteClientType = "addToList" | "removeFromList" | "deleteProperty" | "setProperty" | "setClient" | "nouveauContexte" | "detructionContexte" | "changementContexte";
}


declare module fwkManager.Services.ContexteClient.Messages {
    interface ITechActionGetContextesResponse {
        idContextes: string[];
    }
    interface ITechActionDestroyContexteRequest {
        idContexte: string;
        expediteur: string;
    }
    interface ITechActionDestroyContexteResponse {
        isDestroy: boolean;
    }
    interface ITechActionNewContextRequest {
        idClient?: string;
        expediteur: string;
    }
    interface ITechActionNewContextResponse {
        idContexte: string;
    }
    interface ITechActionChangeContextProcessRequest {
        idContexte: string;
        codeProcessus: string;
        expediteur: string;
    }
    interface ITechActionChangeContextModeRequest {
        idContexte: string;
        mode: ContexteClientMode;
    }
    interface ITechActionGetDetailsContextRequest {
        idContexte: string;
    }
    interface ITechActionGetDetailsContextResponse {
        idClient: string;
        idContexte: string;
        mode: ContexteClientMode;
        processus: string[];
        content: {
            [key: string]: any;
        };
    }
}


declare module fwkManager.Services.Context {
    interface IContextAgent extends IContextCommon {
        VersionComposant: string;
        AddToContext(key: string, value: string): IPromesse<any>;
        AddToMainProcessContext(key: string, value: string): IPromesse<any>;
        AddListToContext(kvp: fwkManager.Services.Context.IContextKeyValuePair[]): IPromesse<any>;
        GetFromContext(key: string): IPromesse<string>;
        GetObjectFromContext<T>(keyArray: string[]): IPromesse<any>;
        GetTypedObjectFromContext<T>(template: T): IPromesse<T>;
        GetListFromContext(keyArray: string[]): IPromesse<fwkManager.Services.Context.IContextKeyValuePair[]>;
        GetAuthentificationInfo(): IPromesse<AuthentificationInfo>;
        GetParametresComptables(): IPromesse<ParametresComptables>;
        Redirect(url?: string, previousUrl?: string): IPromesse<any>;
        GetWaitingProcesses(): IPromesse<fwkManager.Services.Context.IProcess[]>;
        PutProcessInPortalContext(processId: string): IPromesse<any>;
        PutTaskInPortalContext(taskId: string): IPromesse<any>;
        GetCurrentProcessId(): IPromesse<string>;
        GetCurrentStepId(): IPromesse<string>;
        reinitialisationServiceAgent(pIdGenere: string): IPromesse<void>;
        GetCurrentStepInfo(): IPromesse<Context.StepInfoExtended>;
        SetMyWayCompatible(): IPromesse<boolean>;
        SubscribeToNotification(onNotification: {
            (notification: NotificationMessage, agent?: IServiceAgent): void;
        }[], serviceAgent: IServiceAgent): IPromesse<any>;
        AnalyseApp(): AnalyseResult;
        ChangeMainProcessName(name: string): IPromesse<any>;
        AddToSharedContext(key: string, value: string): IPromesse<any>;
        RemoveFromSharedContext(key: string): IPromesse<any>;
        StepInfo: StepInfoExtended;
        ErreurCallback: ErreurCallback;
        AnalyseApp(): AnalyseResult;
        SetContextListener(key: string, callback: () => void): any;
        sendNotification(notification: NotificationMessage, event?: MessageEvent, sendResponseCallback?: Message.ResponseCallback): void;
        retirerListenerNotification(onNotification: (notification: NotificationMessage, agent?: IServiceAgent) => void): void;
    }
}

declare module fwkManager.Services.Controle {
    /**
    * Classe statique de contrôle du type any (classe utilisée depuis les managers)
    * @classe StaticAnyControle
    * fonction : isNotUndefinedAndNotNull – public - Permet de contrôler que le paramètre en entrée n'est ni null ni undefined
    */
    class StaticAnyControle {
        /**
        * Contrôle que le paramètre en entrée n'est ni undefined ni null
        * @param value {any} valeur à contrôler
        */
        static isNotUndefinedAndNotNull(value: any): boolean;
    }
    /**
    * Classe de contrôle du type any (classe utilisée depuis les agents)
    * @classe AnyControle
    * fonction : isNotUndefinedAndNotNull – public - Permet de contrôler que le paramètre en entrée n'est ni null ni undefined
    */
    class AnyControle {
        /**
        * Contrôle que le paramètre en entrée n'est ni undefined ni null
        * @param value {any} valeur à contrôler
        */
        isNotUndefinedAndNotNull(value: any): boolean;
    }
}

declare module fwkManager.Services.Controle {
    /**
    * Classe statique de contrôle des tableaux (classe utilisée depuis les managers)
    * @classe StaticArrayControle
    * fonction : isArray – public - Contrôle que le paramètre en entrée est un tableau,
    */
    class StaticArrayControle {
        /**
        * Contrôle que le paramètre en entrée est un tableau
        * @param value {any} valeur à contrôler
        */
        static isArray(value: any): boolean;
    }
    /**
    * Classe statique de contrôle des tableaux (classe utilisée depuis les agents)
    * @classe ArrayControle
    * fonction : isArray – public - Contrôle que le paramètre en entrée est un tableau
    */
    class ArrayControle {
        /**
        * Contrôle que le paramètre en entrée est un tableau
        * @param value {any} valeur à contrôler
        */
        isArray(value: any): boolean;
    }
}

declare module fwkManager.Services.Controle {
    /**
    * Classe statique de contrôle du type any (classe utilisée depuis les managers)
    * @classe StaticDateControle
    * fonction : isDate – public - Contrôle que le paramètre en entrée est une date
    */
    class StaticDateControle {
        /**
        * Contrôle que le paramètre en entrée est une date
        * @param value {any} valeur à contrôler
        */
        static isDate(value: any): boolean;
    }
    /**
    * Classe de contrôle du type any (classe utilisée depuis les agents)
    * @classe DateControle
    * fonction : isDate – public - Contrôle que le paramètre en entrée est une date
    */
    class DateControle {
        /**
        * Contrôle que le paramètre en entrée est une date
        * @param value {any} valeur à contrôler
        */
        isDate(value: any): boolean;
    }
}


declare module fwkManager.Services.Controle {
    /**
    * Classe statique de contrôle des export const enum (classe utilisée depuis les managers)
    * @classe StaticEnumControle
    * fonction : isAnEnumValueOrNullOrUndefined - public - Contrôle que la valeur est bien une valeur de l'export const enum ou null ou undefined
    * fonction : isAnEnumValue – public - Contrôle que la valeur est bien une valeur de l'export const enum
    * fonction : isAnEnumMember – public - Contrôle que le membre est bien un membre de l'export const enum
    */
    class StaticEnumControle {
        /**
        * Contrôle que la valeur est bien une valeur de l'export const enum ou null ou undefined
        * @param value {any} valeur à contrôler
        * @param enumObject {any} l'export const enum
        */
        static isAnEnumValueOrNullOrUndefined(value: any, enumObject: any): boolean;
        /**
        * Contrôle que la valeur est bien une valeur de l'export const enum
        * @param value {any} valeur à contrôler
        * @param enumObject {any} l'export const enum
        */
        static isAnEnumValue(value: any, enumClass: any): boolean;
        /**
        * Contrôle que le membre est bien un membre de l'export const enum
        * @param member {any} membre à contrôler
        * @param enumObject {any} l'export const enum
        */
        static isAnEnumMember(member: any, enumClass: any): boolean;
    }
    /**
    * Classe de contrôle des export const enum (classe utilisée depuis les agents)
    * @classe EnumControle
    * fonction : isAnEnumValueOrNullOrUndefined - public - Contrôle que la valeur est bien une valeur de l'export const enum ou null ou undefined
    * fonction : isAnEnumValue – public - Contrôle que la valeur est bien une valeur de l'export const enum
    * fonction : isAnEnumMember – public - Contrôle que le membre est bien un membre de l'export const enum
    */
    class EnumControle {
        /**
        * Contrôle que la valeur est bien une valeur de l'export const enum ou null ou undefined
        * @param value {any} valeur à contrôler
        * @param enumObject {any} l'export const enum
        */
        isAnEnumValueOrNullOrUndefined(value: any, enumObject: any): boolean;
        /**
        * Contrôle que la valeur est bien une valeur de l'export const enum
        * @param value {any} valeur à contrôler
        * @param enumObject {any} l'export const enum
        */
        isAnEnumValue(value: any, enumObject: any): boolean;
        /**
        * Contrôle que le membre est bien un membre de l'export const enum
        * @param member {any} membre à contrôler
        * @param enumObject {any} l'export const enum
        */
        isAnEnumMember(member: any, enumObject: any): boolean;
    }
}

declare module fwkManager.Services.Controle {
    /**
    * Classe statique de contrôle des fonctions (classe utilisée depuis les managers)
    * @classe StaticFunctionControle
    * fonction : isFunction – public - Contrôle que le paramètre en entrée est une fonction
    * fonction : isFunctionOrNull – public - Contrôle que le paramètre en entrée est une fonction ou null
    */
    class StaticFunctionControle {
        /**
        * Contrôle que le paramètre en entrée est une fonction
        * @param value {any} valeur à contrôler
        */
        static isFunction(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une fonction ou null
        * @param value {any} valeur à contrôler
        */
        static isFunctionOrNull(value: any): boolean;
    }
    /**
    * Classe de contrôle des fonctions (classe utilisée depuis les agents)
    * @classe FunctionControle
    * fonction : isFunction – public - Contrôle que le paramètre en entrée est une fonction
    * fonction : isFunctionOrNull – public - Contrôle que le paramètre en entrée est une fonction ou null
    */
    class FunctionControle {
        /**
        * Contrôle que le paramètre en entrée est une fonction
        * @param value {any} valeur à contrôler
        */
        isFunction(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une fonction ou null
        * @param value {any} valeur à contrôler
        */
        isFunctionOrNull(value: any): boolean;
    }
}

declare module fwkManager.Services.Controle {
    /**
    * Classe statique de contrôle des nombres (classe utilisée depuis les managers)
    * @classe StaticNumberControle
    * fonction : isNumber – public - Contrôle que le paramètre en entrée est un nombre
    * fonction : isInt – public - Contrôle que le paramètre en entrée est un nombre entier
    */
    class StaticNumberControle {
        /**
        * Contrôle que le paramètre en entrée est un nombre
        * @param value {any} valeur à contrôler
        */
        static isNumber(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un nombre entier
        * @param value {any} valeur à contrôler
        */
        static isInt(value: any): boolean;
    }
    /**
    * Classe de contrôle des nombres (classe utilisée depuis les managers)
    * @classe NumberControle
    * fonction : isNumber – public - Contrôle que le paramètre en entrée est un nombre
    * fonction : isInt – public - Contrôle que le paramètre en entrée est un nombre entier
    */
    class NumberControle {
        /**
        * Contrôle que le paramètre en entrée est un nombre
        * @param value {any} valeur à contrôler
        */
        isNumber(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un nombre entier
        * @param value {any} valeur à contrôler
        */
        isInt(value: any): boolean;
    }
}

declare module fwkManager.Services.Controle {
    /**
    * Classe statique permettant d'appliquer un contrôle sur les objets (classe utilisée depuis les managers)
    * @classe StaticObjectControle
    * fonction : isObject – public - Contrôle que le paramètre en entrée est un objet de type Object
    * fonction : isObjectOrNull – public - Contrôle que le paramètre en entrée est un objet ou null
    * fonction : isObjectOrNullOrUndefined – public - Contrôle que le paramètre en entrée est un objet ou null ou undefined
    * fonction : isObjectSpecified – public - Contrôle que le paramètre en entrée est un objet correspondant au type spécifié
    */
    class StaticObjectControle {
        /**
        * Contrôle que le paramètre en entrée est un objet de type Object
        * @param value {any} valeur à contrôler
        */
        static isObject(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un objet ou null
        * @param value {any} valeur à contrôler
        */
        static isObjectOrNull(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un objet ou null ou undefined
        * @param value {any} valeur à contrôler
        */
        static isObjectOrNullOrUndefined(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un objet correspondant au type spécifié
        * @param value {any} valeur à contrôler
        * @param objectType {string} type auquel doit correspondre la valeur
        */
        static isObjectSpecified(value: any, objectType: string): boolean;
    }
    /**
    * Classe permettant d'appliquer un contrôle sur les objets (classe utilisée depuis les agents)
    * @classe ObjectControle
    * fonction : isObject – public - Contrôle que le paramètre en entrée est un objet de type Object
    * fonction : isObjectOrNull – public - Contrôle que le paramètre en entrée est un objet ou null
    * fonction : isObjectOrNullOrUndefined – public - Contrôle que le paramètre en entrée est un objet ou null ou undefined
    * fonction : isObjectSpecified – public - Contrôle que le paramètre en entrée est un objet correspondant au type spécifié
    */
    class ObjectControle {
        /**
        * Contrôle que le paramètre en entrée est un objet de type Object
        * @param value {any} valeur à contrôler
        */
        isObject(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un objet ou null
        * @param value {any} valeur à contrôler
        */
        isObjectOrNull(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un objet ou null ou undefined
        * @param value {any} valeur à contrôler
        */
        isObjectOrNullOrUndefined(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est un objet correspondant au type spécifié
        * @param value {any} valeur à contrôler
        * @param objectType {string} type auquel doit correspondre la valeur
        */
        isObjectSpecified(value: any, objectType: string): boolean;
    }
}

declare module fwkManager.Services.Controle {
    /**
    * Classe statique de contrôle des chaines de caractères (classe utilisée depuis les managers)
    * @classe StaticStringControle
    * fonction : isString – public - Contrôle que le paramètre en entrée est une chaine de caractères
    * fonction : isStringOrNull – public - Contrôle que le paramètre en entrée est une chaine de caractères ou null
    * fonction : isStringOrNullOrUndefined – public - Contrôle que le paramètre en entrée est une chaine de caractères ou null ou undefined
    * fonction : isStringNotEmpty – public - Contrôle que le paramètre en entrée est une chaine de caractères non vide
    * fonction : isStringNotEmptyOrNull – public - Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null
    * fonction : isStringNotEmptyOrNullOrUndefined – public - Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null ou undefined
    * fonction : isStringNotEmptyOrNullOrUndefined – public - Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null ou undefined
    * fonction : isType - public - Contrôle que le paramètre [value] en entrée est correspond bien au [type] passé en paramètre
    */
    class StaticStringControle {
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères
        * @param value {any} valeur à contrôler
        */
        static isString(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères ou null
        * @param value {any} valeur à contrôler
        */
        static isStringOrNull(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères ou null ou undefined
        * @param value {any} valeur à contrôler
        */
        static isStringOrNullOrUndefined(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères non vide
        * @param value {any} valeur à contrôler
        */
        static isStringNotEmpty(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null
        * @param value {any} valeur à contrôler
        */
        static isStringNotEmptyOrNull(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null ou undefined
        * @param value {any} valeur à contrôler
        */
        static isStringNotEmptyOrNullOrUndefined(value: any): boolean;
        /**
        * Contrôle que le paramètre [value] en entrée est correspond bien au [type] passé en paramètre
        * @param value {string} valeur à contrôler
        * @param value {export const enum} type attendu
        */
        static isType(value: string, type: TYPE_STRING): boolean;
    }
    /**
    * Classe de contrôle des chaines de caractères (classe utilisée depuis les agents)
    * @classe StringControle
    * fonction : isString – public - Contrôle que le paramètre en entrée est une chaine de caractères
    * fonction : isStringOrNull – public - Contrôle que le paramètre en entrée est une chaine de caractères ou null
    * fonction : isStringOrNullOrUndefined – public - Contrôle que le paramètre en entrée est une chaine de caractères ou null ou undefined
    * fonction : isStringNotEmpty – public - Contrôle que le paramètre en entrée est une chaine de caractères non vide
    * fonction : isStringNotEmptyOrNull – public - Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null
    * fonction : isStringNotEmptyOrNullOrUndefined – public - Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null ou undefined
    */
    class StringControle {
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères
        * @param value {any} valeur à contrôler
        */
        isString(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères ou null
        * @param value {any} valeur à contrôler
        */
        isStringOrNull(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères ou null ou undefined
        * @param value {any} valeur à contrôler
        */
        isStringOrNullOrUndefined(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères non vide
        * @param value {any} valeur à contrôler
        */
        isStringNotEmpty(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null
        * @param value {any} valeur à contrôler
        */
        isStringNotEmptyOrNull(value: any): boolean;
        /**
        * Contrôle que le paramètre en entrée est une chaine de caractères non vide ou null ou undefined
        * @param value {any} valeur à contrôler
        */
        isStringNotEmptyOrNullOrUndefined(value: any): boolean;
        /**
        * Contrôle que le paramètre [value] en entrée est correspond bien au [type] passé en paramètre
        * @param value {string} valeur à contrôler
        * @param value {export const enum} type attendu
        */
        isType(value: string, type: TYPE_STRING): boolean;
    }
    /**
    * Enumération correspondant aux différents types de string testables
    * @export const enum Controle.CONTROLES
    */
    export const enum TYPE_STRING {
        ADRESSE_IP = 0,
    }
}

declare module fwkManager.Services.Controle {
    /**
    * Classe statique de contrôle des booléens (classe utilisée depuis les managers)
    * @classe StaticBooleanControle
    * fonction : isBoolean – public - Contrôle que le paramètre en entrée est un booléen
    */
    class StaticBooleanControle {
        /**
        * Contrôle que le paramètre en entrée est un booléen
        * @param value {any} valeur à contrôler
        */
        static isBoolean(value: any): boolean;
    }
    /**
    * Classe de contrôle des booléens (classe utilisée depuis les agents)
    * @classe BooleanControle
    * fonction : isBoolean – public - Contrôle que le paramètre en entrée est un booléen
    */
    class BooleanControle {
        /**
        * Contrôle que le paramètre en entrée est un booléen
        * @param value {any} valeur à contrôler
        */
        isBoolean(value: any): boolean;
    }
}

declare module fwkManager.Services.Controle {
    /**
    * Classe statique de contrôle de parametres (classe utilisée depuis les managers)
    * @classe StaticParametresControle
    * fonction : checkParameters – public - Permet de contrôler un ensemble de paramétres
    */
    class StaticParametresControle {
        /**
        * Permet de contrôler un ensemble de paramétres
        * Retourne une chaine de caractères correspondant à la description de l'ensemble des erreurs rencontrées (séparées par '/')
        * Si tous les contrôles sont OK, la chaine retournée est vide
        * @param parametres {parametre[]} Tableau de parametres à contrôler
        */
        static checkParameters(parametres: Parametre[]): string;
    }
    /**
    * Interface permettant de définir un paramétre à contrôler
    * @interface Controle.Parametre
    */
    interface Parametre {
        name: string;
        value: any;
        controle: CONTROLES;
        enumObject?: any;
        enumName?: any;
        objectType?: string;
    }
    /**
    * Enumération correspondant aux différents contrôles applicables sur une valeur
    * @export const enum Controle.CONTROLES
    */
    export const enum CONTROLES {
        isNotUndefinedAndNotNull = 0,
        isArray = 100,
        isBoolean = 200,
        isDate = 300,
        isAnEnumValue = 400,
        isAnEnumMember = 401,
        isAnEnumValueOrNullOrUndefined = 402,
        isFunction = 500,
        isFunctionOrNull = 501,
        isNumber = 600,
        isInt = 601,
        isObject = 700,
        isObjectOrNull = 701,
        isObjectOrNullOrUndefined = 702,
        isObjectSpecified = 703,
        isString = 800,
        isStringOrNull = 801,
        isStringOrNullOrUndefined = 802,
        isStringNotEmpty = 803,
        isStringNotEmptyOrNull = 804,
        isStringNotEmptyOrNullOrUndefined = 805,
    }
}


declare module fwkManager.Services.BaseDeDonnees.messages {
    var NOM_BIBLIOTHEQUE: string;
    export const enum TYPE {
        GET_BASES,
        DB_UPGRADE,
        GET,
        GETALL,
        FIND,
        COUNT,
        AJOUTER,
        SUPPRIMER,
        METTRE_A_JOUR,
        RESET_ALL,
    }
    export const enum DB_UPGRADE_TYPE {
        TABLE_CREER,
        TABLE_SUPPRIMER,
        INDEX_CREER,
        INDEX_SUPPRIMER,
    }
    interface BASE {
        nom: string;
        implementation: CAPACITE;
        type: TYPE_BASE;
        version: number;
    }
    interface BASE_DETAIL extends BASE {
        tables: TABLE[];
    }
    interface TABLE {
        nom: string;
        primaryKey: CLE_ABSTRACT;
        indexes: INDEX[];
    }
    interface CLE_ABSTRACT {
        estAutoIncrement: boolean;
    }
    interface CLE_AUTOINCREMENT extends CLE_ABSTRACT {
    }
    interface CLE_PATH extends CLE_ABSTRACT {
        valeurs: string[];
    }
    export const enum CAPACITE {
        VOLATILE = 1,
        MONO_ENREGISTREMENT = 2,
        MULTI_ENREGISTREMENT = 3,
    }
    export const enum TYPE_BASE {
        LOCALSTORAGE,
        MEMORY,
    }
    interface DB_UPGRADE {
        base: BASE;
        actions: DB_UPGRADE_ACTION[];
        fixVersion: number;
    }
    interface DB_UPGRADE_ACTION {
        type: DB_UPGRADE_TYPE;
    }
    interface TABLE_CREER extends DB_UPGRADE_ACTION {
        nom: string;
        typeCle: CLE_TYPE;
        path: string[];
        indexes: INDEX[];
    }
    interface TABLE_SUPPRIMER extends DB_UPGRADE_ACTION {
        nom: string;
    }
    interface INDEX_CREER extends DB_UPGRADE_ACTION {
        table: string;
        index: INDEX;
    }
    interface INDEX_SUPPRIMER extends DB_UPGRADE_ACTION {
        table: string;
        nom: string;
    }
    interface GET {
        base: BASE;
        table: string;
        cle: any;
    }
    interface GETALL {
        base: BASE;
        table: string;
    }
    interface FIND {
        base: BASE;
        table: string;
        criteres: CRITERES_RECHERCHE;
    }
    interface COUNT {
        base: BASE;
        table: string;
        criteres?: CRITERES_RECHERCHE;
    }
    interface AJOUTER {
        base: BASE;
        table: string;
        element: any;
    }
    interface SUPPRIMER {
        base: BASE;
        table: string;
        cle: any;
    }
    interface METTRE_A_JOUR {
        base: BASE;
        table: string;
        cle: any;
        element: any;
    }
    export const enum CLE_TYPE {
        AUTOINCREMENT,
        PATH,
    }
    interface INDEX {
        nom: string;
        estUnique: boolean;
        valeurs: string[];
    }
    interface CRITERES_RECHERCHE {
        critereType: CRITERE_TYPE;
        index: string;
        direction: CRITERE_DIRECTION;
    }
    interface CRITERES_RECHERCHE_SIMPLE extends CRITERES_RECHERCHE {
        valeurIndex: any[];
        inclureValeurReference: boolean;
    }
    interface CRITERES_RECHERCHE_BORNES extends CRITERES_RECHERCHE {
        minValeurIndex: any[];
        maxValeurIndex: any[];
        minInclureValeurReference: boolean;
        maxInclureValeurReference: boolean;
    }
    interface IDBEntry<Key, Value> {
        cle: Key;
        valeur: Value;
        rowid: number;
    }
    export const enum CRITERE_TYPE {
        EGAL,
        INFERIEUR,
        SUPERIEUR,
        BORNES,
    }
    export const enum CRITERE_DIRECTION {
        PRECEDENT,
        PRECEDENT_UNIQUE,
        SUIVANT,
        SUIVANT_UNIQUE,
    }
}


declare module fwkManager.Services.Dates {
    export const enum FORMATS_DATE {
        aaaammjj = 10,
    }
    class DatesCommon extends Component.ComponentCommonBase {
        private static CLASS_NAME;
        private static logger;
        constructor(library: Component.IComponentLibrary);
        getDateDuJour(format: FORMATS_DATE): string;
        private isBissextile();
        private getNbJoursMois(annee, mois);
        CompareDates(date1: Date, date2: Date, Periode: string): number;
        addDate(d: Date, jours: number, mois?: number, annees?: number): Date;
    }
}


declare module fwkManager.Services.Donnees {
    class DonneesCommon extends Component.ComponentCommonBase {
        constructor(library: Component.IComponentLibrary);
        Enum: EnumExtension;
        Array: ArrayExtension;
        Object: ObjectExtension;
        String: StringExtension;
    }
}


/**
* Module qui fournit des méthodes utilitaires sur les export const enum
* @module fwkManager.Donnees
* classe : StaticEnumExtension - public - Classe statique qui fournit des méthodes utilitaires sur les export const enum (classe utilisée depuis les managers)
* classe : EnumExtension - public - Classe qui fournit des méthodes utilitaires sur les export const enum (classe utilisée depuis les agents)
*/
declare module fwkManager.Services.Donnees {
    /**
    * Classe statique qui fournit des méthodes utilitaires sur les export const enum (classe utilisée depuis les managers)
    * @classe StaticEnumExtension
    * fonction : getNames – public - Permet de récupérer tous les membres d'un export const enum sous la forme d'un tableau de chaines de caractères
    * fonction : getName – public - Permet de récupérer un membre d'un export const enum correspondant à la valeur passée en paramètre
    * fonction : getValues – public - Permet de récupérer toutes les valeurs d'un export const enum sous la forme d'un tableau de nombres
    * fonction : getValue – public - Permet de récupérer une valeur d'un export const enum correspondant au membre passé en paramètre
    * fonction : getValuesAndNames - public - Permet de récupérer toutes les valeurs et tous les membres d'un export const enum sous la forme d'un tableau de valeur, membre
    */
    class StaticEnumExtension {
        /**
        * Permet de récupérer tous les membres d'un export const enum sous la forme d'un tableau de chaines de caractères
        * @param e {any} export const enum pour lequel on veut récupérer les différents membres
        * @return {Array<string>} Retourne les membres de l'export const enum
        */
        static getNames(e: any): Array<string>;
        /**
        * Permet de récupérer un membre d'un export const enum correspondant à la valeur passée en paramètre
        * @param e {any} export const enum pour lequel on veut récupérer le membre
        * @param value {number} valeur pour laquelle on veut récupérer le membre de l'export const enum
        * @return {string} Retourne le membre de l'export const enum correspondant à la valeur passée en paramètre
        */
        static getName(e: any, value: number): string;
        /**
        * Permet de récupérer toutes les valeurs d'un export const enum sous la forme d'un tableau de nombres
        * @param e {any} export const enum pour lequel on veut récupérer les différentes valeurs
        * @return {Array<number>} Retourne les valeurs de l'export const enum
        */
        static getValues(e: any): Array<number>;
        /**
        * Permet de récupérer une valeur d'un export const enum correspondant au membre passé en paramètre
        * @param e {any} export const enum pour lequel on veut récupérer la valeur
        * @param name {string} membre pour lequel on veut récupérer la valeur
        * @return {number} Retourne la valeur de l'export const enum correspondant au membre passé en paramètre
        */
        static getValue(e: any, name: string): number;
        /**
        * Permet de récupérer toutes les valeurs et tous les membres d'un export const enum sous la forme d'un tableau d'objets contenant les membres et les valeurs de l'export const enum
        * @param e {any} export const enum pour lequel on veut récupérer les différents membres et les différentes valeurs
        * @return {number} Retourne toutes les valeurs et tous les membres de l'export const enum
        */
        static getValuesAndNames(e: any): any[];
    }
    /**
    * Classe qui fournit des méthodes utilitaires sur les export const enum (classe utilisée depuis les agents)
    * @classe EnumExtension
    * fonction : getNames – public - Permet de récupérer tous les membres d'un export const enum sous la forme d'un tableau de chaines de caractères
    * fonction : getName – public - Permet de récupérer un membre d'un export const enum correspondant à la valeur passée en paramètre
    * fonction : getValues – public - Permet de récupérer toutes les valeurs d'un export const enum sous la forme d'un tableau de nombres
    * fonction : getValue – public - Permet de récupérer une valeur d'un export const enum correspondant au membre passé en paramètre
    * fonction : getValuesAndNames - public - Permet de récupérer toutes les valeurs et tous les membres d'un export const enum sous la forme d'un tableau de valeur, membre
    */
    class EnumExtension {
        /**
        * Permet de récupérer tous les membres d'un export const enum sous la forme d'un tableau de chaines de caractères
        * @param e {any} export const enum pour lequel on veut récupérer les différents membres
        * @return {Array<string>} Retourne les membres de l'export const enum
        */
        getNames(e: any): Array<string>;
        /**
        * Permet de récupérer un membre d'un export const enum correspondant à la valeur passée en paramètre
        * @param e {any} export const enum pour lequel on veut récupérer le membre
        * @param value {number} valeur pour laquelle on veut récupérer le membre de l'export const enum
        * @return {string} Retourne le membre de l'export const enum correspondant à la valeur passée en paramètre
        */
        getName(e: any, value: number): string;
        /**
        * Permet de récupérer toutes les valeurs d'un export const enum sous la forme d'un tableau de nombres
        * @param e {any} export const enum pour lequel on veut récupérer les différentes valeurs
        * @return {Array<number>} Retourne les valeurs de l'export const enum
        */
        getValues(e: any): Array<number>;
        /**
        * Permet de récupérer une valeur d'un export const enum correspondant au membre passé en paramètre
        * @param e {any} export const enum pour lequel on veut récupérer la valeur
        * @param name {string} membre pour lequel on veut récupérer la valeur
        * @return {number} Retourne la valeur de l'export const enum correspondant au membre passé en paramètre
        */
        getValue(e: any, name: string): number;
        /**
        * Permet de récupérer toutes les valeurs et tous les membres d'un export const enum sous la forme d'un tableau d'objets contenant les membres et les valeurs de l'export const enum.
        * @param e {any} export const enum pour lequel on veut récupérer les différents membres et les différentes valeurs
        * @return {number} Retourne toutes les valeurs et tous les membres de l'export const enum
        */
        getValuesAndNames(e: any): any[];
    }
}


/**
* Module qui fournit des méthodes utilitaires sur les tableaux
* @module fwkManager.Donnees.ArrayExtension
* classe : StaticArrayExtension - public - Classe statique qui fournit des méthodes utilitaires sur les tableaux (classe utilisée depuis les managers)
* classe : ArrayExtension - public - Classe qui fournit des méthodes utilitaires sur les tableaux (classe utilisée depuis les agents)
*/
declare module fwkManager.Services.Donnees {
    /**
    * Classe statique qui fournit des méthodes utilitaires sur les tableaux (classe utilisée depuis les managers)
    * @classe StaticArrayExtension
    * fonction : filtrer – public - Permet de filtrer les éléments dans un tableau en fonction des critères définis
    */
    class StaticArrayExtension {
        /**
        * Permet de filtrer les éléments dans un tableau en fonction des critères définis
        * @param collection {Array<any>} tableau contenant les données à filtrer
        * @param predicat {function} Action de filtre à appliquer sur chaque donnée contenue dans le tableau (la donnée courante est transmise en paramètre: data)
        *                            Doit retourner true si la donnée répond aux critères, false si la données ne répond pas aux critères et null en cas d'erreur
        * @return {Array<any>} Retourne les éléments du tableau qui correspondent au filtre (null en cas d'erreur)
        */
        static filtrer(collection: Array<any>, predicat: (data: any) => boolean): Array<any>;
    }
    /**
    * Classe qui fournit des méthodes utilitaires sur les tableaux (classe utilisée depuis les agents)
    * @classe ArrayExtension
    * fonction : filtrer – public - Permet de filtrer les éléments dans un tableau en fonction des critères définis
    */
    class ArrayExtension {
        /**
        * Permet de filtrer les éléments dans un tableau en fonction des critères définis
        * @param collection {Array<any>} tableau contenant les données à filtrer
        * @param predicat {function} action de filtre à appliquer sur chaque donnée contenue dans le tableau (la donnée courante est transmise en paramètre: data)
        * @return {Array<any>} Retourne les éléments du tableau qui correspondent au filtre
        */
        filtrer(collection: Array<any>, predicat: (data: any) => boolean): Array<any>;
    }
}


/**
* Module qui fournit des méthodes utilitaires sur les objets
* @module fwkManager.Donnees.ObjectExtension
* classe : StaticObjectExtension - public - Classe statique qui fournit des méthodes utilitaires sur les objets (classe utilisée depuis les managers)
* classe : ObjectExtension - public - Classe qui fournit des méthodes utilitaires sur les objets (classe utilisée depuis les agents)
*/
declare module fwkManager.Services.Donnees {
    /**
    * Classe statique qui fournit des méthodes utilitaires sur les objets (classe utilisée depuis les managers)
    * @classe StaticObjectExtension
    * fonction : getTaille – public - Retourne la taille d'un objet
    */
    class StaticObjectExtension {
        /**
        * Retourne la taille d'un objet
        * @param objet {any} objet dont on veut calculer la taille
        * @return {number} Retourne la taille de l'objet
        */
        static getTaille(objet: any): number;
    }
    /**
    * Classe qui fournit des méthodes utilitaires sur les objets (classe utilisée depuis les agents)
    * @classe ObjectExtension
    * fonction : getTaille – public - Retourne la taille d'un objet
    */
    class ObjectExtension {
        /**
        * Retourne la taille d'un objet
        * @param objet {any} objet dont on veut calculer la taille
        * @return {number} Retourne la taille de l'objet
        */
        getTaille(objet: any): number;
    }
}


/**
* Module qui fournit des méthodes utilitaires sur les chaines de caractères
* @module fwkManager.Donnees.StringExtension
* classe : StaticStringExtension - public - Classe statique qui fournit des méthodes utilitaires sur les string (classe utilisée depuis les managers)
* classe : StringExtension - public - Classe qui fournit des méthodes utilitaires sur les string (classe utilisée depuis les agents)
*/
declare module fwkManager.Services.Donnees {
    /**
    * Classe statique qui fournit des méthodes utilitaires sur les string (classe utilisée depuis les managers)
    * @classe StaticStringExtension
    * fonction : getEmptyStringIfNotStringOrGetItSelf – public - Retourne une chaine de caractères vide si le paramètre en entrée n'est pas une chaine de caractère. Retourne le paramètre en entrée sinon.
    */
    class StaticStringExtension {
        /**
        * Retourne une chaine de caractères vide si le paramètre en entrée n'est pas une chaine de caractère. Retourne le paramètre en entrée sinon.
        * @param valueToTest {any} valeur à tester/modifer
        * @return {number} Retourne une chaine de caractères vide si le paramètre en entrée n'est pas une chaine de caractère. Retourne le paramètre en entrée sinon
        */
        static getEmptyStringIfNotStringOrGetItSelf(valueToTest: any): string;
    }
    /**
    * Classe qui fournit des méthodes utilitaires sur les objets (classe utilisée depuis les agents)
    * @classe ObjectExtension
    * fonction : getTaille – public - Retourne la taille d'un objet
    */
    class StringExtension {
        /**
        * Retourne une chaine de caractères vide si le paramètre en entrée n'est pas une chaine de caractère. Retourne le paramètre en entrée sinon.
        * @param valueToTest {any} valeur à tester/modifer
        * @return {number} Retourne une chaine de caractères vide si le paramètre en entrée n'est pas une chaine de caractère. Retourne le paramètre en entrée sinon
        */
        getEmptyStringIfNotStringOrGetItSelf(valueToTest: any): string;
    }
}


/**
* Module de gestion des données délocalisées (module commun aux agents et aux managers)
* @module fwkManager.Services.DonneesDelocalisees
* export const enum : CRITERES_OPERATEUR - public - Enumération correspondant aux différents opérateurs applicables sur un critère
* interface : ObjectDataCritere - public - Description d'un critère de recherche pour un objet de données
*/
declare module fwkManager.Services.DonneesDelocalisees {
    /**
    * Enumération correspondant aux différents opérateurs applicables sur un critère
    * @export const enum DonneesDelocalisees.CRITERES_OPERATEUR
    */
    export const enum CRITERES_OPERATEUR {
        EGAL = 0,
        CONTIENT = 1,
    }
    /**
    * Interface permettant de définir un critère de recherche pour un objet de données
    * @interface DonneesDelocalisees.ObjectDataCritere
    */
    interface ObjectDataCritere {
        /** Propriété pour laquelle un critère doit être appliqué. */
        propriete: string;
        /** Valeur à tester pour le critere donné. */
        valeur: string;
        /** Opérateur à appliquer pour la recherche. */
        operateur: CRITERES_OPERATEUR;
    }
}


declare module fwkManager.Services.DonneesDelocalisees {
    interface IDonneesDelocaliseesAgent {
        getDonneesDelocalisees(numEtablissement: string, objectDataName: string): IPromesse<any>;
        getListeDonneesDelocalisees(numEtablissement: string, objectDataNames: string[]): IPromesse<any[]>;
        getRubriqueLibelle(numEtablissement: string, objectDataName: string, code: string): IPromesse<string>;
        getDonneesParCriteres(numEtablissement: string, objectDataName: string, criteres: Array<ObjectDataCritere>): IPromesse<any>;
    }
}


/**
* Module de gestion des exports (module commun aux agents et aux managers)
* @module fwkManager.Services.Export
*/
declare module fwkManager.Services.Export {
    /**
    * Enumération permettant de définir le format du fichier à exporter
    * @export const enum Export.FORMAT_FICHIER
    */
    export const enum FORMAT_FICHIER {
        CSV,
    }
    /**
    * Enumération permettant la localisation du fichier à exporter
    * Permet de formater les données suivant la localisation du logiciel.
    * @export const enum Export.LOCALISATION
    */
    export const enum LOCALISATION {
        EN = 0,
        FR = 1,
    }
    /**
    * Description des options pour l'export dans un fichier
    * @interface Export.IOptionsExportFichier
    */
    interface IOptionsExportFichier {
        nomFichier?: string;
        localisation?: LOCALISATION;
    }
    interface ICellule {
        cellule: string | number;
    }
    interface ILigne {
        ligne: Array<ICellule>;
    }
    interface IDonneesAExporter {
        entetes: string[];
        contenu: Array<ILigne>;
    }
}


declare module fwkManager.Services.Fichier {
    /**
    * Enumération correspondant aux différents types de fichier
    * Les valeurs inférieures à 100 sont réservées aux types de fichier autorisés pour la génération de document (API Impression)
    * @export const enum Fichier.TYPE_FICHIER
    */
    export const enum TYPE_FICHIER {
        PDF = 0,
        PDF_EMBED = 5,
        PDFA_1A = 10,
        PDFA_1B = 15,
        PDFX_1_2001 = 20,
        PDFX_1A_2001 = 25,
        PDFX_1A_2003 = 30,
        PDFX_3_2002 = 35,
        PDFX_3_2003 = 40,
        JSON = 105,
        TAR_GZ = 110,
        WORDML = 100,
    }
    /**
    * Enumération correspondant aux différents types de données à sauvegarder
    * @export const enum Fichier.TYPE_DONNEES_A_SAUVER
    */
    export const enum TYPE_DONNEES_A_SAUVER {
        BLOB = 0,
        BASE64 = 1,
    }
}


/**
* Module de gestion technique des habilitations
*
* @module fwkManager.Services.Habilitation
*/
declare module fwkManager.Services.Habilitation {
    export const enum DOMAIN {
        MYSYS,
        IAM,
        CULTURENET,
    }
    /**
     * Modèle d'une habilitation
     */
    class HabilitationModel {
        [code: string]: boolean;
        constructor(_code: string, _valeur: boolean);
    }
    const enum EHabilitationType {
        MYSYS = 0,
        IAM = 1,
        CULTURENET = 2,
    }
    /**
     * DTO du service REST habilitation
     */
    interface IHabilitationsDTO {
        mysys: string[];
        iam: string[];
        cultureNet: string[];
        erreurs: fwkManager.Services.Erreur;
        timestamp: any;
    }
    /**
     * DTO du service REST habilitation
     */
    interface IHabilitationsContextDTO {
        codesHabilites: any[];
        codesNonHabilites: any[];
        timestamp: number;
    }
}


declare module fwkManager.Services.Habilitation {
    interface IHabilitationAgent {
        /**
         * Permet de récupérer une habilitation pour un utilisateur.
         *
         * Cette méthode ne prend qu'un seul code habilitation en paramètre.
         *
         * ~~~ts
         *
         * // Récupération de l'habilitation 'SHOP24' pour l'utilisateur authentifié
         * serviceAget.Habilitation.EstHabilite('SHOP24').then((result: boolean) => {
         * ...
         * }).catch((rreur: fwkManager.Services.Erreur) => {
         * ...
         * });
         * ~~~
         *
         * @param  {string}             codeHabilitation
         *
         * Code de la fonction, du processus,... exemple : SHOP24
         *
         * @return {IPromesse<boolean>}
         *
         * Promesse indiquant si oui(true) ou non(false) l'utilisateur est habilité au code habilitation passé en paramètre
         *
         */
        EstHabilite(codeHabilitation: string): IPromesse<boolean>;
        /**
         * Permet de récupérer plusieurs habilitations pour un utilisateur (Méthode à privilégier pour la récupération de plusieurs codes dans un même traitement)
         *
         * ~~~ts
         *
         * // Récupération des habilitations 'SHOP24', 'SHOMW1', 'SHOMW2' pour l'utilisateur authentifié
         * serviceAgent.Habilitation.EstHabilite(['SHOP24','SHOMW1','SHOMW2']).then((result: boolean []) => {
         * ...
         * }).catch((erreur: fwkManager.Services.Erreur) => {
         * ...
         * });
         * ~~~
         *
         * @param  {string[]}             codesHabilitation
         *
         * Codes des fonctions, des processus,... exemple : [‘SHOP24’,’SHOMW1’]
         *
         * @return {IPromesse<boolean[]>}
         *
         * Promesse indiquant si oui(true) ou non(false) l'utilisateur est habilité à chaque code habilitation passé en paramètre
         *
         */
        EstHabilite(codesHabilitation: string[]): IPromesse<boolean[]>;
    }
}


declare module fwkManager.Services.Communication {
    interface ICommunicationAgent {
        /**
        * Permet d'envoyer un mail
        *
        * @param mail Mail
        *
        */
        envoyerMail(mail: Mail): IPromesse<string>;
        /**
        * Permet de déclencher un appel
        *
        * @param {Call} call    Données de l'appel
        *
        */
        declencherAppel(call: Call): IPromesse<string>;
        /**
        * Permet de raccrocher un appel
        *
        */
        raccrocherAppel(): IPromesse<string>;
    }
}


/**
* Module de gestion des impressions (module commun aux agents et aux managers)
* @module fwkManager.Services.Impression
* @export const enum RESTITUTION_VERSION - public - Enumération correspondant aux différentes versions du serveur de restitution
* @export const enum GENERATION_ACTION - public - Enumération correspondant aux différentes actions du service de génération
* @export const enum GENERATION_IMPRESSION_ACTION - public - Enumération correspondant aux différentes actions du service de génération et d'impression
* @export const enum TYPE_IMAGE - public - Enumération correspondant aux différentes types de données images possibles dans le flux de données d'impression
* @interface DocumentGenere - public - Interface permettant de décrire un objet document généré
* @interface DocumentImpressionLot - public - Interface permettant de définir les paramètres de documents pour l'impression par lot
* @interface GenerationParams - public - Interface permettant de définir les paramètres de génération d'un document
* @interface ParametresGenerationSysteme - public - Interface permettant de définir les paramètres système pour la génération d'un document
* @interface ParametresGenerationObligatoires - public - Interface permettant de définir les paramètres obligatoires pour la génération d'un document
* @interface ParametresGenerationFichier - public - Interface permettant de définir les paramètres nécessaires à la génération d'un fichier d'impression
* @interface ParametresGenerationOptionnels - public - Interface permettant de définir les paramètres optionnels pour la génération d'un document
* @interface MentionsLegales - public - Interface permettant de définir les mentions légales
* @interface Archivage - public - Interface permettant d’archiver lors de la génération du fichier
* @interface GceContextSoapHeader - public - Interface contenant les  informations d'entête du contexte SOAP
* @interface AQstnCreerDoc - public - Interface contenant les questions pour la création de document
* @interface DonnCntx - public - Interface contenant les données contextuelles
* @interface Document - public - Interface permettant de créer un document
* @interface ProprietesDoc - public - Interface contenant les métadonnées du document à créer
* @interface FichierDoc - public - Interface contenant les propriétés propres à la pièce-jointe du document à créer
* @interface BlocGenerique - public - Interface
* @interface ImpressionParams - public - Interface permettant de définir les paramètres d'impression d'un document
* @interface ParametresImpressionObligatoires - public - Interface permettant de définir les paramètres obligatoires pour l'impression d'un document
* @interface ParametresImpressionOptionnels - public - Interface permettant de définir les paramètres optionnels pour l'impression d'un document
* @interface GenerationImpressionParams - public - Interface permettant de définir les paramètres de génération et d'impression d'un document
* @interface ParametresGenerationImpressionObligatoires - public - Interface permettant de définir les paramètres obligatoires pour la génération et l'impression d'un document
* @interface ParametresGenerationImpressionOptionnels - public - Interface permettant de définir les paramètres optionnels pour la génération et l'impression d'un document
* @interface ParametreActiveX - public - Interface permettant de définir les paramètres de l'ActiveX d'impression pour une impression simple
* @interface ParametresActiveXIndividuels - public - Interface permettant de définir les paramètres individuels de l'ActiveX d'impression pour une impression par lot
* @interface ParametresActiveXGlobaux - public - Interface permettant de définir les paramètres globaux de l'ActiveX d'impression pour une impression par lot
*/
declare module fwkManager.Services.Impression {
    /**
    * Enumération correspondant aux différentes versions du serveur de restitution
    * @export const enum Impression.RESTITUTION_VERSION
    */
    export const enum RESTITUTION_VERSION {
        /** Version 180 du serveur de restitution */
        V180 = 180,
    }
    /**
    * Enumération correspondant aux différentes actions de génération possibles
    * @export const enum Impression.GENERATION_ACTION
    */
    export const enum GENERATION_ACTION {
        /** Permet d'archiver le document généré en GED */
        archiver = 10,
        /** Permet d'archiver en GED et d'obtenir le fichier généré */
        archiverAndGetFichier = 20,
        /** Permet d'obtenir le fichier généré */
        getFichier = 30,
    }
    /**
    * Enumération correspondant aux différentes actions de génération et d'impression possibles
    * @export const enum Impression.GENERATION_IMPRESSION_ACTION
    */
    export const enum GENERATION_IMPRESSION_ACTION {
        /** Permet d'archiver en GED et d'obtenir le fichier généré et imprimé */
        archiverAndGetFichier = 20,
        /** Permet d'obtenir le fichier généré et imprimé */
        getFichier = 30,
    }
    /**
    * Enumération correspondant aux différentes types de données images possibles dans le flux de données d'impression
    * @export const enum Impression.TYPE_IMAGE
    */
    export const enum TYPE_IMAGE {
        /** Nom de l'image */
        Id = 0,
        /** Image en Base 64 */
        Flux = 1,
    }
    /**
    * Interface permettant de décrire un objet document généré
    * @interface Impression.DocumentGenere
    */
    interface DocumentGenere {
        /**
        * L'identifiant d'archivage en GED sous forme de chaine de caractères<br />
        * <i>null</i> si l'archivage n’a pas été demandé
        */
        IdntPJ: any;
        /**
        * Le fichier généré sous forme de chaine de caractères (BASE64)<br />
        * <i>null</i> si aucun retour de fichier n’a été demandé
        */
        Fichier: any;
        /**
        * Date de la création du document généré<br />
        * NE PAS UTILISER, VA ETRE SUPPRIME
        */
        DateCrtn: string;
    }
    /**
    * Interface permettant de définir les paramètres de documents pour l'impression par lot
    * @interface Impression.DocumentImpressionLot
    */
    interface DocumentImpressionLot {
        /** Le numéro d'identification de l'élément */
        numeroOrdre: number;
        /**
        * Le fichier au format PDF (Base 64)<br />
        * Peut-être <i>null</i> si idGed est renseigné
        */
        fichier?: any;
        /**
        * L'identifiant GED du document<br />
        * Peut-être <i>null</i> si fichier est renseigné
        */
        idGed?: any;
        /**
        * Nom du composant applicatif<br />
        * Si non renseigné, 'CONTELEC' est utilisé
        */
        composantApplicatif?: string;
        /**
        * Permet de définir le code Banque sous lequel l'établissement est répertorié par la Banque de France<br />
        * Si non renseigné, récupéré du contexte
        */
        codeEtablissement?: string;
        /** Permet de définir les paramètres d'impression d'un document */
        impressionParams: ImpressionParams;
    }
    /**
    * Interface permettant de définir les paramètres de génération d'un document
    * @interface Impression.GenerationParams
    */
    interface GenerationParams {
        /** Permet de définir les paramètres système pour la génération d'un document */
        systeme: ParametresGenerationSysteme;
        /** Permet de définir les paramètres obligatoires pour la génération d'un document */
        obligatoires: ParametresGenerationObligatoires;
        /** Permet de définir les paramètres optionnels pour la génération d'un document */
        optionnels: ParametresGenerationOptionnels;
    }
    /**
    * Interface permettant de définir les paramètres système pour la génération d'un document
    * @interface Impression.ParametresGenerationSysteme
    */
    interface ParametresGenerationSysteme {
        /** Permet de définir le nom de la classe d'impression */
        typeName: string;
        /** Permet de définir le nom complet de la classe d'impression */
        typeFullName: string;
        /** Permet de définir la librairie d'impression */
        librairie: string;
    }
    /**
    * Interface permettant de définir les paramètres obligatoires pour la génération d'un document
    * @interface Impression.ParametresGenerationObligatoires
    */
    interface ParametresGenerationObligatoires {
        /**
        * Permet de définir l'action à réaliser lors de la génération<br />
        * Si ces actions impliquent l’obtention d’un fichier généré alors le paramètre optionnel <i>nomFichier</i> doit être renseigné
        */
        action: GENERATION_ACTION;
        /** Permet de définir les paramètres nécessaires à la génération d'un fichier d'impression */
        parametresGenerationFichier: ParametresGenerationFichier;
    }
    /**
    * Interface permettant de définir les paramètres nécessaires à la génération d'un fichier d'impression
    * @interface Impression.ParametresGenerationFichier
    */
    interface ParametresGenerationFichier {
        /** Permet de définir les différents types de fichier */
        typeFichier: fwkManager.Services.Fichier.TYPE_FICHIER;
        /** Permet de définir les différentes versions du serveur de restitution */
        restitutionVersion: RESTITUTION_VERSION;
        /**
        * Permet de définir le chemin relatif du sous répertoire contenant le modèle à utiliser<br />
        * Valoriser à "" pour utiliser le répertoire racine
        */
        sousRepModele: string;
    }
    /**
    * Interface permettant de définir les paramètres optionnels pour la génération d'un document
    * @interface Impression.ParametresGenerationOptionnels
    */
    interface ParametresGenerationOptionnels {
        /**
        * Permet de définir les paramètres nécessaires à la génération du fichier d’impression<br />
        * Si non défini, c’est le flux XML avant génération qui est archivé
        */
        nomFichier?: string;
        /**
        * Permet de définir les paramètres nécessaires à l’alimentation automatique des mentions légales : la data correspondant au nom passé en paramètre sera automatiquement alimentée<br />
        * Si non défini, les mentions légales ne seront pas automatiquement injectées lors de la génération du flux XML
        */
        mentionsLegales?: MentionsLegales;
        /**
        * Permet de définir les paramètres nécessaires à l'archivage en GED d'un document généré<br />
        * Ne pas oublier de mettre <i>action</i> de <i>ParametresGenerationObligatoires</i> à <i>GENERATION_ACTION.archiver</i> ou <i>GENERATION_ACTION.archiverAndGetFichier</i>
        */
        archivage?: Archivage;
        /**  */
        blocGenerique?: BlocGenerique;
    }
    /**
    * Interface permettant de définir les mentions légales
    * @interface Impression.MentionsLegales
    */
    interface MentionsLegales {
        /**  */
        numEtablissement: string;
    }
    /**
    * Interface permettant d’archiver lors de la génération du fichier.
    * @interface Impression.Archivage
    */
    interface Archivage {
        /** Permet de définir les paramètres contenant les informations d'entête du contexte SOAP */
        gceContextSoapHeader?: GceContextSoapHeader;
        /** Permet de définir les paramètres contenant les questions pour la création d'un document */
        aQstnCreerDoc: AQstnCreerDoc;
    }
    /**
    * Interface contenant les informations d'entête du contexte SOAP
    * @interface Impression.GceContextSoapHeader
    */
    interface GceContextSoapHeader {
        /**  */
        codePrflAgnt?: string;
        /**  */
        codeTypeIdntExtn?: string;
        /**  */
        extendedProperties?: string;
        /**  */
        idntAgnt?: string;
        /**  */
        idntAgntAcces?: string;
        /**  */
        idntAgntTech?: string;
        /**  */
        idntEtabEntt?: string;
        /**  */
        idntExtnConx?: string;
        /**  */
        idntInteEdsAgnt?: string;
        /**  */
        refrExtnAgnt?: string;
        /**  */
        refrPosteFoncAgnt?: string;
        /**  */
        typeCanlAcces?: string;
        /**  */
        typePrflAgnt?: string;
    }
    /**
    * Interface contenant les questions pour la création de document
    * @interface Impression.AQstnCreerDoc
    */
    interface AQstnCreerDoc {
        /** Permet de définir les paramètres contenant les données contextuelles du document à archiver */
        donnCntx: DonnCntx;
        /** Permet de définir les paramètres du document à archiver */
        document: Document;
    }
    /**
    * Interface contenant les données contextuelles
    * @interface Impression.DonnCntx
    */
    interface DonnCntx {
        /**
        * Permet de définir le code Banque sous lequel l'établissement est répertorié par la Banque de France<br />
        * Si pas renseigné, récupérer dans le contexte
        */
        codeEtablissement?: string;
        /** Identifiant de l'application à l'origine de la demande */
        idntCmpstApplf: string;
    }
    /**
    * Interface permettant de créer un document
    * @interface Impression.Document
    */
    interface Document {
        /** Permet de définir les paramètres contenant les métadonnées du document à archiver */
        proprietesDoc: ProprietesDoc;
        /** Permet de définir les paramètres contenant les propriétés propres à la pièce jointe du document à archiver */
        fichierDoc: FichierDoc;
    }
    /**
    * Interface contenant les métadonnées du document à créer
    * @interface Impression.ProprietesDoc
    */
    interface ProprietesDoc {
        /** Permet de définir l'identifiant du lot */
        idntLot?: string;
        /**
        * Permet de définir le mode d'acquisition du document. Prend les valeurs :
        * <ol>
        *     <li>Signature Agence</li>
        *     <li>Signature à distance </li>
        *     <li>RAD-LAD CE</li>
        *     <li>Numérisation CE </li>
        *     <li>Reprise de masse </li>
        *     <li>Flux de masse </li>
        *     <li>Numérisation externe</li>
        *     <li>Injection Temps Réel</li>
        * </ol>
        * Valoriser à 8 si ActionDocument = 4<br />
        * Ce paramètre devient obligatoire si l'archivage se fait en GED définitive (codeTypeStck = "A")
        */
        codeTypeModeAcqs?: string;
        /**
        * Permet de définir le moyen d'acquisition du document. Prend les valeurs:
        * <ol>
        *     <li>Fax</li>
        *     <li>E-mail</li>
        *     <li>Editique </li>
        *     <li>Numérique</li>
        *     <li>Papier</li>
        * </ol>
        * Valoriser à 3 si ActionDocument = 4<br />
        * Ce paramètre devient obligatoire si l'archivage se fait en GED définitive
        */
        codeTypeOrigAcqs?: string;
        /** Permet de définir la nature du document */
        codeTypeNatrDoc: string;
        /**
        * Permet de définir le type d'attributaire :
        * <ol>
        *    <li>Attributaire type contrat</li>
        *    <li>Attributaire type personne particulier</li>
        *    <li>Attributaire type personne Professionnel</li>
        *    <li>Attributaire type personne Morale </li>
        *    <li>Attributaire type relation économique </li>
        *    <li>Attributaire type demande de financement</li>
        *    <li>Attributaire type entité titulaire</li>
        *    <li>Attributaire type Sinistre assurance</li>
        *    <li>Attributaire type dossier temporaire VMC</li>
        *    <li>Attributaire type prospect BDR</li>
        *    <li>Attributaire type bénéficiaire assurance vie</li>
        *    <li>Dossier de fraude interne</li>
        *    <li>Document d'entreprise</li>
        * </ol>
        */
        codeTypeAttrb: string;
        /**
        * Si Type attributaire égal à :
        * <ol>
        *    <li>Identifiant du contrat souscrit</li>
        *    <li>Identifiant de la personne</li>
        *    <li>Identifiant de la personne</li>
        *    <li>Identifiant de la personne</li>
        *    <li>Identifiant de la relation Economique</li>
        *    <li>Identifiant de la demande de financement</li>
        *    <li>Identifiant de l'entité titulaire</li>
        *    <li>Identifiant d'un sinistre Assurance</li>
        *    <li>Identifiant d'un dossier temporaire</li>
        *    <li>Identifiant Prospect BDR</li>
        *    <li>Attributaire bénéficiaire assurance vie</li>
        *    <li>Dossier de fraude interne</li>
        *    <li>Document d'entreprise</li>
        * </ol>
        */
        idntAttrb: string;
        /**
        * Permet de définir l'identifiant secondaire de l'attributaire<br />
        * Il n'est renseigné que pour certains types d'attributaire<br />
        * Pour le code type=3 (Professionnel), contient le numéro chrono professionnel… */
        idntAttrSecn?: string;
        /**
        * Permet de définir, pour un document issu d'une numérisation, la "date de délivrance" située sur la pièce numérisée<br />
        * Sinon, défini la date de création du fichier (généré ou saisie) */
        dateDeliv: Date;
        /** Permet de définir, dans le cas d'un document issu d'une numérisation, la date à laquelle le document a été numérisé */
        dateNumr: Date;
        /** Permet de définir, dans le cas d'un document issu d'une numérisation, la date à laquelle le chargé d'affaire à pris possession du document origine */
        dateColt?: Date;
        /**
        * Permet de définir la date à laquelle le document pourra être purgé<br />
        * Si non renseignée, document non purgé
        */
        datePerm?: Date;
        /** Permet de définir la date d'élimination du document (date de purge) */
        dateFinVald?: Date;
        /** Permet de définir le numéro de l'archive physique */
        numUnitePhysique?: string;
        /** Permet de définir la position dans l'archive physique */
        posUnitePhysique?: number;
        /**
        * Exemples:
        * <ul style="list-style-type: none;">
        *    <li>Pour "particulier" correspond à DESIGNATION PARTICULIER</li>
        *    <li>Pour "Professionnel" correspond à NOM COMMERCIAL</li>
        *    <li>Pour "personne morale" correspond à RAISON SOCIALE</li>
        *    <li>Pour "Contrat" correspond à INTITULE ENTITE TITULAIRE</li>
        *    <li>Pour "Relation Economique" correspond à INTITULE RELATION ECONOMIQUE</li>
        *    <li>Pour "Demande de Financement" correspond OBJET DE LA DEMANDE DE FINANCEMENT</li>
        * </ul>
        */
        inttAttr: string;
        /**
        * Permet de définir la date qualifiant l'attributaire<br />
        * Exemples :
        * <ul style="list-style-type: none;">
        *    <li>Si code type attributaire = 2 (particulier) correspond à la date de naissance</li>
        *    <li>Si code attributaire = 4 (personne morale) date création entreprise</li>
        *    <li>etc.</li>
        * </ul>
        */
        dateAttr?: Date;
        /** Permet de définir le numéro d'identification du poste fonctionnel au sein d'un Etablissement */
        refrPosteFoncAcqs?: string;
        /** Permet de définir la description sommaire du document */
        descDoc?: string;
        /**
        * Permet de définir la zone de stockage où sera créé le document, à savoir :
        * <ul style="list-style-type: none;">
        *    <li>A : archivage (par défaut si rubrique non renseignée)</li>
        *    <li>T : transitoire</li>
        *    <li>L : temporaire</li>
        * </ul>
        */
        codeTypeStck?: string;
        /**
        * Code permettant le forçage du code accessibilité associé à la nature du document<br />
        * <b>!!! NON GERE ACTUELLEMENT !!!!</b>
        */
        codeForcAccs?: string;
        /**
        * Permet de définir le mode de signature. Prend les valeurs :
        * <ol start="0">
        *    <li>Non signé </li>
        *    <li>Signature papier </li>
        *    <li>Signature électronique</li>
        * </ol>
        * interface Ce paramètre devient obligatoire si l'archivage se fait en GED définitive
        */
        codeTypeSign?: string;
    }
    /**
    * Interface contenant les propriétés propres à la pièce-jointe du document à créer
    * @interface Impression.FichierDoc
    */
    interface FichierDoc {
        /** Nom du document qui sera stocké dans la GED définitive (avec l'extension) */
        nomFich: string;
    }
    /**
    * Interface
    * @interface Impression.BlocGenerique
    */
    interface BlocGenerique {
        /**  */
        idBloc?: string;
        /**  */
        dateBloc: Date;
    }
    /**
    * Interface permettant de définir les paramètres d'impression d'un document
    * @interface Impression.ImpressionParams
    */
    interface ImpressionParams {
        /** Permet de définir les paramètres obligatoires pour l'impression d'un document */
        obligatoires: ParametresImpressionObligatoires;
        /** Permet de définir les paramètres optionnels pour l'impression d'un document */
        optionnels: ParametresImpressionOptionnels;
    }
    /**
    * Interface permettant de définir les paramètres obligatoires pour l'impression d'un document
    * @interface Impression.ParametresImpressionObligatoires
    */
    interface ParametresImpressionObligatoires {
        /** Permet de définir le nom du fichier imprimé */
        nomFichier: string;
    }
    /**
    * Interface permettant de définir les paramètres optionnels pour l'impression d'un document
    * @interface Impression.ParametresImpressionOptionnels
    */
    interface ParametresImpressionOptionnels {
        /** @DEPRECATED Permet de définir les paramètres de l'ActiveX d'impression */
        parametreActiveX?: ParametreActiveX;
        /** Permet de définir les paramètres individuels de l'ActiveX d'impression */
        parametresActiveXIndividuels?: ParametresActiveXIndividuels;
    }
    /**
    * Interface permettant de définir les paramètres de génération et d'impression d'un document
    * @interface Impression.GenerationImpressionParams
    */
    interface GenerationImpressionParams {
        /** Permet de définir les paramètres système pour la génération et l'impression d'un document */
        systeme: ParametresGenerationSysteme;
        /** Permet de définir les paramètres obligatoires pour la génération et l’impression d'un document */
        obligatoires: ParametresGenerationImpressionObligatoires;
        /** Permet de définir les paramètres optionnels pour la génération et l’impression d'un document */
        optionnels: ParametresGenerationImpressionOptionnels;
    }
    /**
    * Interface permettant de définir les paramètres obligatoires pour la génération et l'impression d'un document
    * @interface Impression.ParametresGenerationImpressionObligatoires
    */
    interface ParametresGenerationImpressionObligatoires {
        /** Permet de définir les actions à réaliser lors de la génération et de l’impression */
        action: GENERATION_IMPRESSION_ACTION;
        /** Permet de définir le nom du fichier téléchargé par le navigateur si l’impression n’est pas possible (ex : exécution du service sur une tablette) */
        nomFichier: string;
        /** Permet de définir les paramètres nécessaires à la génération du fichier d’impression */
        parametresGenerationFichier: ParametresGenerationFichier;
    }
    /**
    * Interface permettant de définir les paramètres optionnels pour la génération et l'impression d'un document
    * @interface Impression.ParametresGenerationImpressionOptionnels
    */
    interface ParametresGenerationImpressionOptionnels {
        /**
        * Permet de définir le paramètre nécessaire à l'archivage en GED d'un document généré et imprimé<br />
        * Ne pas oublier de mettre <i>action</i> de <i>ParametresGenerationImpressionObligatoires</i> à <i>GENERATION_IMPRESSION_ACTION.archiverAndGetFichier</i>
        */
        archivage?: Archivage;
        /** @DEPRECATED Permet de définir les paramètres de l'ActiveX d'impression */
        parametreActiveX?: ParametreActiveX;
        /** Permet de définir les paramètres individuels de l'ActiveX d'impression  */
        parametresActiveXIndividuels?: ParametresActiveXIndividuels;
        /** @DEPRECATED Permet de définir si la génération se fait en local */
        local?: boolean;
    }
    /**
    * Interface permettant de définir les paramètres de l'ActiveX d'impression pour une impression simple<br />
    * @interface Impression.ParametreActiveX
    */
    interface ParametreActiveX {
        /**
        * Permet d'afficher ou non le bouton icône <i>Aperçu</i> dans l'ActiveX d'impression<br />
        * Si non défini, le bouton ne sera pas affiché
        */
        voir?: boolean;
        /**
        * Permet d'afficher ou non le bouton icône <i>Enregistrer</i> dans l'ActiveX d'impression<br />
        * Si non défini, le bouton ne sera pas affiché
        */
        enregistrer?: boolean;
        /**
        * Permet de bloquer et donc d’imposer le nombre de copies à imprimer pour un document <br />
        * La valeur par défaut est false
        */
        blocnbex?: boolean;
        /**
        * Permet de définir le nombre de copies par défaut du document à imprimer<br />
        * Si non défini, le nombre de copies est 1
        */
        nbcopiesdef?: number;
        /**
        * Permet de définir le nombre minimum de copies pour le document à imprimer<br />
        * Si non défini, le nombre de copies minimum est 0
        */
        mincop?: number;
        /**
        * Permet de définir le nombre maximum de copies pour le document à imprimer<br />
        * La valeur par défaut est 0
        */
        maxcop?: number;
        /**
        * Permet d'afficher ou non le bouton <i>Annuler</i> dans l'ActiveX d'impression<br />
        * Si non défini, le bouton ne sera pas affiché
        */
        annul?: boolean;
        /**
        * Permet d’imposer l’impression sur l’imprimante par défaut<br />
        * <i>true</i>, obligation d’utiliser l’imprimante par défaut. Impossibilité de sélectionner une autre imprimante<br />
        * <i>false</i> ou non défini, l’utilisateur peut choisir l’imprimante désirée dans la liste des imprimantes proposées
        */
        impdef?: boolean;
        /**
        * Permet d’effectuer l’impression dans une fenêtre réduite<br />
        * <i>true</i>, ouverture d’une fenêtre d’impression réduite<br />
        * <i>false</i> ou non défini, affiche la fenêtre d’impression normale
        */
        affred?: boolean;
        /**
        * Permet de conserver les fichiers nécessaires à la réimpression du ou des documents
        * <i>true</i>, création et enregistrement dans le répertoire temporaire (%temp%) du poste de travail de 3 fichiers :
        * <ul>
        *   <li><strong>REIMPTYP.txt</strong> : ce fichier contient le type d’impression (« <strong>SIMPLE</strong> » ou « <strong>MULTI</strong> »)</li>
        *   <li>
        *       <strong>REIMPDOC.txt</strong> : ce fichier contient en fonction du type d’impression :
        *       <ul>
        *           <li>Impression simple : le flux d’impression envoyé à l’ActiveX</li>
        *           <li>Impression multiple : les flux d’impression et paramétrages associés envoyés à l’ActiveX</li>
        *       </ul>
        *   </li>
        *   <li>
        *       <strong>REIMPPAR.txt</strong> : ce fichier contient :
        *       <ul>
        *           <li>Dans le cas d’une impression simple : le paramétrage associé au document à imprimer</li>
        *           <li>Dans le cas d’une impression multiple : ce fichier n’est pas créé car inutile</li>
        *       </ul>
        *   </li>
        * </ul>
        * <i>false</i> ou non défini, l’utilisateur peut choisir l’imprimante désirée dans la liste des imprimantes proposées
        */
        reimp?: boolean;
    }
    /**
    * Interface permettant de définir les paramètres individuels de l'ActiveX d'impression pour une impression par lot
    * @interface Impression.ParametresActiveXIndividuels
    */
    interface ParametresActiveXIndividuels {
        /**
        * Permet d'afficher ou non le bouton icône <i>Aperçu</i> dans l'ActiveX d'impression<br />
        * Si non défini, le bouton ne sera pas affiché
        */
        voir?: boolean;
        /**
        * Permet d'afficher ou non le bouton icône <i>Enregistrer</i> dans l'ActiveX d'impression<br />
        * Si non défini, le bouton ne sera pas affiché
        */
        enregistrer?: boolean;
        /**
        * Permet de bloquer et donc d’imposer le nombre de copies à imprimer pour un document <br />
        * La valeur par défaut est false
        */
        blocknbex?: boolean;
        /**
        * Permet de définir le nombre de copies par défaut du document à imprimer<br />
        * Si non défini, le nombre de copies est 1
        */
        nbcopiesdef?: number;
        /**
        * Permet de définir le nombre minimum de copies pour le document à imprimer<br />
        * Si non défini, le nombre de copies minimum est 0
        */
        mincop?: number;
        /**
        * Permet de définir le nombre maximum de copies pour le document à imprimer<br />
        * La valeur par défaut est 0
        */
        maxcop?: number;
    }
    /**
    * Interface permettant de définir les paramètres globaux de l'ActiveX d'impression pour une impression par lot
    * @interface Impression.ParametresActiveXGlobaux
    */
    interface ParametresActiveXGlobaux {
        /**
        * Permet d'afficher ou non le bouton <i>Annuler</i> dans l'ActiveX d'impression<br />
        * Si non défini, le bouton ne sera pas affiché
        */
        annul?: boolean;
        /**
        * Permet d’imposer l’impression sur l’imprimante par défaut<br />
        * <i>true</i>, obligation d’utiliser l’imprimante par défaut. Impossibilité de sélectionner une autre imprimante<br />
        * <i>false</i> ou non défini, l’utilisateur peut choisir l’imprimante désirée dans la liste des imprimantes proposées
        */
        impdef?: boolean;
        /**
        * Permet d’effectuer l’impression dans une fenêtre réduite<br />
        * <i>true</i>, ouverture d’une fenêtre d’impression réduite<br />
        * <i>false</i> ou non défini, affiche la fenêtre d’impression normale
        */
        affred?: boolean;
        /**
        * Permet de conserver les fichiers nécessaires à la réimpression du ou des documents<br />
        * <i>true</i>, création et enregistrement dans le répertoire temporaire (%temp%) du poste de travail de 3 fichiers :
        * <ul>
        *   <li><strong>REIMPTYP.txt</strong> : ce fichier contient le type d’impression (« <strong>SIMPLE</strong> » ou « <strong>MULTI</strong> »)</li>
        *   <li>
        *       <strong>REIMPDOC.txt</strong> : ce fichier contient en fonction du type d’impression :
        *       <ul>
        *           <li>Impression simple : le flux d’impression envoyé à l’ActiveX</li>
        *           <li>Impression multiple : les flux d’impression et paramétrages associés envoyés à l’ActiveX</li>
        *       </ul>
        *   </li>
        *   <li>
        *       <strong>REIMPPAR.txt</strong> : ce fichier contient :
        *       <ul>
        *           <li>Dans le cas d’une impression simple : le paramétrage associé au document à imprimer</li>
        *           <li>Dans le cas d’une impression multiple : ce fichier n’est pas créé car inutile</li>
        *       </ul>
        *   </li>
        * </ul>
        * <i>false</i> ou non défini, l’utilisateur peut choisir l’imprimante désirée dans la liste des imprimantes proposées
        */
        reimp?: boolean;
    }
}


declare module fwkManager.Services.Interop {
    class InfoFichier {
        DateModification: Date;
        Taille: number;
        constructor();
    }
    class ExecutableWrapper {
        ExecApp: ExecApp;
        ExecTransaction: ExecTransaction;
        ExecServ: ExecServ;
        ExecWeb: ExecWeb;
        constructor(execapp: ExecApp, exectransaction: ExecTransaction, execserv: ExecServ, execweb: ExecWeb);
    }
    class ExecApp {
        Executable: string;
        constructor(executable: string);
    }
    class ExecTransaction {
        Numero: string;
        constructor(numero: string);
    }
    class ExecServ {
        CodeSortie: string;
        constructor(codesortie: string);
    }
    class ExecWeb {
        Url: string;
        Libelle: string;
        constructor(url: string, libelle: string);
    }
    class ContexteMyway {
        ProcessId: string;
        StepId: string;
        constructor(processId: string, stepId: string);
    }
    class ContexteClient {
        NumeroClient: string;
        Plan: number;
        constructor(numeroClient: string, plan: number);
    }
    class JsonStringArray {
        Valeur: string[];
        constructor(tableau: string[]);
    }
}

declare module fwkManager.Services.Libelle {
    interface ILibelleService {
        afficherMessage(codeLibelle: string, typeAffichage: TYPE_AFFICHAGE, valeurs?: string[], callback?: () => void, callbackClic?: (any) => void): void;
        constituerLibelle(codeLibelle: string, callback: (any) => void, valeurs?: string[]): void;
    }
    export const enum TYPE_AFFICHAGE {
        ERREUR = 10,
        AVERTISSEMENT = 30,
        INFORMATION = 50,
        OUI_NON = 70,
        OUI_NON_ANNULER = 90,
        VALIDER_ANNULER = 110,
        ANNULER = 120,
        VIDE = 140,
    }
}

declare module fwkManager.Services.Libelle {
    class LibelleModel {
        static COM: {
            MESSAGE_SANS_VARIABLE: string;
            RESULTATS: string;
            ERREUR_PARAMETRE_MAUVAIS_TYPE: string;
            ERREUR_PARAMETRES: string;
            ERREUR_FRAMEWORK: string;
            ERREUR_SERVEUR: string;
            ERREUR_TIMEOUT_SERVEUR: string;
            ERREUR_TIMEOUT_CLIENT: string;
            ERREUR_ACCES_SERVEUR: string;
            ERREUR_CONFIGURATION_PAS_DE_CONFIG: string;
            ERREUR_HABILITATION_MAUVAIS_FORMAT: string;
            ERREUR_HABILITATION_CODE_INCONNU: string;
            ERREUR_HABILITATION_PARAMETRES_INSUFFISANTS: string;
            ERREUR_HABILITATION_AUTHENTIFICATION_MANQUANTE: string;
            ERREUR_INDEXED_DB_NON_SUPPORTE: string;
            ERREUR_INDEXED_DB_GENERIQUE: string;
            ERREUR_INDEXED_DB_SUPPRESSION_IMPOSSIBLE: string;
            ERREUR_INDEXED_DB_ACCES_IMPOSSIBLE: string;
            ERREUR_INDEXED_DB_LECTURE_IMPOSSIBLE: string;
            ERREUR_INDEXED_DB_AJOUT_IMPOSSIBLE: string;
            ERREUR_INDEXED_DB_MAJ_IMPOSSIBLE: string;
            ERREUR_INDEXED_DB_REQUETE_IMPOSSIBLE_INDEX: string;
            ERREUR_INDEXED_DB_REQUETE_IMPOSSIBLE_CRITERE: string;
            ERREUR_INDEXED_DB_CALCUL_TAILLE: string;
            ERREUR_CONTEXTE_RECUP_CODE_ETAB_IMPOSSIBLE: string;
            ERREUR_CONTEXTE_RECUP_ID_AGENCE_IMPOSSIBLE: string;
            ERREUR_DONNEESDELOC_OBJET_MAL_FORME: string;
            ERREUR_DONNEESDELOC_PROPRIETE_ABSENTE: string;
            ERREUR_DONNEESDELOC_RECUP_DERNMAJ_IMPOSSIBLE: string;
            ERREUR_LISA_NEXT_IMPOSSIBLE: string;
            ERREUR_LISA_START_IMPOSSIBLE: string;
            ERREUR_LISA_GETPROCESSES_IMPOSSIBLE: string;
            ERREUR_LISA_GETTOOLS_IMPOSSIBLE: string;
            ERREUR_NUMERISATION_RECUP_CODE_ETAB_IMPOSSIBLE: string;
            ERREUR_NUMERISATION_RECUP_DONNEES_DELOCALISEES_IMPOSSIBLE: string;
            ERREUR_INTEROP_SERVICE_LOCAL_APPEL_IMPOSSIBLE: string;
            ERREUR_FICHIER_PARAMETRE_DATA_VIDE: string;
            ERREUR_FICHIER_PARAMETRE_B64_VIDE: string;
            ERREUR_APPLICATION: string;
            ERREUR_APPLICATION_CODE_NON_RENSEIGNE: string;
            ERREUR_APPLICATION_TYPE_INCONNU: string;
            ERREUR_APPLICATION_DEMARRAGE_IMPO: string;
            ERREUR_APPLICATION_MAINTENANCE: string;
            ERREUR_MOBILITE_RECUP_RESEAU_IMPOSSIBLE: string;
            ERREUR_MOBILITE_RECUP_LISTE_PERIPH_IMPOSSIBLE: string;
            ERREUR_MOBILITE_RECUP_LISTE_TABLETTES_SIGNATURES_IMPOSSIBLE: string;
            ERREUR_MOBILITE_RECUP_INFO_MACHINE_IMPOSSIBLE: string;
            ERREUR_MOBILITE_RECUP_PLATEFORME_MACHINE_IMPOSSIBLE: string;
            ERREUR_MOBILITE_RECUP_RESOLUTION_ECRAN_IMPOSSIBLE: string;
            ERREUR_MOBILITE_RECUP_TYPE_ECRAN_IMPOSSIBLE: string;
            ERREUR_CAPACITES_REGLE_INCONNU: string;
            ERREUR_COMMUNICATION_MESSAGE_INDISPONIBLE: string;
            ERREUR_COMMUNICATION_FORMAT_MAIL_INCORRECT: string;
            ERREUR_COMMUNICATION_FORMAT_NUMERO_INCORRECT: string;
            ERREUR_COMMUNICATION_DONNEES_APPEL_MANQUANTE: string;
            ERREUR_COMMUNICATION_PARAMETRES_INSUFFISANTS: string;
            ERREUR_CONTROLE_STRING_ADRESSEIP_INCORRECT: string;
            ERREUR_ACQUISITION_PARAMETRES_INSUFFISANTS: string;
            ERREUR_EXPORT_DONNEES_ENTREES_FORMAT_INVALIDE: string;
            ERREUR_EXPORT_DONNEES_ENTREES_VIDE: string;
            ERREUR_EXPORT_DONNEES_ENTREES_NB_INVALIDE: string;
            ERREUR_EXPORT_CONVERSION_CSV_IMPOSSIBLE: string;
            ERREUR_EXPORT_TELECHARGEMENT_IMPOSSIBLE: string;
            ERREUR_EXPORT_FORMAT_FICHIER_INCONNU: string;
        };
        static TEC: {
            CHAINE_VIDE: string;
            VALIDATION_ARRAY: string;
            IMPRESSION_GENERATION_EN_COURS: string;
            IMPRESSION_IMPRESSION_EN_COURS: string;
            IMPRESSION_GENERATION_IMPRESSION_EN_COURS: string;
            NUMERISATION_EN_COURS: string;
        };
    }
}


declare module fwkManager.Services.Lisa {
    class LisaCallbackResult {
        processId: string;
        codeProcessus: string;
        codeEtape: string;
        finDeProcessus: boolean;
        sousProcessusDemarre: string;
        etapeCourante: Context.IProcessStep;
        retourEtapePrecedente: boolean;
        nouvelleIframe: boolean;
    }
    interface IInitialisationData {
        /**
         * Données de contexte à insérer dans un processus sous forme d'objet: ex: {"idPersonne":"1234"}
         */
        context?: any;
        /**
         * Données de contexte à insérer dans un processus sous forme de tableau clé valeur ex: [{"Key":"idPersonne", "Value":"1234"}]
         */
        contextArray?: fwkManager.Services.Context.IContextKeyValuePair[];
        /**
         * Nom a utiliser pour l'affichage du processus dans le navigateur
         */
        displayName?: string;
        /**
         * id du client pour rattachement de ce processus au contexte client
         */
        idClient?: string;
        /**
         * id du contexte client pour rattachement de ce processus au contexte client
         */
        idContexteClient?: string;
        /**
         * (Technique) Sous-processus à démarrer immédiatement après le démarrage du processus
         */
        subProcessCode?: string;
        /**
         * (Technique) Permet d'indiquer que le processus doit démarrer dans une nouvelle instance
         */
        processusAOuvrirDansUneNouvelleInstance?: boolean;
    }
    interface IInfoEtape {
        codeTechnique: string;
        codeMetier: string;
    }
    interface IInfoProcessus {
        dateExport: string;
        codeProcessus: string;
        identifiantAgent: string;
        nomProcessus: string;
        etapes: IInfoEtape[];
    }
    interface IAddOns {
        nextsSubProcess: IAddOnsNextSubProcess[];
    }
    interface IAddOnsNextSubProcess {
        codeEtape: string;
        valeurSortie: number;
        valeurDepartSousProcessus: number;
        actionsFinSousProcessus: IAddOnsActionFinProcess[];
    }
    interface IAddOnsActionFinProcess {
        ValeurSortie: number;
        EstExterne: boolean;
        NomExterne: string;
        ValeursFinProcessPossibles: number[];
    }
}


declare module fwkManager.Services.Lisa {
    interface ILisaAgent {
        Next(valeurSortie: number): IPromesse<LisaCallbackResult>;
        NextWithStep(stepCode: string, valeurSortie: number): IPromesse<any>;
    }
}


/**
* Module de gestion de la mobilite (module commun aux agents et aux managers)
* @module fwkManager.Services.Mobilite
*/
declare module fwkManager.Services.Mobilite {
    /**
    * Enumération permettant de définir les types de réseau
    * @export const enum Mobilite.TYPE_RESEAU
    */
    export const enum TYPE_RESEAU {
        DECONNECTE = 0,
        VPN = 10,
        WIFI_AGENCE = 20,
        FILAIRE = 30,
        CONNECTE = 99,
        INCONNU = 99,
    }
    /**
    * Description des plages réseaux CE
    * @interface Mobilite.IPlageReseau
    */
    interface IPlageReseau {
        adresseIP: string;
        masque: string;
    }
    /**
    * Enumération permettant de définir les types de périphérques connectés au poste
    * @export const enum Mobilite.TYPE_PERIPHERIQUE
    */
    export const enum TYPE_PERIPHERIQUE {
        TABLETTE_SIGNATURE = 0,
        CAISSE_AUTO = 1,
    }
    interface IPeripherique {
        typePeripherique: TYPE_PERIPHERIQUE;
    }
    /**
     * Déclaration pour les caisses automatiques
     */
    interface ICaisseAuto extends IPeripherique {
    }
    class CaisseAuto implements ICaisseAuto {
        typePeripherique: TYPE_PERIPHERIQUE;
        type: string;
        constructor();
    }
    /**
     * Déclaration pour les tablettes de signature Wacom
     */
    interface ITabletteSignature extends IPeripherique {
        type: string;
        modele: string;
        codeModele: string;
    }
    class TabletteSignature implements ITabletteSignature {
        type: string;
        modele: string;
        codeModele: string;
        typePeripherique: TYPE_PERIPHERIQUE;
        constructor(type: string, modele: string, codeModele: string);
    }
    /**
    * Enumération permettant de définir le type de plateforme
    * @export const enum Mobilite.PLATEFORME
    */
    export const enum PLATEFORME {
        MYSYS = 1,
        WINDOWS = 2,
        APPLE = 3,
        ANDROID = 4,
        AUTRE = 99,
    }
    /**
    * Description du navigateur de l'utilisateur
    * @interface Mobilite.INavigateur
    */
    interface INavigateur {
        nom: string;
        version: string;
    }
    /**
    * Description des informations de la machine de l'utilisateur
    * @interface Mobilite.IInfoMachine
    */
    interface IInfoMachine {
        plateforme?: PLATEFORME;
        largeurEcran?: number;
        hauteurEcran?: number;
        ecranTactile?: boolean;
        navigateur?: INavigateur;
    }
    class InfoMachine implements IInfoMachine {
        protected _plateforme: PLATEFORME;
        protected _largeurEcran: number;
        protected _hauteurEcran: number;
        protected _ecranTactile: boolean;
        protected _navigateur: INavigateur;
        constructor(_plateforme?: PLATEFORME, _largeurEcran?: number, _hauteurEcran?: number, _ecranTactile?: boolean, _navigateur?: INavigateur);
        plateforme: PLATEFORME;
        largeurEcran: number;
        hauteurEcran: number;
        ecranTactile: boolean;
        navigateur: INavigateur;
    }
}


/**
* Module contenant la configuration des réseaux CE
* @module fwkManager.Services.Mobilite
*/
declare module fwkManager.Services.Mobilite {
    /**Régexp pour déterminer les IP interne, soit commençant par 126. **/
    var PLAGES_IP: RegExp;
    /** Plage réseau des IP se connectant en VPN **/
    var PLAGES_VPN: Array<IPlageReseau>;
    /** Plage réseau des IP se connectant en Wifi **/
    var PLAGES_WIFI_AGENCE: Array<IPlageReseau>;
    /** Plage réseau des IP se connectant en Wifi (backup) **/
    var PLAGES_WIFI_AGENCE_BACKUP: Array<IPlageReseau>;
}


declare module fwkManager.Services.Message {
    class MessageBase extends Component.ComponentBase {
        private static CLASS_NAMEMessageBase;
        private static loggerMessageBase;
        private _targetWindow;
        private _targetDomain;
        private _authorizedDomains;
        private _currentIndex;
        private _callbackArray;
        private _recipient;
        private _sender;
        private _recipientZone;
        private _me;
        constructor(targetWindow: Window, targetDomain: string, authorizedDomains: string[], recipient: string, sender: string, recipientZone: string, zoneName: string, library: Component.IComponentLibrary);
        Dispose(): void;
        CreateMessage(recipient: string, subject: string, content: any, callbackIndex: number, errorCallbackIndex: number): IFrameMessage;
        SendMessage(recipient: string, subject: string, content: any, callback?: (any) => void, errorCallback?: (error: Erreur) => void, targetWindow?: Window, targetDomain?: string, pIdFrame?: string): void;
        protected postMessage(pMessage: IFrameMessage, pTargetWindow: Window, pTargetDomain: string, pIdFrame: string): void;
        private _AddCallback(callback);
        _ReceiveMessage: (event: MessageEvent) => void;
        private static _getBaseDomain(domain);
        HandleReception(event: MessageEvent): void;
        protected transmettreMessageAvecOrdre(event: MessageEvent): void;
        protected transmettreMessage(event: MessageEvent): void;
        HandleResponse(event: MessageEvent): void;
        static IsDomainAuthorized(eventOrigin: string, authorizedDomains: string[]): boolean;
        private _ExecuteCallback(callbackIndex, callbackParam);
        private _RemoveCallback(callbackIndex);
        private _SendResponse;
        private ValidateMessage(message);
    }
    interface IFrameMessage {
        RecipientZone: string;
        RecipientComponent: string;
        SenderZone: string;
        SenderComponent: string;
        Subject: string;
        Content: any;
        Response: any;
        CallbackIndex: number;
        ErreurCallbackIndex: number;
        Error: Erreur;
        type?: string;
    }
    interface IFrameMessageWithOrder extends IFrameMessage {
        index: number;
    }
    class ResponseMessage implements IFrameMessage {
        RecipientZone: string;
        RecipientComponent: string;
        SenderZone: string;
        SenderComponent: string;
        Subject: string;
        Content: any;
        Response: any;
        CallbackIndex: number;
        ErreurCallbackIndex: number;
        Error: Erreur;
        constructor();
    }
}


declare module fwkManager.Services.Message {
    interface IMessageService {
        SendMessage(recipient: string, subject: string, content: any, callback?: (any) => void, errorCallback?: (error) => void, targetWindow?: Window, targetDomain?: string, pIdFrame?: string): any;
        Dispose(): any;
    }
}


declare module fwkManager.Services.Message {
    interface ResponseCallback {
        (event: MessageEvent, callbackContent: any, error: Erreur): void;
    }
}


/**
* Module de gestion de la numérisation (module commun aux agents et aux managers)
* @module fwkManager.Services.Numerisation
* interface : NumerisationParams - public - Interface permettant de définir les paramètres de numérisation d'un document
*/
declare module fwkManager.Services.Numerisation {
    /**
    * Interface permettant de définir les données nécessaires à la numérisation d'un document
    * @interface Numerisation.NumerisationData
    */
    interface NumerisationData {
        CCLI_TYP: any;
        CCLI_UTL: any;
        NATURE: any;
        data: string;
    }
    /**
    * Interface permettant de définir les données nécessaires à la numérisation d'un document avec SpiFactory Arcade
    * @interface Numerisation.NumerisationDataArcade
    */
    interface NumerisationDataArcade {
        D93F: any;
        D93G: any;
        D93J: any;
        D93K: any;
        D93M: any;
        D93T: any;
        D93V: any;
        D93Y: any;
        data: string;
    }
    /**
    * Interface permettant de définir les paramètres nécessaires à la numérisation d'un document
    * @interface Numerisation.NumerisationParams
    */
    interface NumerisationParams {
        dropZonePath: string;
        configurationFilePath: string;
    }
}


declare module fwkManager.Services.Trace {
    export const enum NIVEAUX_TRACE {
        DEBUG = 30,
        INFO = 50,
        WARNING = 70,
        ERROR = 90,
    }
    interface ILogger {
        debug(message: string, action?: string, object?: any): void;
        info(message: string, action?: string, object?: any): void;
        warning(message: string, action?: string, object?: any): void;
        error(message: string, action?: string, object?: any): void;
    }
    class Utils {
        static gererErreur(object: any): any;
    }
}


declare module fwkManager.Services.Trace {
    class Logger implements ILogger {
        private _componentName;
        private _zoneName;
        private _library;
        constructor(componentName: string, zoneName: string, library: Component.IComponentLibrary);
        debug(message: string, action?: string, detail?: any): void;
        info(message: string, action?: string, detail?: any): void;
        warning(message: string, action?: string, detail?: any): void;
        error(message: string, action?: string, detail?: any): void;
        private send(niveauTrace, message, action?, detail?);
        private createTrace(niveau, message, url, application, composant?, action?, detail?);
    }
    class TraceModel {
        /** Date de la trace */
        datetime: number;
        /** Niveau de la trace (DEBUG, INFO, WARNING, ERROR) */
        niveau: NIVEAUX_TRACE;
        /** Numero station de travail */
        client: string;
        /** Nom du serveur (opt.) */
        serveur: string;
        /** URL de la page provoquant la trace */
        url: string;
        /** Id du processus courant */
        idProcessus: string;
        /** Chemin de l'étape courante */
        cheminInstances: string;
        /** Nom de l'application provoquant la trace */
        application: string;
        /** Nom du composant provoquant la trace */
        composant: string;
        /** Action en cours lors de la trace */
        action: string;
        /** Code agent */
        COCEAG: string;
        /** Code etablissement */
        COCXBQ: string;
        /** Type fonction */
        CTCEAG: string;
        /** Numero interne EDS */
        NOCEEL: string;
        /** Message de la trace */
        message: string;
        /** Détails de la trace */
        details: any;
    }
}


declare module fwkManager.Services.Trace {
    interface ITraceService {
        send(trace: Trace.TraceModel): void;
        sendDiagnostic(diagnostic: ApplicationDiagnostic): void;
        sendLog(pLog: Loggers.ILoggerWithContext): IPromesse<void>;
    }
}


declare module fwkManager.Services.TraceSuivi {
    class TraceSuiviModel {
        dateUse: number;
        timezone: string;
        deviceType: string;
        deviceId: string;
        computerSi: string;
        establishment: string;
        agentEdsType: string;
        agentEdsCode: string;
        agentEdsInternalRef: string;
        agentCode: string;
        computerEdsInternalId: string;
        processIdMaster: string;
        processIdCurrent: string;
        stepIdCurrent: string;
        processIdBusiness: string;
        action: string;
        state: string;
        resultStep: string;
        data: any;
    }
}


declare module fwkManager.Services {
    class RouteurAgent {
        private static CLASS_NAME;
        private static logger;
        constructor();
        StepInfo: Context.StepInfo;
        Next(valeurSortie: any): void;
        AddToContext(key: string, value: string): void;
        GetFromContext(key: string): string;
        LireFichier(nomFichier: string): IPromesse<string>;
        Previous(): void;
    }
}


declare module fwkManager.Services.BaseDeDonnees {
    class VerificationSchemaIndexeddb {
        private static isVerified;
        private static estEnCours;
        private static defersEnAttente;
        static testEtCorrectionSchema(): IPromesse<void>;
        private static testDB(pBDName, pTables);
    }
}

declare module fwkManager.Services.Component {
    interface IComponentManager extends IComponent {
        Library: ManagerLibrary;
    }
}


declare module fwkManager.Services.Component {
    class ManagerEvent {
        EventType: ManagerEventType;
        Detail: IManagerEventDetail;
        ComponentName: string;
        constructor(EventType: ManagerEventType, Detail: IManagerEventDetail);
        onSend(pIFrameId: string): boolean;
    }
    interface IManagerEventDetail {
        portalContext?: Context.IPortalContext;
        demandeDeDemarrageDeProcessusDetail?: IDemandeDeDemarrageDeProcessusDetail;
        /**
         * Permet d'indiquer au sein du message si le processus est à ouvrir dans une nouvelle instance de navigateur
         */
        processusAOuvrirDansUneNouvelleInstance?: boolean;
        diagnostic?: ApplicationDiagnostic;
        contexteClientMiseAJourInfo?: ContexteClient.Messages.IMiseAJourContexteClient;
        chat?: BriqueCommunication.Messages.IBriqueCommunicationMessage<any>;
        info?: string;
    }
    interface IDemandeDeDemarrageDeProcessusDetail {
        codeProcessus?: string;
        valeurDepart?: string;
        initData?: string;
        onlyHeader?: boolean;
        applicationDTO?: Application.ApplicationDTO;
    }
    export const enum ManagerEventType {
        PortalContextChanged = 1,
        FinDeTransition = 2,
        FinDeProcessus = 3,
        NouvelleEtape = 4,
        NouveauProcess = 5,
        NouveauSousProcess = 6,
        NouvelleAppliExterne = 7,
        BasculeProcess = 8,
        ChangementNomProcess = 9,
        DemandeDeDemarrageDeProcessus = 10,
        AcceptPhase = 11,
        ConnectionSignalR = 12,
        AfficherLogOn = 13,
        MasquerLogOn = 14,
        Extraction = 15,
        Diagnostic = 16,
        MiseAJourContexteClient = 17,
        Log = 18,
        ChangementAuthentificationInfo = 19,
        BriqueCommunication = 20,
        ContextRecharge = 21,
        ResetHabilitations = 22
    }
    class ComponentManagerBase extends ComponentBase implements IComponentManager {
        Library: ManagerLibrary;
        private listenersEvennement;
        constructor(library: ManagerLibrary, name: string);
        SendMessage(subject: string, content: any, callback?: (any) => void, errorCallback?: ErreurCallback): void;
        SendMessageWithRecipient(recipient: string, subject: string, content: any, callback?: (any) => void, errorCallback?: ErreurCallback): void;
        SendMessageWithRecipientAndFrame(recipient: string, subject: "Notification", content: NotificationMessage, frame: fwkManager.Services.Display.FrameModel, callback?: (any) => void, errorCallback?: ErreurCallback): void;
        SendMessageWithRecipientAndFrame(recipient: string, subject: string, content: any, frame: fwkManager.Services.Display.FrameModel, callback?: (any) => void, errorCallback?: ErreurCallback): void;
        SendEvent(event: ManagerEvent): void;
        Dispose(): IPromesse<void>;
        protected ajouterListenerEvent(pTypeEvennement: ManagerEventType, pListener: (event: ManagerEvent) => void): void;
    }
}


declare var versionMySys: string;
declare module fwkManager.Services {
    interface IServiceManagerInitialisation {
        OnEvent?: (event: Component.ManagerEvent) => void;
        IFrameId?: string;
        LogOnUrl?: string;
        ServiceApi?: IServiceApi;
        /**
         * Mode du portail
         *
         * - 'portal' : correspond à un portail 'multi-processus'
         *
         * - 'single' : correspond à un portail 'mono-processus' PCM
         *
         */
        PortalType?: string;
        isTotemCapable?: boolean;
        ModeVerificationProcessus?: ModeVerificationProcessus;
        delegationPortail?: boolean;
    }
    export const enum ModeVerificationProcessus {
        Aucun = 0,
        Warning = 1,
        Erreur = 2,
    }
    class ServiceManagerExtended {
        private _serviceManager;
        Aide: Aide.AideManagerExtended;
        Trace: Trace.TraceManagerExtended;
        Context: Context.ContextManagerExtended;
        ContexteClient: ContexteClient.ContexteClientManagerExtended;
        Interop: Interop.InteropManagerExtended;
        Display: Display.DisplayManagerExtended;
        Lisa: Lisa.LisaManagerExtended;
        Application: Application.ApplicationManagerExtended;
        Habilitation: Habilitation.HabilitationManagerExtended;
        Preferences: Preferences.PreferencesManagerExtended;
        Communication: Communication.CommunicationManagerExtended;
        DonneesDelocalisees: DonneesDelocalisees.DonneesDelocaliseesManagerExtended;
        TraceSuivi: TraceSuivi.TraceSuiviManagerExtended;
        Chat: BriqueCommunication.Chat.ChatManagerExtended;
        constructor();
        init(serviceInit: IServiceManagerInitialisation): IPromesse<Context.IPortalContext>;
        private initBriqueCommunication();
        Initialize(): IPromesse<any>;
        OnEvent: (event: Component.ManagerEvent) => void;
        Dispose(): IPromesse<any>;
        VersionMySys(): string;
    }
    class ServiceManager {
        private onPortalContextChanged;
        private static CLASS_NAME;
        private static logger;
        private listenerEventFromPortail;
        Library: ManagerLibrary;
        constructor(onPortalContextChanged: (context: fwkManager.Services.Context.IPortalContext, onlyHeader: boolean) => void);
        private static _instance;
        static Instance(): ServiceManager;
        init(serviceInit: IServiceManagerInitialisation): IPromesse<any>;
        OnEvent: (event: Component.ManagerEvent) => void;
        static staticInit(): void;
        private StartManagers(serviceApi, serviceInit);
        private initBriqueCommunication();
        Dispose(): IPromesse<void>;
        internalContextRevisions: string[];
        internalInteropMessageBusRevisions: string[];
        private _onInternalInteropMessageBusStorageChanged;
        private _onInternalContextStorageChanged;
        private limitesDBOriginales;
        private timersLimitesBases;
        private callbacksLimitesBases;
        private _onStorageLimitGenerique;
        private _onStorageLimit;
        Initialize(): IPromesse<any>;
    }
}


declare module fwkManager.Services {
    class PhantomAgent implements IServiceAgent {
        Lisa: Lisa.ILisaAgent;
        Context: Context.IContextAgent;
        DonneesDelocalisees: DonneesDelocalisees.IDonneesDelocaliseesAgent;
        Habilitation: Habilitation.IHabilitationAgent;
        Communication: Communication.ICommunicationAgent;
        Core: CoreCommon;
        Dates: Dates.DatesCommon;
        Trace: Trace.Logger;
        private _logger;
        private _serviceManager;
        constructor();
        SendRequest(settings: IRequestSettings): IPromesse<any>;
        init(serviceInit?: IServiceAgentInitialisation): IPromesse<any>;
        DisplayMessage(message: IMessage): void;
        SubscribeToNotification(onNotification: (notification: NotificationMessage, serviceAgent?: IServiceAgent) => void): void;
        Dispose(): void;
        OnNotification(notification: NotificationMessage, serviceAgent?: IServiceAgent): void;
    }
}


declare module fwkManager.Services {
    class ServiceManagerProvider {
        private $q;
        static $inject: string[];
        private static _serviceManager;
        constructor($q: ng.IQService);
        static Instance(): ServiceManagerExtended;
        init(serviceInit?: IServiceManagerInitialisation): ng.IPromise<ServiceManagerExtended>;
    }
    class PhantomAgentProvider {
        private $q;
        static $inject: string[];
        private static _phantomAgent;
        constructor($q: ng.IQService);
        static Instance(): PhantomAgent;
        init(serviceInit?: IServiceAgentInitialisation): ng.IPromise<PhantomAgent>;
    }
    var moduleManager: ng.IModule;
}


declare module fwkManager.Services {
    interface IServiceApi2 {
        Next(codeEtape: string, valeurSortie: number, currentProcess: string, callback: (next: Lisa.NextResult) => void, errorCallback: (error) => void): any;
        GetAuthentificationInfo(callback: (authentificationInfo: Context.AuthentificationInfo) => void, errorCallback: ErreurCallback): any;
        GetParametresComptables(callback: (parametresComptables: Context.ParametresComptables) => void, errorCallback: ErreurCallback): any;
        Lancer(executableWrapper: Interop.ExecutableWrapper, parametres: string[], sync: boolean, errorCallback: ErreurCallback): any;
        AddToContextInterop(level: string, processCourant: string, key: string, value: string, callback: (any) => void, errorCallback: ErreurCallback): any;
        AddListToContextInterop(level: string, datas: fwkManager.Services.Context.IContextKeyValuePair[], callback: (any) => void, errorCallback: ErreurCallback): any;
        GetVarEnv(nom: string, callback: (valeur: string) => void, errorCallback: ErreurCallback): any;
        GetRegistryValue(niveau: string, souscle: string, nom: string, callback: (any) => void, errorCallback: (error) => void): any;
        EcrireFichier(pathFichier: string, fluxdonnees: string, ajouter: boolean, creeDir: boolean, callback: (retour: string) => void, errorCallback: ErreurCallback): any;
        LireFichier(pathFichier: string, callback: (data: string) => void, errorCallback: ErreurCallback): any;
        GetInfoFichier(pathFichier: string, callback: (infoFichier: Interop.InfoFichier) => void, errorCallback: ErreurCallback): any;
        AfficherWindowParHandle(handle: string, affiche: boolean): any;
        AfficherWindowParPid(Pid: string, affiche: boolean): any;
        envoyerTraces(traces: Trace.TraceModel[], callback: () => void, errorCallback: ErreurCallback): any;
        sendRequest(settings: IRequestSettings, callback: (data: any) => void, callbackError: ErreurCallback): any;
        getDistantObjectData(settings: IRequestSettings, callback: (data: any) => void, callbackError: ErreurCallback): any;
        getDistantTDT(settings: IRequestSettings, callback: (data: any) => void, callbackError: ErreurCallback): any;
        getTDTById(settings: IRequestSettings, callback: (data: any) => void, callbackError: ErreurCallback): any;
        genererDocument(settings: IRequestSettings, callback: (fichier?: Impression.DocumentGenere) => void, callbackError: ErreurCallback): any;
        imprimerDocument(settings: IRequestSettings, callback: () => void, callbackError: ErreurCallback): any;
        numeriserDocument(settings: IRequestSettings, callback: (data: any) => void, callbackError: ErreurCallback): any;
        getSpiFactoryActivationStatutOnServeur(settings: IRequestSettings, callback: (statut: boolean) => void, callbackError: ErreurCallback): any;
        numeriserDocumentArcade(settings: IRequestSettings, callback: (data: any) => void, callbackError: ErreurCallback): any;
        envoyerTracesSuivi(traces: TraceSuivi.TraceSuiviModel, callback: (result: string) => void, errorCallback: ErreurCallback): any;
        ObtenirPreferences(nomPoste: string, callback: (data: any) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): any;
        EcrirePreference(nomPoste: string, cle: string, valeur: string, callback: (data: any) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): any;
    }
    interface IServiceApi {
        Name: string;
        Acquisition: Acquisition.IAcquisitionApi;
        Lisa: Lisa.ILisaApi;
        Interop: Interop.IInteropApi;
        Context: Context.IContextApi;
        DonneesDelocalisees: DonneesDelocalisees.IDonneesDelocaliseesApi;
        Trace: Trace.ITraceApi;
        Impression: Impression.IImpressionApi;
        Numerisation: Numerisation.INumerisationApi;
        Libelles: Libelle.LibelleModel;
        Fichier: Fichier.IFichierApi;
        Configuration: Configuration.IConfigurationApi;
        Habilitation: Habilitation.IHabilitationApi;
        Aide: Aide.IAideApi;
        Application: Application.IApplicationApi;
        TraceSuivi: TraceSuivi.ITraceSuiviApi;
        Preferences: Preferences.IPreferencesApi;
        JAB: JAB.IJABApi;
        Mobilite: Mobilite.IMobiliteApi;
        TraitementNsdk: TraitementNsdk.ITraitementNsdkApi;
        DeviceCapabilities: DeviceCapabilities;
        NumerotationTelephonique: Communication.INumerotationTelephoniqueApi;
        ContexteClient: ContexteClient.IContexteClientApi;
        BriqueCommunication: BriqueCommunication.IBriqueCommunicationApi;
    }
}


declare module fwkManager.Services {
    class ServiceApiBase {
        Libelles: Libelle.LibelleModel;
        DeviceCapabilities: DeviceCapabilities;
        private callback;
        private compteurOperationsAsynchrones;
        Init(callback: (serviceApi: IServiceApi) => void): void;
        private gererRetour();
    }
}


declare module fwkManager.Services {
    class ServiceApiFullWeb extends ServiceApiBase implements IServiceApi {
        Name: string;
        Acquisition: Acquisition.IAcquisitionApi;
        Lisa: Lisa.ILisaApi;
        Interop: Interop.IInteropApi;
        Context: Context.IContextApi;
        DonneesDelocalisees: DonneesDelocalisees.IDonneesDelocaliseesApi;
        Trace: Trace.ITraceApi;
        Impression: Impression.IImpressionApi;
        Numerisation: Numerisation.INumerisationApi;
        Fichier: Fichier.IFichierApi;
        Configuration: Configuration.IConfigurationApi;
        Habilitation: Habilitation.IHabilitationApi;
        Aide: Aide.IAideApi;
        Application: Application.IApplicationApi;
        TraceSuivi: TraceSuivi.ITraceSuiviApi;
        Preferences: Preferences.IPreferencesApi;
        JAB: JAB.JABApi;
        Mobilite: Mobilite.IMobiliteApi;
        TraitementNsdk: TraitementNsdk.ITraitementNsdkApi;
        NumerotationTelephonique: Communication.INumerotationTelephoniqueApi;
        ContexteClient: ContexteClient.IContexteClientApi;
        BriqueCommunication: BriqueCommunication.IBriqueCommunicationApi;
        constructor(callback: (IServiceApi) => void);
    }
}


declare module fwkManager.Services {
    class ServiceApiDemo extends ServiceApiFullWeb implements IServiceApi {
        constructor(callback: (IServiceApi) => void);
    }
}


declare module fwkManager.Services {
    class ServiceApiDev extends ServiceApiFullWeb implements IServiceApi {
        constructor(callback: (IServiceApi) => void);
    }
}


declare module fwkManager.Services {
    class ServiceApiIntegration extends ServiceApiFullWeb implements IServiceApi {
        constructor(callback: (IServiceApi) => void);
    }
}


declare module fwkManager.Services {
    class ServiceApiWindows extends ServiceApiBase implements IServiceApi {
        Name: string;
        Acquisition: Acquisition.IAcquisitionApi;
        Lisa: Lisa.ILisaApi;
        Interop: Interop.IInteropApi;
        Context: Context.IContextApi;
        DonneesDelocalisees: DonneesDelocalisees.IDonneesDelocaliseesApi;
        Trace: Trace.ITraceApi;
        Impression: Impression.IImpressionApi;
        Numerisation: Numerisation.INumerisationApi;
        Fichier: Fichier.IFichierApi;
        Configuration: Configuration.IConfigurationApi;
        Habilitation: Habilitation.IHabilitationApi;
        Aide: Aide.IAideApi;
        Application: Application.IApplicationApi;
        TraceSuivi: TraceSuivi.ITraceSuiviApi;
        Preferences: Preferences.IPreferencesApi;
        JAB: JAB.JABApi;
        Mobilite: Mobilite.IMobiliteApi;
        TraitementNsdk: TraitementNsdk.ITraitementNsdkApi;
        NumerotationTelephonique: Communication.INumerotationTelephoniqueApi;
        ContexteClient: ContexteClient.IContexteClientApi;
        BriqueCommunication: BriqueCommunication.IBriqueCommunicationApi;
        constructor(callback: (IServiceApi) => void);
    }
}


declare module fwkManager.Services {
    class ServiceApiSIRIS extends ServiceApiWindows implements IServiceApi {
        Mobilite: Mobilite.IMobiliteApi;
        constructor(callback: (IServiceApi) => void);
    }
}


declare module fwkManager.Services {
    class ServiceApiPetra extends ServiceApiWindows implements IServiceApi {
        Name: string;
        Application: Application.IApplicationApi;
        constructor(callback: (IServiceApi) => void);
    }
}

declare module fwkManager.Services {
    class EmptyServiceApi implements IServiceApi {
        Name: string;
        Acquisition: Acquisition.IAcquisitionApi;
        Lisa: Lisa.ILisaApi;
        Interop: Interop.IInteropApi;
        Context: Context.IContextApi;
        DonneesDelocalisees: DonneesDelocalisees.IDonneesDelocaliseesApi;
        Trace: Trace.ITraceApi;
        Impression: Impression.IImpressionApi;
        Numerisation: Numerisation.INumerisationApi;
        Fichier: Fichier.IFichierApi;
        Libelles: Libelle.LibelleModel;
        Configuration: Configuration.IConfigurationApi;
        Habilitation: Habilitation.IHabilitationApi;
        Aide: Aide.IAideApi;
        Application: Application.IApplicationApi;
        TraceSuivi: TraceSuivi.ITraceSuiviApi;
        Preferences: Preferences.IPreferencesApi;
        JAB: JAB.JABApi;
        Mobilite: Mobilite.IMobiliteApi;
        TraitementNsdk: TraitementNsdk.TraitementNsdkApi;
        DeviceCapabilities: DeviceCapabilities;
        NumerotationTelephonique: Communication.INumerotationTelephoniqueApi;
        ContexteClient: ContexteClient.IContexteClientApi;
        BriqueCommunication: BriqueCommunication.IBriqueCommunicationApi;
    }
}


declare module fwkManager.Services {
    class ServiceApiFactory {
        DeviceCapabilities: DeviceCapabilities;
        ServiceApi: IServiceApi;
        constructor();
        CreateServiceApi(fullWebMode: string, callback: (IServiceApi) => void): void;
        GetServiceLocalCapabilities(): IPromesse<IXMLHttpRequest>;
    }
    class DeviceCapabilities {
        ServiceLocal: boolean;
        SIRIS: boolean;
        MobileBrowser: boolean;
        InteropAppliBancaire: boolean;
    }
    class CompetencesServiceLocal {
        SIRIS: boolean;
        interopApplicationBancaire: boolean;
    }
}


declare module fwkManager.Services {
    class Evennements extends Component.ComponentManagerBase {
        private static CLASS_NAME;
        private static logger;
        private listenersParEvenement;
        private typesEvenements;
        constructor(library: ManagerLibrary);
        ajouterListener(pListener: (pEvent: Component.ManagerEvent) => void, ...pTypeEvenements: Component.ManagerEventType[]): void;
        retirerListener(pListenerASupprimer: (pEvent: Component.ManagerEvent) => void): void;
        notifier(pEvent: Component.ManagerEvent): void;
        private notifierAgents(pEvent);
    }
    class ManagerLibrary extends Component.ComponentLibraryBase implements ICommonLibrary {
        Evennements: Evennements;
        ServiceApi: IServiceApi;
        Persistence: Persistence.PersistenceManager;
        Acquisition: Acquisition.AcquisitionManager;
        Aide: Aide.AideManager;
        Application: Application.ApplicationManager;
        Configuration: Configuration.ConfigurationManager;
        Context: Context.ContextManager;
        ContexteClient: ContexteClient.ContexteClientManager;
        Core: CoreCommon;
        Dates: Dates.DatesCommon;
        Display: Display.DisplayManager;
        DonneesDelocalisees: DonneesDelocalisees.DonneesDelocaliseesManager;
        Export: Export.ExportManager;
        Fichier: Fichier.FichierManager;
        Habilitation: Habilitation.HabilitationManager;
        Impression: Impression.ImpressionManager;
        Interop: Interop.InteropManager;
        JAB: JAB.JABManager;
        Libelle: Libelle.LibelleManager;
        Lisa: Lisa.LisaManager;
        Message: Message.MessageManager;
        Mobilite: Mobilite.MobiliteManager;
        Numerisation: Numerisation.NumerisationManager;
        Preferences: Preferences.PreferencesManager;
        Trace: Trace.TraceManager;
        TraceSuivi: TraceSuivi.TraceSuiviManager;
        TraitementNsdk: TraitementNsdk.TraitementNsdkManager;
        Capacites: Capacites.CapacitesManager;
        Communication: Communication.CommunicationManager;
        BaseDeDonnees: BaseDeDonnees.BaseDeDonneesManager;
        Logger: Loggers.LoggerManager;
        BriqueCommunication: BriqueCommunication.BriqueCommunicationManager;
        Chat: BriqueCommunication.Chat.ChatManager;
        Notification: BriqueCommunication.Notification.NotificationManager;
        private static _instance;
        constructor();
        static Instance(): ManagerLibrary;
    }
}


declare module fwkManager.Services {
    class PrivatePortalServiceParameters {
        private static _instance;
        constructor();
        static Instance(): PrivatePortalServiceParameters;
        init(): void;
        /**
         * URL
         */
        AuthorizedDomains: string[];
        ConfigurationUrl: string;
        DonneesDelocaliseesUrl: string;
        HabilitationUrl: string;
        ImpressionUrl: string;
        GetFichierFromGEDUrl: string;
        JABUrl: string;
        LisaFileUrl: string;
        LisaUrl: string;
        ReferentielProcessusSiUrl: string;
        LocalServiceUrl: string;
        NumerisationUrl: string;
        PortsServiceUrl: string;
        PreferencesUrl: string;
        ShareServiceUrl: string;
        TraceUrl: string;
        TraceSuiviUrl: string;
        TempRestUrl: string;
        AideUrl: string;
        AuthentificationUrl: string;
        ApplicationUrl: string;
        RADLADUrl: string;
        StockageUrl: string;
        PortalInfoUrl: string;
        SimulateAppIFrame: boolean;
        FichierMessage: string;
        TTLModeDebug: number;
        ModeDebug: boolean;
        Environnement: string;
        NumerotationTelephoniqueUrl: string;
        KofaxUrl: string;
        private _lisaPlaceHolders;
        LisaPlaceholders: any;
        LocalServiceDisabled: boolean;
    }
}


declare module fwkManager.Services {
    class PortalServiceParameters {
        private static _instance;
        constructor();
        static Instance(): PortalServiceParameters;
        /**
         * URL
         */
        RestUrl: string;
        SpaUrl: string;
        ServiceLocaleUrl: string;
        ImpressionUrl: string;
        PortsServiceUrl: string;
        /**
         * Variables
         */
        Environnement: string;
        Version: string;
        PresPMM: string;
        EnvPMM: string;
        DomainePMM: string;
        AuthorizedDomains: string[];
        LisaFilePath: string;
        CDNUrl: string;
    }
}


declare module fwkManager.Services.Loggers.Appenders {
    class DBAppender extends AbstractAppender {
        static CLASSNAME: string;
        private static _SERVICE_TRACE;
        private static indexeddbIsOk;
        private static bufferAttenteTestIndexeddb;
        static SERVICE_TRACE: Trace.TraceManager;
        private static purger();
        private static tracesAEnregistrer;
        private messageFormater;
        constructor(pNom: string, level: LEVEL, config: IConsoleAppenderConfig);
        protected onAppend(pMessage: ILoggerWithContext): void;
    }
}


declare module fwkManager.Services.Loggers.Appenders {
    class PortalAppender extends AbstractAppender {
        static CLASSNAME: string;
        private format;
        private _eventsToSend;
        constructor(pNom: string, level: LEVEL, config: IConsoleAppenderConfig);
        onAppend(pMessage: ILoggerWithContext): void;
        private send(pEvent);
        private parse(pFormat);
    }
}


declare module fwkManager.Services.Loggers {
    var DEFAULT_CONFIGURATION_PORTAIL: IConfig;
}


declare module fwkManager.Services.Loggers {
    class LoggerManager extends Component.ComponentManagerBase {
        private loggerFactory;
        private _managerLibrary;
        Library: ManagerLibrary;
        constructor(managerLibrary: ManagerLibrary, loggerFactory: Loggers.LoggerFactory);
        private onGetConfigDB(pParametres);
        private onSetConfigDB(pParametres);
        private onGetConfigActual();
        private onSetConfigActual(pParametres);
        private onLoadConfig(pParametres);
        private onSaveConfig(pParametres);
        private onGetLoggers();
        private onGetNomConfigActuelle();
        private getClassByName(pName);
        private onIsClassExists(pParams);
        private onReset();
        /**
        * Traite les messages provenants de l'agent BaseDeDonneesAgent
        * @param event {Event} évènement
        * @param sendResponseCallback {ResponseCallback} objet contenant le callback de retour
        */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}


declare module fwkManager.Services.Configuration {
    class ConfigurationManager extends Component.ComponentManagerBase {
        private static CLASS_NAME;
        private static logger;
        private _managerLibrary;
        Library: ManagerLibrary;
        constructor(managerLibrary: ManagerLibrary);
        SetConfiguration(callback?: (data: any) => void, errorCallback?: (error: fwkManager.Services.Erreur) => void): void;
        GetConfiguration(): any;
        private isJson(str);
    }
}


declare module fwkManager.Services.Configuration {
    interface IConfigurationApi {
        SetConfiguration(dateConfig: string, nomPoste: string, nomEtablissement: string, callback: (data: any) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): any;
        GetConfiguration(): any;
    }
}


declare module fwkManager.Services.Configuration {
    /**
    * Classe permettant la gestion des configurations
    */
    class ConfigurationApi extends Component.ComponentApiBase implements IConfigurationApi {
        constructor();
        SetConfiguration(dateConfig: string, nomPoste: string, nomEtablissement: string, callback: (data: any) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): void;
        GetConfiguration(): void;
    }
}


declare module fwkManager.Services.Aide {
    class AideManagerExtended {
        private manager;
        constructor(manager: AideManager);
        MemoriserEtape(aidePref: IAidePref): void;
    }
    /**
    * Classe permettant la gestion de l'aide
    */
    class AideManager extends Component.ComponentManagerBase {
        ClePreferenceModaleAide: string;
        private _listeCodesEtapesVues;
        private _managerLibrary;
        Library: ManagerLibrary;
        private static INDICATEUR_DE_TOKEN;
        private static CLASS_NAME;
        private static logger;
        constructor(managerLibrary: ManagerLibrary);
        /**
         * Permet de récupérer une aide push si elle existe, puis déclencher son ouverture si elle n'a pas encore été vue
         * @param {IAideParametres}                           params          Paramètres de recherche de l'aide push
         * @param {AideResult)            =>     void}        callback        Callback de succès, avec le résultat de l'aide
         * @param {fwkManager.Services.Erreur) =>     void}        errorCallback   Callback d'erreur
         */
        DisplayAideFlash(params: InfobulleAfficheeParametres): void;
        private LireEtapesDansPreference(callback);
        /**
         * Permet de mémoriser que l'utilisateur ne souhaite plus visualiser systématiquement
         * l'aide flash de l'étape dont le code étape et l'id flash est précisée en paramètre
         * @param {IAidePref} préférence d'aide
         */
        AjouterEtapeDansPreference(aidePref: IAidePref): void;
        private AidePrefExistForOnlyCodeEtape(aidepref, aidePrefList);
        private AidePrefExist(aidepref, aidePrefList);
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
        GetContenuInfobulle(params: DetailInfobulleAfficheeParametres, callback: (data: DetailInfobulleAfficheeResult) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): void;
        GetInfobullesAffichables(params: InfobulleAfficheeParametres, callback: (data: InfobulleAfficheeResult[]) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): void;
        private GetParametresContexte(idChampLie?, horsProcessus?, codeProcessus?, codeEtape?);
        private ValoriserMessage(interpretationTokens, messageOriginel);
        private RemplacerTokens(messageOriginel);
        private DeterminerNouveaute(dateFinNouveaute, tokenNouveaute);
        private CreerImageBlob(imageBase64);
    }
}


declare module fwkManager.Services.Aide {
    var CODE_ETAPE_KEY: string;
    var ID_FLASH_CODE_KEY: string;
    interface IAideParametres {
        codeEtablissement: string;
        codeProcessus: string;
        codeEtape: string;
        pointEntree: string;
    }
    interface IAidePref {
        codeEtape: string;
        idFlashCode: number;
    }
    class InfobulleAfficheeParametres implements IAideParametres {
        codeEtablissement: string;
        codeProcessus: string;
        codeEtape: string;
        pointEntree: string;
        dateTraitement: string;
        estEgal(parametres: InfobulleAfficheeParametres): boolean;
    }
    class DetailInfobulleAfficheeParametres extends InfobulleAfficheeParametres {
        idChampLie: string;
        estEgal(parametres: DetailInfobulleAfficheeParametres): boolean;
    }
    interface IAideApi {
        GetContenuInfobulle(params: DetailInfobulleAfficheeParametres, callback: (data: any) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): any;
        GetInfobullesAffichables(params: InfobulleAfficheeParametres, callback: (data: any) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): any;
        GetAideFlash(params: InfobulleAfficheeParametres, callback: (data: IAideFlash) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): any;
    }
}


declare module fwkManager.Services.Aide {
    class AideApi extends Component.ComponentApiBase implements IAideApi {
        constructor();
        GetContenuInfobulle(params: DetailInfobulleAfficheeParametres, callback: (data: any) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): void;
        GetInfobullesAffichables(params: InfobulleAfficheeParametres, callback: (data: any) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): void;
        GetAideFlash(params: InfobulleAfficheeParametres, callback: (data: IAideFlash) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): void;
    }
}


/**
* Module de gestion de la numérisation
* @module fwkManager.Services.Acquisition
* classe : NumerisationManager - public - Classe permettant la gestion de la numérisation
*/
declare module fwkManager.Services.Acquisition {
    /**
    * Classe permettant la gestion de la numérisation
    *
    * @classe AcquisitionManager
    */
    class AcquisitionManager extends Component.ComponentManagerBase {
        private static CLASS_NAME;
        private static logger;
        /**
         * Constructeur de la classe NumerisationManager
         * @param managerLibrary {ManagerLibrary}
         * @param serviceApi {IServiceApi}
         */
        constructor(managerLibrary: ManagerLibrary);
        /**
         * Permet d'extraire les données de fichiers
         *
         * @param fileInfos les informations sur les fichiers (url et type)
         * @param params la liste des paramètres RADLAD
         *
         * @return les informations du traitement RADLAD
         */
        appelRADLAD(fileInfos: IFileInformation[], params: IRadladParams): IPromesse<string>;
        /**
         * Permet de convertir des fichiers en images
         *
         * @param fileInfo information du fichier
         * @param params paramètres de conversion du fichier
         *
         * @return array un tableau evs les liens vers les images, les miniatures et les pds de chaque fichier
         */
        convertFileToImg(fileInfo: IFileInformation, params: IConvertFileParams): IPromesse<string>;
        /**
         * Permet de merger des pdf en un seul et de l'archiver en GED
         *
         * @param fileInfos information des pdfs
         * @param putDocumentInput le document à envoyer en GED
         *
         * @return
         */
        mergerEtArchiver(fileInfos: IFileInformation[], putDocumentInput: IPutDocumentInput): IPromesse<string>;
        /**
         * Permet de merger des pdf en un seul et de l'uploader
         *
         * @param fileInfos information des pdfs
         *
         * @return
         */
        mergerEtUploader(fileInfos: IFileInformation[]): IPromesse<string>;
        /**
         * Permet de convertir des fichiers base64 en binaire
         *
         * @param urls la liste des urls des fichiers à convertir
         *
         * @return
         */
        convertBase64ToBin(urls: string[]): IPromesse<string>;
        /**
         * Permet de vider le répertoire où sont stocké les images
         *
         * @return boolean true si tout s'est bien passé sinon false
         */
        purge(): IPromesse<any>;
        /**
         * Permet de fermer SpiFactory
         *
         * @return boolean true si tout s'est bien passé sinon false
         */
        fermetureSpiFactory(): IPromesse<any>;
        /**
         * Permet de configurer un scanner
         *
         * @param typeScanner le type du scanner à configurer
         *
         * @return boolean true si tout s'est bien passé sinon false
         */
        setConfigurationScanner(typeScanner: string): IPromesse<boolean>;
        /**
         * Traite les messages provenant de l'agent AcquisitionAgent
         *
         * @param event {Event} Evénement
         * @param sendResponseCallback {ResponseCallback} Objet contenant le callback de retour
         *
         */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}

declare module fwkManager.Services.Acquisition {
    interface IAcquisitionApi {
        recuperationImageKofax(fileInfos: IFileInformation[]): IPromesse<any>;
        creerImagesBitonales(base64List: string, ICreerImageBitonalParams: any): IPromesse<any>;
        traitementRADLAD(base64List: string[], params: IRadladParams, authentInfo: Context.AuthentificationInfo): IPromesse<any>;
        convertFileToImg(fileInfo: IFileInformation, params: IConvertFileParams): IPromesse<any>;
        mergerPdfs(fileInfos: IFileInformation[]): IPromesse<any>;
        archiver(putDocumentInput: IPutDocumentInput, authentInfo: Context.AuthentificationInfo): IPromesse<any>;
        convertBase64ToBin(urls: string[]): IPromesse<any>;
        purge(): IPromesse<any>;
        fermetureSpiFactory(): IPromesse<any>;
        setConfigurationScanner(typeScanner: string): IPromesse<any>;
    }
}


declare module fwkManager.Services.Acquisition {
    class AcquisitionApiBase implements IAcquisitionApi {
        constructor();
        recuperationImageKofax(fileInfos: IFileInformation[]): IPromesse<any>;
        creerImagesBitonales(base64List: string, ICreerImageBitonalParams: any): IPromesse<any>;
        traitementRADLAD(base64List: string[], params: IRadladParams, authentInfo: Context.AuthentificationInfo): IPromesse<any>;
        convertFileToImg(fileInfo: IFileInformation, params: IConvertFileParams): IPromesse<any>;
        mergerPdfs(fileInfos: IFileInformation[]): IPromesse<any>;
        archiver(putDocumentInput: IPutDocumentInput, authentInfo: Context.AuthentificationInfo): IPromesse<any>;
        convertBase64ToBin(urls: string[]): IPromesse<any>;
        purge(): IPromesse<any>;
        fermetureSpiFactory(): IPromesse<any>;
        setConfigurationScanner(typeScanner: string): IPromesse<any>;
    }
}


declare module fwkManager.Services.Acquisition {
    class AcquisitionApiFullWeb extends AcquisitionApiBase {
        constructor();
    }
}


declare module fwkManager.Services.Acquisition {
    class AcquisitionApiWindows extends AcquisitionApiBase {
        private _url;
        private _RADLADUrl;
        private _StockageUrl;
        constructor();
        recuperationImageKofax(fileInfos: IFileInformation[]): IPromesse<any>;
        creerImagesBitonales(base64List: string, params: ICreerImageBitonalParams): IPromesse<any>;
        traitementRADLAD(base64List: string[], params: IRadladParams, authentInfo: Context.AuthentificationInfo): IPromesse<any>;
        convertFileToImg(fileInfo: IFileInformation, params: IConvertFileParams): IPromesse<any>;
        mergerPdfs(fileInfos: IFileInformation[]): IPromesse<any>;
        archiver(putDocumentInput: IPutDocumentInput, authentInfo: Context.AuthentificationInfo): IPromesse<any>;
        convertBase64ToBin(urls: string[]): IPromesse<any>;
        purge(): IPromesse<any>;
        fermetureSpiFactory(): IPromesse<any>;
        setConfigurationScanner(typeScanner: string): IPromesse<any>;
    }
}


declare module fwkManager.Services.Application {
    interface IApplicationApi {
        GetApplication(codeApplication: string, authenficationInfo: Context.AuthentificationInfo): IPromesse<ApplicationDTO>;
        Demarrer(application: ApplicationDTO): IPromesse<boolean>;
        Lancer(executableWrapper: Interop.ExecutableWrapper, parametres: string[], sync: boolean): IPromesse<boolean>;
        OuvrirUrl(result: ApplicationDTO, isTotemCapable: boolean): IPromesse<boolean>;
        LancerApplicationClientLourd(result: ApplicationDTO, parametres: string[]): IPromesse<boolean>;
        DemarrerProcessus(result: ApplicationDTO, delegationPortail: boolean): IPromesse<boolean>;
    }
    var TYPE_URL_GET: string;
    var TYPE_URL_POST: string;
    class ApplicationDTO {
        codeTypeApplication: number;
        codeApplication: string;
        codeApplicationMaintenance: number;
        codeEtablissement: string;
        codeExecutableConteneurMyway: number;
        codeClientIdentifie: number;
        libelleDescriptionApplication: string;
        libelleDeviceCompatible: string;
        libelleCheminExecution: string;
        libelleHabilitation: string;
        libelleMessageMaintenance: string;
        libelleNomApplication: string;
        libelleValeurParametre1: string;
        libelleValeurParametre2: string;
        libelleValeurParametre3: string;
        libelleValeurParametre4: string;
        listeApplicationUrlValeur: any[];
    }
}


/**
* Module de gestion des applications
* @module fwkManager.Services.Application
*/
declare module fwkManager.Services.Application {
    /**
    * Classe permettant la gestion des applications
    */
    class ApplicationApiBase extends Component.ComponentApiBase implements IApplicationApi {
        private static CLASS_NAME_BASE;
        private static loggerApplicationApiBase;
        private _localServiceUrl;
        constructor();
        /**
         * [GetApplication description]
         * @param  {string}            codeApplication         Code de l'application à démarrer référencé dans les applications du portail
         * @return {IPromesse<ApplicationDTO>}                 DTO reçu par le SR
         */
        GetApplication(codeApplication: string, authentificationInfo: Context.AuthentificationInfo): IPromesse<ApplicationDTO>;
        Demarrer(application: ApplicationDTO): IPromesse<boolean>;
        Lancer(executableWrapper: Interop.ExecutableWrapper, parametres: string[], sync: boolean): IPromesse<boolean>;
        OuvrirUrl(result: ApplicationDTO, isTotemCapable: boolean): IPromesse<boolean>;
        LancerApplicationClientLourd(result: ApplicationDTO, parametres: string[]): IPromesse<boolean>;
        DemarrerProcessus(result: ApplicationDTO, delegationPortail: boolean): IPromesse<boolean>;
    }
}


/**
* Module de gestion des applications
* @module fwkManager.Services.Application
*/
declare module fwkManager.Services.Application {
    /**
    * Classe permettant la gestion des applications
    */
    class ApplicationApiFullWeb extends ApplicationApiBase {
        private static CLASS_NAME;
        private static logger;
        constructor();
        LancerApplicationClientLourd(result: ApplicationDTO): IPromesse<boolean>;
    }
}


/**
* Module de gestion des applications
* @module fwkManager.Services.Application
*/
declare module fwkManager.Services.Application {
    /**
    * Classe permettant la gestion des applications
    */
    class ApplicationApiWindows extends ApplicationApiBase {
        private static CLASS_NAME;
        private static logger;
        constructor();
    }
}


/**
* Module de gestion des applications
* @module fwkManager.Services.Application
*/
declare module fwkManager.Services.Application {
    /**
    * Classe permettant la gestion des applications
    */
    class ApplicationApiPetra extends ApplicationApiBase {
        private static CLASS_NAME;
        private static logger;
        constructor();
        DemarrerProcessus(result: ApplicationDTO, delegationPortail: boolean): IPromesse<boolean>;
        OuvrirUrl(result: ApplicationDTO): IPromesse<boolean>;
    }
}


/**
* Module de gestion des habilitations
* @module fwkManager.Services.Application
* @author Mathieu Dartigues && Laurie Marchaterre
*/
declare module fwkManager.Services.Application {
    class ApplicationManagerExtended {
        private manager;
        constructor(manager: ApplicationManager);
        Demarrer(codeApplication: string): IPromesse<boolean>;
    }
    /**
    * Classe permettant la gestion des applications
    */
    class ApplicationManager extends Component.ComponentManagerBase {
        private _managerLibrary;
        private contextKey;
        Library: ManagerLibrary;
        private isTotemCapable;
        private delegationPortail;
        private static CLASS_NAME;
        private static logger;
        constructor(managerLibrary: ManagerLibrary, isTotemCapable: boolean, delegationPortail: boolean);
        private remplacerVariablesContexte(chaineCaractere);
        /**
         * Permet d'encoder des paramètres pour les passer à une URL
         * @param  {string[]} params Tableau de paramètres à encoder
         * @return {string}          Chaine de caractères à ajouter à l'url
         */
        private creerUrlAvecParametres(params);
        /**
         * Permet de démarrer une application, en récupérant les données correspondantes
         * et en adoptant la bonne stratégie par rapport au type d'application
         *     - 1 : URL (GET)
         *     - 2 : Fichier de type .pdf/.ica/.doc (avec une URL en http)
         *     - 3 : Application lourde (le Service Local est nécessaire)
         *     - 4 : Processus
         *     - 5 : URL Culturenet
         *
         * @param {string} codeApplication Le code de référence de l'Application
         *
         * ~~~ts
         * // Démarrage de l'application AC1
         * serviceManager.Application.Demarrer('AC1').then((result: boolean) => {
         * ...
         * }).catch((erreur: fwkManager.Services.Erreur) => {
         * ...
         * });
         * ~~~
         * @return {IPromesse<boolean>}
         * Promesse indiquant si oui(true) ou non(false) l'application a correctement démarrée sinon retourne une **erreur**
         *
         * #### Listes des erreurs
         * | codeLibelle                               | libelle                                                        |
         * | ----------------------------------------- |:-------------------------------------------------------------- |
         * | ERREUR_APPLICATION_TYPE_INCONNU           | Le type de l'application n'est pas pris en charge              |
         * | ERREUR_APPLICATION_DEMARRAGE_IMPOSSIBLE   | L'application n'a pas pu être démarrée                         |
         * | ERREUR_APPLICATION_CODE_NON_RENSEIGNE     | Le code de l'application n'est pas renseigné                   |
         * | ERREUR_APPLICATION_MAINTENANCE            | L'application est indisponible temporairement pour maintenance |
         */
        Demarrer(codeApplication: string, delegationPortail?: boolean): IPromesse<boolean>;
        /**
         * Permet de récupérer les informations d'une application,
         * à partir de son code, en appelant l'API correspondante
         * @param {string} codeApplication : Le code de référence de l'application
         * @return {IPromesse<any>} objet contenant les informations de l'application
         */
        private ObtenirInformationsApplication(codeApplication);
        /**
        * Traite les messages provenants de l'agent ApplicationAgent
        * @param event {Event} évènement
        * @param sendResponseCallback {ResponseCallback} objet contenant le callback de retour
        */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}


declare module fwkManager.Services.BriqueCommunication {
    interface IBriqueCommunicationApi {
        connect(pUrl: string, pAuthentificationInfo: Context.AuthentificationInfo): IPromesse<any>;
    }
}


declare module fwkManager.Services.BriqueCommunication {
    var URLBASE_CONFIGURATION: string;
    var TOPIC_CONFIGURATION_GENERALE: string;
    export const enum KaazingCanalType {
        JMS = 0,
    }
    interface KaazingCanal {
        code: string;
        type: KaazingCanalType;
        url: string;
        destination: string;
        parameters?: {
            [key: string]: any;
        };
    }
    interface ICanalControlerReadAndWrite<T> extends ICanalControlerReadOnly<T> {
        writer: (pMessage: T) => void;
    }
    interface ICanalControlerReadOnly<T> extends ICanalControler {
        reader: (pMessage: T) => void;
    }
    interface ICanalControler {
        close: () => void;
    }
    interface ICanalOptions {
        readable: boolean;
        writable: boolean;
    }
    class CanalControlerReadOnly<T> implements ICanalControlerReadOnly<T> {
        close: () => void;
        private _reader;
        private _lastMessage;
        private _hasMessage;
        constructor(close?: () => void);
        reader: (pValue: T) => void;
    }
    class CanalControler<T> extends CanalControlerReadOnly<T> {
        writer: (pValue: T) => void;
        constructor(close?: () => void);
    }
    interface IInfosAgent {
        userid: string;
        login: string;
        lastname: string;
        firstname: string;
        establishment: string;
        online?: boolean;
        onlineStatus?: boolean;
        email?: string;
        mobile?: string;
        persisted?: boolean;
        type: InfosAgentType;
        preferences: any;
    }
    interface IInfosAgentAvailable {
        userid: string;
        login: string;
        label: string;
        establishment: string;
        type: InfosAgentType;
    }
    interface IInfosAgentExpert extends IInfosAgent {
        preferences: {
            expertises: string[];
        };
    }
    export const enum InfosAgentType {
        CLIENT,
        ADVISER,
        EXPERT,
        PROSPECT,
    }
    class BriqueCommunicationApi implements IBriqueCommunicationApi {
        private static CLASS_NAME;
        private static logger;
        /**
         *
         * @param pUrl
         * @param pAuthentificationInfo
         * @return Promesse avec une session Kaazing. Doit mettre ANY car sinon le portal.d.ts doit référencer Kaazing (c'est moche!)
         */
        connect(pUrl: string, pAuthentificationInfo: Context.AuthentificationInfo): IPromesse<any>;
        private generateToken(pAuthentificationInfo);
    }
}


declare module fwkManager.Services.BriqueCommunication {
    class BriqueCommunicationManager extends Component.ComponentManagerBase {
        private static CLASS_NAME;
        private static logger;
        private initialization;
        constructor(library: ManagerLibrary);
        private configuration;
        private configurationEtablissement;
        private AVAILABLE;
        private CONNECTED;
        private TO_DEVICE;
        private FROM_DEVICE;
        private CONFIGURATION_ETABLISSEMENT;
        private agentCourant;
        init(): IPromesse<void>;
        getConfiguration(): KaazingCanal[];
        getConfigurationEtablissement(): KaazingCanal[];
        getInfosAgentCourant(): IInfosAgent;
        private loadConfig;
        private loadConfigEtablissement(pAuthentificationInfo, pDefer);
        private enregistrerAgent();
        setStatutEnLigne(pEstEnLigne: boolean): fwkManager.Services.IPromesse<void>;
        getUtilisateursConnectes(): fwkManager.Services.IPromesse<ICanalControlerReadOnly<IInfosAgentAvailable[]>>;
        getUtilisateurs(): fwkManager.Services.IPromesse<ICanalControlerReadOnly<IInfosAgentAvailable[]>>;
        private sessions;
        private connexionsInProgress;
        private connexionsEnFileDAttente;
        dispose(): IPromesse<void>;
        ouvrirCanal<T>(pUrl: string, pDestination: string, pOptions: ICanalOptions, pAuthentificationInfo: Context.AuthentificationInfo): fwkManager.Services.IPromesse<ICanalControlerReadAndWrite<T>>;
        replaceTokens(pString: string, pValues: {
            [key: string]: string;
        }): string;
        private connect(pUrl, pAuthentificationInfo);
    }
}


declare module fwkManager.Services.BriqueCommunication.Chat {
    interface IChatConnexionMessage {
        chatroom_id: string;
        user_id: string;
        type: string;
        users_ids: string[];
    }
    interface IChatConfirmationConnexionMessage {
        chatroom_id: string;
        user_id: string;
        accepted: boolean;
        type: string;
    }
    interface IWriterChat {
        write: (pMessage: string) => void;
    }
    interface IChatExpertiseMessageBase {
        type: string;
        chatroom_id: string;
        domain: string;
        date: number;
        user_id: string;
    }
    interface IChatExpertiseMessageRequest extends IChatExpertiseMessageBase {
        type: "request";
    }
    interface IChatExpertiseMessageResponse extends IChatExpertiseMessageBase {
        type: "response";
        accepted: boolean;
    }
    interface IVideoroom {
        canal: ICanalControlerReadAndWrite<any>;
        start: () => void;
        stop: () => void;
    }
    interface ChatRoom {
        id: string;
        membres: string[];
        membresObject: {
            [key: string]: boolean;
        };
        myUserId: string;
        close: () => void;
        reader: (pMessage: Messages.IChatMessage) => void;
        writeMessage: (pMessage: string) => void;
        writeResponse: (pEstAccepte: boolean) => void;
        writeEnd: () => void;
        videosrooms: {
            [key: string]: IVideoroom;
        };
        videoroomAjoutee: (IVideoroom: IVideoroom, pUserId: string) => void;
        framePrincipale: string;
        videoEstEnCours: boolean;
        utilisateurConnecte: (pUserId: string) => void;
        utilisateurDeconnecte: (pUserId: string) => void;
    }
}


declare module fwkManager.Services.BriqueCommunication.Chat {
    interface IChatManagerCanauxControleur {
        notifierChangementListeUtilisateurs: (pUtilisateurs: Messages.IUtilisateur[]) => void;
        fermerChatroom: (pChatroomId: string) => void;
        ouvrirChatroom: (pChatroomId: string, pDemandeur: string, pMembresPresents: string[]) => void;
        demanderExpert: (pChatroomId: string, pDomaine: string, pDemandeur: string) => void;
        finDemandeExpert: (pChatroomId: string, pDomaine: string, pExpert: string) => void;
    }
    class ChatManagerCanaux {
        private library;
        private listenerOnChangeAuthentificationInfo;
        private currentCodeAgent;
        private currentCodeEtablissement;
        private doitEcouterMiseAJourListeUtilisateurs;
        private utilisateurs;
        private currentListenerListeUtilisateurs;
        private promessesGetUtilisateursEnAttente;
        private doitEcouterCanalDemandeChat;
        private currentListenerDemandeChat;
        private currentCanauxEcouteExpertises;
        private currentCanauxEcouteExpertisesParDomaine;
        private chatrooms;
        private controleur;
        constructor(library: ManagerLibrary);
        init(pControleur: IChatManagerCanauxControleur): void;
        Dispose(): void;
        closeAndOpenAll(): void;
        getUtilisateurs(): IPromesse<Messages.IUtilisateur[]>;
        getChatrooms(): ChatRoom[];
        ajouterChatroom(pChatroom: ChatRoom): void;
        retirerChatroom(pChatroom: ChatRoom): void;
        getChatRoomById(pIdChat: string): ChatRoom;
        accepterDemandeExpert(pIdChat: string, pDomaine: string, pDemandeur: string): void;
        private ecouterCanauxExpertises();
        private ecouterMiseAJourListeUtilisateurs(pEtablissement);
        private ecouterCanalDeDemande(pCodeAgent);
    }
}


declare module fwkManager.Services.BriqueCommunication.Chat {
    class ChatManagerBase extends Component.ComponentManagerBase {
        private chatManagerCanaux;
        private static CLASS_NAME;
        private static logger;
        private conf_chat_request;
        private conf_chat_request_experts;
        private conf_chat_rooms;
        private storageInstance;
        private storageValue;
        private storageSaveTimeout;
        private initialization;
        constructor(library: ManagerLibrary, chatManagerCanaux: ChatManagerCanaux);
        private sendNotification(pEvent, pOnSend?);
        private getCurrentFramePrincipale();
        init(): IPromesse<void>;
        private load();
        private onChangeStorage;
        private onChangeAuthentificationInfo;
        private addChatroomReader(pChatRoom);
        setChatCapacite(pFrameId: string): void;
        getUtilisateurs(): IPromesse<Messages.IUtilisateur[]>;
        setStatut(pStatut: Messages.UTILISATEUR_STATUT): IPromesse<void>;
        getChatrooms(pFrame: string): IPromesse<Messages.OpenChatResponse[]>;
        getChatroom(pIdChat: string, pFrame: string): IPromesse<Messages.OpenChatResponse>;
        closeChat(pIdChat: string): IPromesse<void>;
        accepterDemandeExpert(pIdChat: string, pDomaine: string, pDemandeur: string, pFrame: string): IPromesse<void>;
        inviterPersonnesAUneChatroom(pIdChat: string, ...pUsers: string[]): IPromesse<void>;
        changerFramePrincipale(pChatroomId: string, pFrame: string): void;
        demarrerVideoChatroom(pChatroomId: string): void;
        arreterVideoChatroom(pChatroomId: string): void;
        openChat(pDestinataire: string, pFrame: string): IPromesse<Messages.OpenChatResponse>;
        openChatroom(pIdChat: string, pFrame: string, ...pMembres: string[]): IPromesse<Messages.OpenChatResponse>;
        private enregistrerVideoroomsOuvertes(pChatroom);
        sendMessage(pIdChat: string, pMessage: string): IPromesse<void>;
        envoyerMessageVideoroom(pChatId: string, pUserId: string, pMessage: string): IPromesse<void>;
        demarrerVideo(pIdChat: string): IPromesse<void>;
        arreterVideo(pIdChat: string): IPromesse<void>;
        private saveStorageValue();
        private ajouterStorageInstance(pChatroom);
        private supprimerStorageInstance(pChatroom_id);
        private getStorageInstance(pChatroom_id);
        ecouterCanalDeDemandeApi(pIdUtilisateur: string): fwkManager.Services.IPromesse<ICanalControlerReadOnly<IChatConnexionMessage>>;
        ecouterCanalExpertiseApi(pDomaine: string): fwkManager.Services.IPromesse<ICanalControlerReadAndWrite<IChatExpertiseMessageBase>>;
        inviterPersonneARejoindreUneChatroomApi(pChatroomId: string, pUserDestinataire: string, pAuthentificationInfo: Context.AuthentificationInfo, ...pMembresConnus: string[]): void;
        openChatApi(pUserDestinataire: string): fwkManager.Services.IPromesse<ChatRoom>;
        openTchatroomApi(pChatroomId: string, ...pMembres: string[]): fwkManager.Services.IPromesse<ChatRoom>;
        private ouvrirCanalVideoApi(pChatRoom, pUserId);
        private generateRoomId();
    }
}


declare module fwkManager.Services.BriqueCommunication.Chat {
    class ChatManager extends ChatManagerBase {
        private promiseAlreadyResolved;
        constructor(library: ManagerLibrary, chatManagerCanaux: ChatManagerCanaux);
        private onAddCapaciteChat(pParameters, pFrame);
        private onSetStatut(pParameters);
        private onCloseChat(pParameters);
        private onOpenChat(pParameters, pFrame);
        private onOpenChatroom(pParameters, pFrame);
        private onSendMessage(pParameters);
        private onAccepterDemandeExpert(pParameters, pFrame);
        private onInviterPersonneAUneChatroom(pParameters);
        private onGetUtilisateurs();
        private onGetChatrooms(pParameters, pFrame);
        private onGetChatroom(pParameters, pFrame);
        private onDemarrerVideoChatroom(pParameters);
        private onArreterVideoChatroom(pParameters);
        private onEnvoyerMessageVideoroom(pParameters);
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}


declare module fwkManager.Services.BriqueCommunication.Chat {
    class ChatManagerExtended {
        private manager;
        constructor(manager: ChatManagerBase);
        closeChat(pIdChat: string): IPromesse<void>;
        openChat(pDestinataire: string): IPromesse<Messages.OpenChatResponse>;
        openChatroom(pIdChat: string): IPromesse<Messages.OpenChatResponse>;
        sendMessage(pIdChat: string, pMessage: string): IPromesse<void>;
        getUtilisateurs(): IPromesse<Messages.IUtilisateur[]>;
    }
}


declare module fwkManager.Services.BriqueCommunication.Notification {
    interface ISubjectConnexion {
        name: string;
        canal: ICanalControlerReadOnly<Messages.INotification>;
    }
    interface ISubjectConfCanal {
        selection: "ALLOWED" | "DEFAULT";
    }
    interface ISubjectConf {
        code: string;
        channels: {
            [key: string]: ISubjectConfCanal;
        };
        name: string;
        description: string;
        family: string;
    }
    interface IParametersConfEtablissement {
        variables: string[];
        subjects: ISubjectConf[];
    }
    class NotificationManagerBase extends Component.ComponentManagerBase {
        private CONF_NOTIFICATIONS;
        private subjetsConnected;
        private subjetsConnectedByName;
        private subjects;
        private subjectsByName;
        private storageInstance;
        private abonnements;
        private initialization;
        constructor(library: ManagerLibrary);
        /**
         * Initialisation du manager
         *
         * @return Promesse d'initialisation
         */
        init(): IPromesse<void>;
        /**
         * Evennement appelé quand le stockage de la configuration change
         *
         * @param pNouvelleValeur Nouvelle valeur dans le stockage
         */
        private onChangeStorage;
        /**
         * Sauvegarde de la configuration courante
         */
        private save();
        /**
         * Envoi une notification
         *
         * @param pEvent Evenement à envoyer
         */
        private sendNotification(pEvent);
        /**
         * Execution de l'inscription à un sujet
         *
         * @param pSubject Nom du sujet
         */
        private _ecouterNotifications(pSubject);
        private _arreterNotifications(pSubject);
        ecouterNotifications(pSubject: string): IPromesse<void>;
        arreterNotifications(pSubject: string): void;
        getListeSujets(): IPromesse<Messages.INotificationMessageListeSujetsResponse>;
        private load;
        ecouterNotificationsApi(pNotificationName: string): IPromesse<ICanalControlerReadOnly<Messages.INotification>>;
    }
}


declare module fwkManager.Services.BriqueCommunication.Notification {
    class NotificationManager extends NotificationManagerBase {
        constructor(library: ManagerLibrary);
        private onAbonnement(pParameters);
        private onDesabonnement(pParameters);
        private onGetSujets();
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}


/**
* Module de gestion des capacités (module commun aux agents et aux managers)
* @module fwkManager.Services.Capacites
*/
declare module fwkManager.Services.Capacites {
    /**
     * Classe de gestion des règles
     */
    class Regles {
        private _managerLibrary;
        private static CLASS_NAME;
        private static logger;
        private _isTotemCapable;
        static URL_SPA_KEY: string;
        static LARGEUR_MINIMALE_MYWAY: number;
        static HAUTEUR_MINIMALE_MYWAY: number;
        constructor(managerLibrary: ManagerLibrary, isTotemCapable: boolean);
        /**
         * Permet de tester une règle (export const enum REGLE) en fonction de critères métiers
         *
         * @param {export const enum} REGLE
         * @return {IPromesse<boolean>} : returne 'true' si on a la capacité de la règle passée en paramètre, sinon 'false'
         */
        resolve(regle: REGLE): IPromesse<boolean>;
    }
}


declare module fwkManager.Services.Capacites {
    class CapacitesManager extends Component.ComponentManagerBase {
        private _managerLibrary;
        Library: ManagerLibrary;
        private static CLASS_NAME;
        private static logger;
        private _isTotemCapable;
        constructor(managerLibrary: ManagerLibrary, isTotemCapable: boolean);
        /**
         * Permet de vérifier si on a la capacité pour une règle donnée.
         * @return {IPromesse<boolean>} : returne 'true' si on a la capacité, sinon 'false'
         */
        getCapacite(regle: REGLE): IPromesse<boolean>;
        /**
        * Traite les messages provenants de l'agent CapacitesAgent
        * @param event {Event} évènement
        * @param sendResponseCallback {ResponseCallback} objet contenant le callback de retour
        */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}


/**
* Module de gestion des moyens de communication
* @module fwkManager.Services.Communication
* @methode controleEnvoyerMail – public - Permet de contrôler l'envoi d'un mail
* @methode controleDeclencherAppel – public - Permet de contrôler le déclenchement d'un appel
*/
declare module fwkManager.Services.Communication {
    /**
    * Permet de contrôler l'envoi d'un mail
    *
    * @param {Mail} mail Le mail à envoyer
    */
    function controleEnvoyerMail(mail: Mail): string;
    /**
    * Permet de contrôler le déclenchement d'un appel
    *
    * @param {Call} call    Les données d'appel
    */
    function controleDeclencherAppel(call: Call): string;
}


/**
* Module de gestion des moyens de communication
* @module fwkManager.Services.Communication
* @classe CommunicationManager - public - Classe permettant la gestion des moyens de communication
*/
declare module fwkManager.Services.Communication {
    class CommunicationManagerExtended {
        private manager;
        constructor(manager: CommunicationManager);
        /**
        * Permet d'envoyer un mail
        *
        * @param mail Mail
        *
        */
        envoyerMail(mail: Mail): IPromesse<string>;
        /**
        * Permet de déclencher un appel
        *
        * @param {Call} call    Données de l'appel
        */
        declencherAppel(call: Call): IPromesse<string>;
        /**
        * Permet de raccrocher un appel
        */
        raccrocherAppel(): IPromesse<string>;
    }
    class CommunicationManager extends Component.ComponentManagerBase {
        private _managerLibrary;
        Library: ManagerLibrary;
        private static CLASS_NAME;
        private static logger;
        /**
         * Constructeur de la classe CommunicationManager
         *
         * @param managerLibrary {ManagerLibrary} La librairie de construction du manager
         *
         */
        constructor(managerLibrary: ManagerLibrary);
        /**
         * Permet d'envoyer un mail
         *
         * @param mail Mail
         *
         */
        envoyerMail(mail: Mail): IPromesse<string>;
        /**
         * Permet de déclencher un appel
         *
         * @param {Call} call    Données de l'appel
         */
        declencherAppel(call: Call): IPromesse<string>;
        /**
        * Permet de raccrocher un appel
        */
        raccrocherAppel(): IPromesse<string>;
        /**
         * Traite les messages provenant de l'agent CommunicationAgent
         *
         * @param event {Event} Evénement
         * @param sendResponseCallback {ResponseCallback} Objet contenant le callback de retour
         *
         */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}


declare module fwkManager.Services.Communication {
    interface INumerotationTelephoniqueApi {
        declencherAppel(call: Call, authentificationInfo: fwkManager.Services.Context.AuthentificationInfo): IPromesse<INumerotationTelephoniqueDTO>;
        raccrocherAppel(authentificationInfo: fwkManager.Services.Context.AuthentificationInfo): IPromesse<INumerotationTelephoniqueDTO>;
    }
}


/**
* Module de gestion des communication
* @module fwkManager.Services.Communication
* classe : NumerotationTelephonique - public - Classe permettant la gestion des appels
*/
declare module fwkManager.Services.Communication {
    /**
    * Classe permettant la gestion des habilitations
    */
    class NumerotationTelephoniqueApi extends Component.ComponentApiBase implements INumerotationTelephoniqueApi {
        private _numerotationTelephoniqueUrl;
        private static CLASS_NAME;
        private static logger;
        constructor();
        /**
         * Permet de déclencher un appel
         *
         * @param  {Call}                                       call        Données de l'appel
         * @param  {AuthentificationInfo}           authentificationInfo        Données personnelles de l'utilisateur
         * @return {IPromesse<INumerotationTelephoniqueDTO>}                DTO reçu par le service REST
         */
        declencherAppel(call: Call, authentificationInfo: fwkManager.Services.Context.AuthentificationInfo): IPromesse<INumerotationTelephoniqueDTO>;
        /**
         * Permet de raccrocher un appel
         *
         * @param  {AuthentificationInfo}           authentificationInfo        Données personnelles de l'utilisateur
         * @return {IPromesse<INumerotationTelephoniqueDTO>}    DTO reçu par le service REST
         */
        raccrocherAppel(authentificationInfo: fwkManager.Services.Context.AuthentificationInfo): IPromesse<INumerotationTelephoniqueDTO>;
    }
}


/**
* Module de gestion des moyens de communication
* @module fwkManager.Services.Communication
* @classe CommunicationAgent - public - Classe permettant la gestion des moyens de communication
*/
declare module fwkManager.Services.Communication {
    class PhantomCommunicationAgent implements ICommunicationAgent {
        private serviceManager;
        /**
         * Constructeur de la classe CommunicationAgent
         *
         * @param agentLibrary {AgentLibrary} La librairie de construction de l'agent
         * @param errorCallback {ErreurCallback} Action à executer en cas d'erreur lors de la construction de l'agent
         *
         */
        constructor(serviceManager: ServiceManager);
        /**
         * Permet d'envoyer un mail
         *
         * @param mail Mail
         *
         */
        envoyerMail(mail: Mail): IPromesse<string>;
        /**
        * Permet de déclencher un appel
        *
        * @param {Call} call    Données de l'appel
        *
        */
        declencherAppel(call: Call): IPromesse<string>;
        /**
        * Permet de raccrocher un appel
        *
        */
        raccrocherAppel(): IPromesse<string>;
    }
}


declare module fwkManager.Services.Context {
    interface ContextKeyValuePair {
        Key: string;
        Value: string;
    }
    class ContextImpl implements IContext {
        globalStorage: IContextKeyValuePair[];
        sharedStorage: IContextKeyValuePair[];
        portals: IPortalContext[];
        waitingProcesses: IProcess[];
        static clone(clonedContext: IContext): ContextImpl;
    }
    class PortalContext implements IPortalContext {
        temporayContextStorage: IContextKeyValuePair[];
        processes: IProcess[];
        isSingle: boolean;
        currentPath: string;
        static clone(clonedPortalContext: IPortalContext): PortalContext;
        static GetPathPart(path: string, pathPart: PATH_PART): string;
        static GetProcessByPath(path: string, processElements: IProcessElement[]): fwkManager.Services.Context.IProcess;
        GetProcess(processId: string): fwkManager.Services.Context.IProcess;
        GetProcessByPathPart(path: string, pathPart: PATH_PART): fwkManager.Services.Context.IProcess;
        GetCurrentProcess(): IProcess;
        GetCurrentMainProcess(): IProcess;
        GetCurrentStep(process: IProcess): IProcessStep;
    }
    class Process implements IProcess {
        id: string;
        icon: string;
        displayName: string;
        contextStorage: IContextKeyValuePair[];
        subElements: IProcessElement[];
        currentInnerElementPath: string;
        putInWaitTime: number;
        type: string;
        knownSteps: string[];
        codeEtape: string;
        codeProcess: string;
        typeProcess: string;
        creationDate: number;
        estApplicationExterne: boolean;
        outputContracts: string[];
        authorizedOutputs: number[];
        isSubProcess: boolean;
        contexteClientId: string;
        lastNextTime: number;
        constructor();
        static clone(clonedProcess: IProcess): Process;
        getPath(): string;
    }
    class ProcessStep implements IProcessStep {
        codeMetier: string;
        parentPath: string;
        id: string;
        codeEtape: string;
        codeApplication: string;
        nomApplication: string;
        contextStorage: IContextKeyValuePair[];
        url: string;
        boundId: string;
        isEnd: boolean;
        nextStep: IProcessStep;
        actions: IStepAction[];
        valeurEntree: number;
        contrats: IStepContrat[];
        type: string;
        processusMaitre: boolean;
        processName: string;
        maintienIFrame: boolean;
        authorizedOutputs: number[];
        etapeResultAsString: string;
        isRouteur: boolean;
        etatEtape: EtatEtape;
        creationDate: number;
        displayTime: number;
        static clone(clonedStep: IProcessStep): ProcessStep;
        static SetValues(step: ProcessStep, currentProcess: Process, nomApplication: string, url: string, actions: Lisa.ActionResult[], contrats: Lisa.ContratResult[], codeApplication: string, codeEtape: string, codeMetier: string, valeurEntree: number, boundId: string, stepOptions: IStepOption, etapeResultAsString: string, etatEtape: EtatEtape, isRouteur: boolean, creationDate: number): void;
        getPath(): string;
    }
    class StepAction implements IStepAction {
        Nom: string;
        CodeEtape: string;
        ValeurSortie: number;
        SurchargeValeurEntree: number;
        NouvelleActivite: boolean;
        EstExterne: boolean;
        Options: string;
        static clone(clonedAction: IStepAction): StepAction;
    }
    class StepContrat implements IStepContrat {
        Code: string;
        Type: string;
        Longueur: number;
        Nullable: boolean;
        Mode: string;
        static clone(clonedContrat: StepContrat): StepContrat;
    }
}


declare module fwkManager.Services.Context {
    class ContextManagerExtended {
        private manager;
        private static CLASS_NAME;
        private static logger;
        constructor(manager: ContextManager);
        AddToContext(levelStr: string, key: string, value: string): boolean;
        GetDonneesLocales(): IPromesse<any>;
        GetAuthentificationInfo(bypassIfNull?: boolean): AuthentificationInfo;
        /**
         * Méthode permettant de récupérer une donnée issue du contexte
         *
         */
        GetFromContext(key: string): string;
        /**
         * Méthode permettant de dédier un processus au portail
         */
        DedierPortail(processId: string): IProcessStep;
        /**
         * Permet de terminer un processus à partir de son id.
         *
         * Bascule l'affichage automatiquement sur le dernier processus actif.
         *
         * Emet un événement de [[Component.ManagerEventType.BasculeProcess]] avec le contexte du portail en paramètre
         *
         * Renvoie une promesse indiquant si la fin de processus s'est bien passée
         *
         */
        TerminerProcess(processId: string): IPromesse<boolean>;
        private TracerTerminerProcessus(process);
        BasculerProcess(processId: string): IPromesse<boolean>;
        ChangerNomProcessPrincipal(nom: string): IPortalContext;
        RemoveWaitingProcesses(): IPortalContext;
        /**
         * wrapper de la méthode AnalyseApp de la class [[ContextManager]]
         */
        AnalyseApp(): IPromesse<AnalyseResult>;
        GetPortalContext(getSingleIfSingle?: boolean): fwkManager.Services.Context.IPortalContext;
        ExtraireProcess(processId: string): IPromesse<boolean>;
    }
    class ContextManager extends Component.ComponentManagerBase implements IContextCommon {
        private static CLASS_NAME;
        private static logger;
        _portalIndex: number;
        _context: IContext;
        private _onPortalContextChanged;
        private _singlePortalContext;
        private _useDiagnostic;
        private _storageNotification;
        Library: ManagerLibrary;
        onProcessNameChanged: (processId: string, name: string) => void;
        constructor(managerLibrary: ManagerLibrary, onPortalContextChanged: (context: fwkManager.Services.Context.IPortalContext, onlyHeader: boolean) => void, useDiagnostic: boolean);
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
        private AddToContextAsync(level, key, value, event, sendResponse);
        private RemoveFromContextAsync(level, key, event, sendResponse);
        private AddListToContextAsync(level, kvp, event, sendResponse, elementId?);
        private GetFromContextAsync(key, event, sendResponse);
        private reinitialisationServiceAgent(event);
        private GetCurrentStepInfoAsync(event, sendResponse);
        private GetListFromContextAsync(keyArray, event, sendResponse);
        private GetAuthentificationInfoAsync(event, sendResponse);
        private GetParametresComptablesAsync(event, sendResponse);
        private GetWaitingProcessesAsync(event, sendResponse);
        private GetCurrentProcessIdAsync(event, sendResponse);
        private GetCurrentStepIdAsync(event, sendResponse);
        GetCurrentMainProcessAsync(event: MessageEvent, sendResponse: Message.ResponseCallback): void;
        private InitSinglePortalContext();
        private static _initContext();
        private static _saveContext(context);
        private SaveContext();
        static AddNewPortalToContext(context: fwkManager.Services.Context.IContext): fwkManager.Services.Context.IContext;
        static CreatePortalContext(): fwkManager.Services.Context.IPortalContext;
        PortalCount: number;
        OnContextStorageChanged(): void;
        DisplayProcesses(nouvelleIframe?: boolean): IPromesse<boolean>;
        DisplayProcessUrl(url: string, mainProcessId?: string, nouvelleIFrame?: boolean): IPromesse<boolean>;
        GetPortalContext(getSingleIfSingle?: boolean): fwkManager.Services.Context.IPortalContext;
        GetCurrentProcessId(): string;
        GetMainProcessId(): string;
        GetCurrentStepId(): string;
        IsSingleProcess(): boolean;
        GetCurrentProcess(): IProcess;
        GetCurrentMainProcess(): fwkManager.Services.Context.IProcess;
        GetParentProcess(process: IProcess): fwkManager.Services.Context.IProcess;
        GetCurrentProcessCode(): string;
        GetProcessById(processId: string, processElements?: IProcessElement[]): fwkManager.Services.Context.IProcess;
        GetAllProcessFromAllPortails(): fwkManager.Services.Context.IProcess[];
        GetProcessByIdFromAllPortails(pProcessId: string): fwkManager.Services.Context.IProcess;
        GetProcessStepById(processStepId: string): fwkManager.Services.Context.IProcessStep;
        GetWaitingProcess(processId: string): fwkManager.Services.Context.IProcess;
        GetCurrentStep(process: IProcess): fwkManager.Services.Context.IProcessStep;
        SetSingleProcess(processId: string): boolean;
        GetWaitingProcesses(): fwkManager.Services.Context.IProcess[];
        getPortails(): Context.IPortalContext[];
        /**
         * Permet de placer le processus en 'waitintProcessus' = processus hors portail
         *  dont l'id est précisé en paramètre
         * @return {fwkManager.Services.Context.IPortalContext}           [description]
         */
        PutProcessInWait(processId: string): fwkManager.Services.Context.IPortalContext;
        /**
         * Appel asynchrone à la méthode [[PutProcessInWait]]
         */
        PutProcessInWaitAsync(processId: string, success: (portalContext: fwkManager.Services.Context.IPortalContext) => void): void;
        PutProcessInPortalContext(processId: string): fwkManager.Services.Context.IPortalContext;
        Notify(notification: NotificationMessage, success: () => void): void;
        Share(processId: string, codeAgent: string, callback: (context: fwkManager.Services.Context.IPortalContext) => void): void;
        PutTaskInPortalContext(taskId: string, callback: (context: fwkManager.Services.Context.IPortalContext) => void, errorCallback: ErreurCallback): void;
        RemoveCurrentPortal(): fwkManager.Services.Context.IPortalContext;
        /**
        * Permet d'ajouter une données au contexte
        *
        * @param level {StorageLevel}
        * @param key {string} nom de la clé de la donnée
        * @param value {string} nom de la valeur de la donnée
        */
        AddToContext(level: StorageLevel, key: string, value: string): boolean;
        RemoveFromContext(level: StorageLevel, key: string): boolean;
        ClearContext(): void;
        GetDonneesLocales(successCallback: () => void, erreurCallback: ErreurCallback): void;
        GetAuthentificationInfo(bypassIfNull?: boolean): AuthentificationInfo;
        getAuthentificationInfo(): IPromesse<AuthentificationInfo>;
        SetContextAuthentificationInfo(authenticationInfo: AuthentificationInfo): void;
        private _getAuthenticationInfoFromContext();
        GetParametresComptables(): ParametresComptables;
        GetInfosUserApi(successCallback: () => void, errorCallback: ErreurCallback): void;
        GetInfosUser(): InfosUserPoste;
        ClearParametresComptables(): void;
        /**
        * Permet d'ajouter une liste de données au contexte
        *
        * @param level {StorageLevel}
        * @param kvp {fwkManager.Services.Context.IContextKeyValuePair[]} Liste de tuple clé/valeur à ajouter au contexte
        * @return {string}
        */
        AddListToContext(level: StorageLevel, kvp: fwkManager.Services.Context.IContextKeyValuePair[], elementId?: string): boolean;
        CheckData(level: StorageLevel, kvps: fwkManager.Services.Context.IContextKeyValuePair[]): void;
        GetLength(value: any): number;
        GetCurrentProcessContextSize(): number;
        GetProcessContextSize(process: IProcess): number;
        RemoveListFromContext(level: StorageLevel, keys: string[], elementId?: string): boolean;
        private _getStorage(level, elementId?);
        setContextClientIdOnProcessus(pContextClientId: string, pProcessus: Context.IProcess, pNotSaveContext?: boolean): void;
        /**
        * Permet de récupérer une donnée depuis le contexte
        * @param key {string} Clé de la donnée
        * @return {string}
        */
        GetFromContext(key: string): string;
        ChangeMainProcessNameAsync(name: string, callback: (context: fwkManager.Services.Context.IPortalContext) => void): void;
        ChangeMainProcessName(name: any): IPortalContext;
        ChangeProcessName(name: string, processId: string): IPortalContext;
        GetCurrentStepInfo(): StepInfoExtended;
        AddProcess(processId: string, nomProcess: string, codeProcess: string, etapesConnues?: string[], options?: IProcessOption, contexteClient?: ContexteClient.ContexteClientClass): void;
        AddSubProcess(processId: string, currentProcess: IProcess, nomProcess: string, codeProcess: string, codeEtape: string, actions: Lisa.ActionResult[], etapesConnues?: string[], options?: IProcessOption, optionsAsEtape?: IStepOption): void;
        GetObjectFromContext(keyArray: string[]): any;
        GetTypedObjectFromContext<T>(template: T): T;
        /**
        * Permet de récupérer une liste de données depuis le contexte
        *
        * @param keyArray {string[]} La liste de clé à récupérer
        * @param useObjectPath {boolean}
        * @param returnEmptyIfNull {boolean}
        * @return {IPromesse<fwkManager.Services.Context.IContextKeyValuePair[]>}
        */
        GetListFromContext(keyArray: string[], useObjectPath?: boolean, returnEmptyIfNull?: boolean): fwkManager.Services.Context.IContextKeyValuePair[];
        AddStepWithResult(etape: Lisa.EtapeResult, url: any, optionsEtape: Context.IStepOption): void;
        AddStep(stepId: string, codeEtape: string, codeApplication: string, codeMetier: string, actions: Lisa.ActionResult[], contrats: Lisa.ContratResult[], nomApplication: string, url: string, valeurEntree: number, stepOptions?: IStepOption, etapeResultAsString?: string): IPortalContext;
        private setAuthorizedOutputs(element, currentProcess, actions);
        SetParentProcessPath(currentProcess: IProcess): void;
        AddBoundStep(previousStep: fwkManager.Services.Context.IProcessStep, stepId: string, displayName: string, url: string, boundId: string, isEnd: boolean): void;
        SwitchToProcess(id: string): boolean;
        SwitchToProcessAsync(id: string, callback: (context: Context.IPortalContext) => void): void;
        SwitchToSubProcess(id: string): IPortalContext;
        SwitchToSubProcessAsync(id: string, callback: (context: Context.IPortalContext) => void): void;
        SwitchToMainProcess(): IPortalContext;
        SwitchToMainProcessAsync(callback: (context: Context.IPortalContext) => void): void;
        SwitchToStep(stepId: string, processId: string): Context.IPortalContext;
        SwitchToCurrentProcess(): Context.IPortalContext;
        SwitchToCurrentProcessAsync(callback: (context: Context.IPortalContext) => void): void;
        RemoveProcess(id: string): fwkManager.Services.Context.IPortalContext;
        RemoveCurrentProcess(): fwkManager.Services.Context.IPortalContext;
        /**
         * Remove all 'waiting Processes' which creationDate is before today 00:00
         */
        RemoveWaitingProcesses(): fwkManager.Services.Context.IPortalContext;
        EndSubProcess(currentPath: string): void;
        private static _removeProcess(context, id);
        private RemoveSubProcessIfSingle(context, id, processElements);
        private RemoveSubProcess(context, id, processElements, parentProcess);
        RemoveCurrentStep(codeEtape?: string): IPortalContext;
        RemoveStep(stepId: string, processId: string): fwkManager.Services.Context.IPortalContext;
        ChangePortalIndex(portalIndex: number): fwkManager.Services.Context.IPortalContext;
        AddAndGetNewPortal(): fwkManager.Services.Context.IPortalContext;
        AddNewPortal(): number;
        GetPortalIndex(): number;
        ClearCurrentPath(): void;
        private _getObjectPropFromContext(path, returnEmptyIfNull?);
        private _getFromContext(key, returnEmptyIfNull?);
        private _clearTempoContext();
        private _addToContextArray(context, kvp);
        private _getFromContextArray(context, key);
        private _removeFromContextArray(context, key);
        private _getStepById(currentProcess, id);
        private _getStepIndexById(currentProcess, id);
        private _getIndexesByBoundId(currentProcess, boundId);
        SendPortalContext(onlyHeader: boolean, reason: string): void;
        AnalyseApp(callback: (result: AnalyseResult) => void): void;
        SetPortalInformation(): IPromesse<any>;
    }
}


declare module fwkManager.Services.Context {
    interface IContextApi {
        GetDonneesLocales(callback: (donneesLocales: Context.DonneesLocales) => void, errorCallback: ErreurCallback): any;
        ShareProcess(sharedProcess: Context.IProcess, codeAgent: string, callback: () => void, errorCallback: ErreurCallback): any;
        RemoveProcess(taskId: string, callback: (process: Context.IProcess) => void, errorCallback: ErreurCallback): any;
        GetInfosUserApi(callback: (infoUser: Context.InfosUserPoste) => void, errorCallback: ErreurCallback): any;
        GetPortalInformation(authentificationInfo: AuthentificationInfo): IPromesse<any>;
    }
}


declare module fwkManager.Services.Context {
}


declare module fwkManager.Services.Context {
    class ContextApiBase extends Component.ComponentApiBase implements IContextApi {
        constructor();
        GetDonneesLocales(callback: (donneesLocales: Context.DonneesLocales) => void, errorCallback: ErreurCallback): void;
        ShareProcess(sharedProcess: Context.IProcess, codeAgent: string, callback: () => void, errorCallback: ErreurCallback): void;
        RemoveProcess(taskId: string, callback: (process: Context.IProcess) => void, errorCallback: ErreurCallback): void;
        GetInfosUserApi(callback: (infosUser: Context.InfosUserPoste) => void, errorCallback: ErreurCallback): void;
        GetPortalInformation(authentificationInfo: AuthentificationInfo): IPromesse<any>;
    }
}


declare module fwkManager.Services.Context {
    class ContextApiWindows extends ContextApiBase {
        private static CLASS_NAME;
        private static logger;
        constructor();
        GetDonneesLocales(callback: (donneesLocales: Context.DonneesLocales) => void, errorCallback: ErreurCallback): void;
        ShareProcess(sharedProcess: Context.IProcess, codeAgent: string, callback: () => void, errorCallback: ErreurCallback): void;
        RemoveProcess(taskId: string, callback: (process: Context.IProcess) => void, errorCallback: ErreurCallback): void;
        GetInfosUserApi(callback: (infosUser: Context.InfosUserPoste) => void, errorCallback: ErreurCallback): void;
    }
}


declare module fwkManager.Services.Context {
    class ContextApiFullWeb extends ContextApiBase {
        constructor();
        GetDonneesLocales(callback: (donneesLocales: Context.DonneesLocales) => void, errorCallback: ErreurCallback): void;
        ShareProcess(sharedProcess: Context.IProcess, codeAgent: string, callback: () => void, errorCallback: ErreurCallback): void;
        RemoveProcess(taskId: string, callback: (process: Context.IProcess) => void, errorCallback: ErreurCallback): void;
        GetInfosUserApi(callback: (infosUser: Context.InfosUserPoste) => void, errorCallback: ErreurCallback): void;
    }
}


declare module fwkManager.Services.Context {
    class PhantomContextAgent implements IContextAgent {
        private serviceManager;
        constructor(serviceManager: fwkManager.Services.ServiceManager);
        VersionComposant: string;
        AddToContext(key: string, value: string): IPromesse<any>;
        AddToMainProcessContext(key: string, value: string): IPromesse<any>;
        AddListToContext(kvp: fwkManager.Services.Context.IContextKeyValuePair[]): IPromesse<any>;
        GetFromContext(key: string): IPromesse<string>;
        GetObjectFromContext<T>(keyArray: string[]): IPromesse<any>;
        GetTypedObjectFromContext<T>(template: T): IPromesse<T>;
        GetListFromContext(keyArray: string[]): IPromesse<fwkManager.Services.Context.IContextKeyValuePair[]>;
        GetAuthentificationInfo(): IPromesse<AuthentificationInfo>;
        getAuthentificationInfo(): IPromesse<AuthentificationInfo>;
        sendNotification(notification: NotificationMessage, event?: MessageEvent, sendResponseCallback?: Message.ResponseCallback): void;
        GetParametresComptables(): IPromesse<ParametresComptables>;
        Redirect(url?: string, previousUrl?: string): IPromesse<any>;
        GetWaitingProcesses(): IPromesse<fwkManager.Services.Context.IProcess[]>;
        PutProcessInPortalContext(processId: string): IPromesse<any>;
        PutTaskInPortalContext(taskId: string): IPromesse<any>;
        GetCurrentProcessId(): IPromesse<string>;
        GetCurrentStepId(): IPromesse<string>;
        reinitialisationServiceAgent(pIdGenere: string): IPromesse<void>;
        GetCurrentStepInfo(): IPromesse<Context.StepInfoExtended>;
        SetMyWayCompatible(): IPromesse<boolean>;
        SubscribeToNotification(onNotification: {
            (notification: NotificationMessage, serviceAgent?: IServiceAgent): void;
        }[], serviceAgent: IServiceAgent): IPromesse<any>;
        retirerListenerNotification(onNotificationASupprimer: (notification: NotificationMessage, agent?: IServiceAgent) => void): void;
        AnalyseApp(): AnalyseResult;
        ChangeMainProcessName(name: string): IPromesse<any>;
        AddToSharedContext(key: string, value: string): IPromesse<any>;
        RemoveFromSharedContext(key: string): IPromesse<any>;
        StepInfo: StepInfoExtended;
        ErreurCallback: ErreurCallback;
        SetContextListener(key: string, callback: () => void): void;
    }
}


declare module fwkManager.Services.ContexteClient {
    class ContexteClientManagerBase extends Component.ComponentManagerBase {
        static RELOAD_FLAG_NAME: string;
        static RELOAD_FLAG_VALUE_NONE: string;
        static RELOAD_FLAG_VALUE_SYNCHRO: string;
        static RELOAD_FLAG_VALUE_RELOAD: string;
        private static CLASS_NAME_BASE;
        private static loggerContexteClientManagerBase;
        private contextes;
        private contextesById;
        private storage;
        constructor(managerLibrary: ManagerLibrary);
        private listenerOnContexteChange;
        nouveauContexte(pIdClient?: string): ContexteClientClass;
        getByIdClient(pIdClient?: string): ContexteClientClass;
        getCurrentContexteClient(): ContexteClientClass;
        setCurrentContexteClient(pContexteClient: ContexteClientClass): void;
        getContexte(pId: string): ContexteClientClass;
        getContextes(): ContexteClientClass[];
        detruireContexte(pExpediteur: string, pId: string): boolean;
        changeTousContexteMode(pMode: Messages.ContexteClientMode): void;
        getClient(pIdContexteClient?: string): string;
        setClient(pExpediteur: string, client: string, pIdContexteClient?: string): boolean;
        getContextesParClients(): string[];
        addToList(pExpediteur: string, pProperty: string, pValue: any, pIdContexteClient?: string): IPromesse<boolean>;
        getContenu(pIdClient: string): IPromesse<any>;
        getProperty(pProperty: string, pIdContexteClient?: string): IPromesse<any>;
        setContenu(pExpediteur: string, pIdClient: string, pValue: any): IPromesse<boolean>;
        setProperty(pExpediteur: string, pProperty: string, pValue: any, pIdContexteClient?: string): IPromesse<boolean>;
        removeFromList(pExpediteur: string, pProperty: string, pIdContexteClient?: string): IPromesse<boolean>;
        deleteProperty(pExpediteur: string, pProperty: string, pIdContexteClient?: string): IPromesse<boolean>;
        notifierRechargementContexte(): void;
        changeContexteOfProcess(pExpediteur: string, pCodeProcessus: string, pIdContexteClient: string): void;
        getMode(pIdContexteClient?: string): Messages.ContexteClientMode;
        changeContexteMode(pIdContexteClient: string, pMode: Messages.ContexteClientMode): void;
        changeContexteModes(pIdsContexteClient: string[], pMode: Messages.ContexteClientMode): void;
        getListeProcessus(pIdContexteClient?: string): Context.IProcess[];
        getDetailsContexte(pIdContexte: string): Messages.ITechActionGetDetailsContextResponse;
        protected getCurrentContexteOrById(pIdContexte?: string): ContexteClientClass;
        protected getCurrentContexteOrByIdAndThrowIfNothing(pIdContexte?: string): ContexteClientClass;
        private save();
        private load(pTousLesContextes?);
        protected broadcastUpdateEvent(cle: string, sender: string, contexteClient: ContexteClientClass, type: Messages.MiseAJourContexteClientType): void;
        protected broadcastUpdateEventByProcess(cle: string, sender: string, pProcess: Context.IProcess[], type: Messages.MiseAJourContexteClientType): void;
    }
}


declare module fwkManager.Services.ContexteClient {
    class ContexteClientManager extends ContexteClientManagerBase {
        private static CLASS_NAME;
        private static logger;
        constructor(managerLibrary: ManagerLibrary);
        private onGetContextesParClients();
        private onGetId();
        private onGetClient();
        private onSetClient(pParameters);
        private onGetContenu(pParameters);
        private onGetProperty(pParameters);
        private onAddToList(pParameters);
        private onSetContenu(pParameters);
        private onSetProperty(pParameters);
        private onRemoveFromList(pParameters);
        private onDeleteProperty(pParameters);
        private onGetContextes();
        private onDestroyContext(pParameters);
        private onNewContexte(pParameters);
        private onChangeContexteProcess(pParameters);
        private onChangeContexteMode(pParameters);
        private onDetailsContexte(pParameters);
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}


declare module fwkManager.Services.ContexteClient {
    class ContexteClientManagerExtended {
        private manager;
        constructor(manager: ContexteClientManager);
        /**
        * Permet la création d'un contexte client sur un client donné transmis par son id
        *
        * @param pIdClient {string} id du client
        * @return L'id technique du contexte client créé (ou mergé)
        */
        nouveauContexte(pIdClient?: string): string;
        /**
        * Permet la destruction d'un contexte client
        *
        * @param pId {string} id du contexte client
        * @return True si le contexte client a bien été détruit, false sinon
        */
        detruireContexte(pId: string): boolean;
        /**
         * Change le contexte client d'un processus
         *
         * @param pIdContexteClient Identifiant du contexte client. Passer "null" pour retirer le processus de tout contexte client
         * @param pIdProcessus Identifiant du processus à modifier
         */
        changerContexteClientDunProcessus(pIdContexteClient: string, pIdProcessus: string): void;
        /**
         * Récupère le client d'un contexte
         *
         * @param pIdContexteClient Identifiant du contexte client.
         * @return Identifiant du client
         */
        getClientDuContexte(pIdContexteClient: string): string;
        /**
         * Modifie le client d'un contexte. Ne peut modifier le client d'un contexte qui a déjà un client
         *
         * @param pIdContexteClient Identifiant du contexte client.
         * @param pIdClient Identifiant du client.
         * @return TRUE si ça s'est bien passé, FALSE sinon
         */
        setClientDuContexte(pIdContexteClient: string, pIdClient: string): boolean;
        /**
         * Récupère le mode du contexte client (AUTOMATIQUE ou MANUEL)
         *
         * @param pIdContexteClient Identifiant du contexte client.
         * @return Le mode du contexe
         */
        getModeDuContexte(pIdContexteClient: string): Messages.ContexteClientMode;
        /**
         * Modifie le mode du contexte client (AUTOMATIQUE ou MANUEL)
         *
         * @param pIdContexteClient Identifiant du contexte client.
         * @param pMode Nouveau mode
         */
        setModeDuContexte(pIdContexteClient: string, pMode: Messages.ContexteClientMode): void;
        /**
         * Permet la récupération de l'ensemble des ids techniques des contextes clients
         *
         * @param pIdContexteClient Identifiant du contexte client.
         * @return Liste des ids contextes clients
         */
        getContextes(): string[];
        /**
         * Permet de connaître l'ensemble des processus attachés à un contexte client
         *
         * @param pIdContexteClient Identifiant du contexte client.
         * @return Liste des ids des processus
         */
        getProcessusDuContexte(pIdContexteClient: string): string[];
        /**
         * Permet de connaitre la valeur d'une propriété d'un contexte client
         *
         * @param pIdContexteClient Identifiant du contexte client.
         * @param pPropriete Propriété à lire. Passer "null" pour connaitre tout le contenu du contexte client
         * @return Valeur de la propriété
         */
        getProprieteDuContexte(pIdContexteClient: string, pPropriete?: string): IPromesse<any>;
        /**
         * Permet de modifier la valeur d'une propriété d'un contexte client
         *
         * @param pIdContexteClient Identifiant du contexte client.
         * @param pPropriete Propriété à lire. Passer "null" pour connaitre tout le contenu du contexte client
         * @param pValeur Nouvelle valeur
         * @return TRUE si ça s'est bien passé, FALSE sinon
         */
        setProprieteDuContexte(pIdContexteClient: string, pPropriete: string, pValeur: any): IPromesse<boolean>;
        /**
         * Permet de modifier la valeur d'une lsite d'un contexte client
         *
         * @param pIdContexteClient Identifiant du contexte client.
         * @param pPropriete Propriété à lire
         * @param pValeur Nouvelle valeur
         * @return TRUE si ça s'est bien passé, FALSE sinon
         */
        ajouterAListeDuContexte(pIdContexteClient: string, pPropriete: string, pValeur: any): IPromesse<boolean>;
        /**
         * Permet de retirer une valeur d'une liste d'un contexte client
         *
         * @param pIdContexteClient Identifiant du contexte client.
         * @param pPropriete Propriété à retirer
         * @return TRUE si ça s'est bien passé, FALSE sinon
         */
        retirerDeListeDuContexte(pIdContexteClient: string, pPropriete: string): IPromesse<boolean>;
        /**
         * Permet de supprimer une valeur d'une propriété d'un contexte client
         *
         * @param pIdContexteClient Identifiant du contexte client.
         * @param pPropriete Propriété à supprimer. Passer "null" pour vider tout le contexte client.
         * @return TRUE si ça s'est bien passé, FALSE sinon
         */
        supprimerProprieteDuContexte(pIdContexteClient: string, pPropriete?: string): IPromesse<boolean>;
    }
}


declare module fwkManager.Services.ContexteClient {
    class ContexteClientClass {
        private coreCommon;
        private contexteClientManager;
        private id;
        private client;
        private contexte;
        private mode;
        private processus;
        constructor(pId: string, coreCommon: CoreCommon, contexteClientManager: ContexteClientManagerBase);
        getId(): string;
        getMode(): Messages.ContexteClientMode;
        setMode(pMode: Messages.ContexteClientMode): void;
        getProcessus(): Context.IProcess[];
        ajouterProcessus(pProcessus: Context.IProcess): void;
        retirerProcessus(pProcessus: Context.IProcess): boolean;
        private checkSiDoitDetruireContexteClient();
        getClient(): string;
        setClient(pClient: string): void;
        getCurrentDatas(): any;
        /**
         * Lis une donnée du contexte client
         */
        getProperty(pCle: string): IPromesse<any>;
        /**
         * Ajoute une donnée dans un tableau du contexte client
         */
        addToList(pCle: string, pValeur: any): IPromesse<boolean>;
        /**
         * Fixe une donnée dans un objet du contexte client
         */
        setProperty(pCle: string, pValeur: any): IPromesse<boolean>;
        /**
         * Supprime une donnée d'un objet du contexte client
         */
        removeFromList(pCle: string): IPromesse<boolean>;
        /**
         * Supprime une donnée d'un tableau du contexte client
         */
        deleteProperty(pCle: string): IPromesse<boolean>;
        detruireContexte(): void;
    }
}


declare module fwkManager.Services.ContexteClient {
    interface IContexteClientApi {
        SetContexteClientNSDK(numeroClient: string, contexteClient: any): IPromesse<boolean>;
    }
}


declare module fwkManager.Services.ContexteClient {
    class ContexteClientApiWindows implements IContexteClientApi {
        SetContexteClientNSDK(numeroClient: string, contexteClient: any): IPromesse<boolean>;
        _setContexteClientNSDK(numeroClient: string, contexteClient: any): IPromesse<boolean>;
        _reloadNSDK(numeroClient: string): IPromesse<boolean>;
    }
}


declare module fwkManager.Services.ContexteClient {
    class ContexteClientApiFullWeb implements IContexteClientApi {
        SetContexteClientNSDK(numeroClient: string, contexteClient: any): IPromesse<boolean>;
    }
}


declare module fwkManager.Services.BaseDeDonnees {
    class BaseDeDonneesManager extends Component.ComponentManagerBase {
        private _managerLibrary;
        Library: ManagerLibrary;
        constructor(managerLibrary: ManagerLibrary);
        private tablesToMessage(pTables);
        private getImplementation(pBase);
        private internalGetBases();
        private getBases();
        private getBase(pBase);
        private onGetBases();
        private onDbUpgrade(pParametres);
        private onGet(pParametres);
        private onGetAll(pParametres);
        private extractCritere(pCritere);
        private onFind(pParametres);
        private onCount(pParametres);
        private onAjouter(pParametres);
        private onSupprimer(pParametres);
        private onModifier(pParametres);
        private onResetAll();
        /**
        * Traite les messages provenants de l'agent BaseDeDonneesAgent
        * @param event {Event} évènement
        * @param sendResponseCallback {ResponseCallback} objet contenant le callback de retour
        */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}

declare module fwkManager.Services.BaseDeDonnees.Generique {
    /** Types de base de données possible */
    export const enum TYPE_BASE {
        MEMORY = 2,
        LOCALSTORAGE = 3,
    }
    /** Types de base de données déterminés (permet d'éviter de changer une implémentation en cours de route) */
    var typeBase: {};
    /** Types de capacité pour les enregistrements */
    export const enum CAPACITE {
        VOLATILE = 1,
        MONO_ENREGISTREMENT = 2,
        MULTI_ENREGISTREMENT = 3,
    }
    /** Interface de paramètre pour faire un reset des bases de données */
    interface IResetParameters {
        /** Si TRUE alors les bases de données persistantes seront remises à zero. Sinon seul le chargement en mémoire sera vidé */
        supprimerBasesPersistantes?: boolean;
        /** Liste des bases de données à supprimer. Permet d'ajouter des bases qui n'ont pas encore été utilisées */
        bases?: string[];
    }
    /** Classe FACTORY pour gérer les implémentation de base de données */
    class Factory {
        private static CLASS_NAME;
        private static logger;
        static testImplementationIndexeddb(): IPromesse<boolean>;
        /**
         * Remise à zéro des bases de données
         * @param pParams Paramètres
         * @return Une promesse qui indique quand la suppression est terminée
         */
        static remiseAZeroBasesDeDonnees(pParams?: IResetParameters): IPromesse<void>;
        /**
         * Connaitre la liste des types de base possible
         * @return Liste des types de base
         */
        static getTypesBases(): Array<TYPE_BASE>;
        /**
         * Récupération des implémentations par capacité
         * @return La liste demandée
         */
        static getTypesBasesParCapacite(): Array<{
            capacite: CAPACITE;
            type: TYPE_BASE;
        }>;
        /**
         * Extrait le nom d'une base de données à partir de son type
         * @return Le nom demandé
         */
        static getNomTypeBase(pType: TYPE_BASE): string;
        static baseDeDonneesDisponible(pTypeDB: CAPACITE): boolean;
        static getTypeBasesParCapacite(pTypeDB: CAPACITE): TYPE_BASE;
        private static getTypeChoisis(pTypeDB);
        static getImplementationBaseUpgrade(pInstanceBase: IDBBase, pTypeDB: CAPACITE): IDBBaseUpgradeImplementation;
        static getImplementationBase(pInstanceBase: IDBBase, pTypeDB: CAPACITE): IDBBaseImplementation;
        static getImplementationTable<Pk, T>(pBase: IDBBase): IDBTableImplementation<Pk, T>;
    }
}


declare module fwkManager.Services.BaseDeDonnees.Generique.Utilities {
    export const enum MODE_OUVERTURE_BASE {
        LECTURE = 0,
        ECRITURE = 1,
    }
    var tablesOuvertesObjet: {
        [key: string]: IBaseOuverte;
    };
    interface IBaseOuverte {
        base: IDBBase;
        tables: Array<IDBTable<any, any>>;
        tablesObjet: {
            [key: string]: ITableOuverte;
        };
    }
    interface ITableOuverte {
        table: IDBTable<any, any>;
        estOuverteEnEcriture: boolean;
        enCoursDeLecture: number;
        attentesDEcriture: Array<() => void>;
        attentesDeLecture: Array<() => void>;
    }
    interface IDBBaseConnexion {
        connexionBase: (pBase: IDBBase, pMode: MODE_OUVERTURE_BASE, pTables: IDBTable<any, any>[]) => IPromesse<IDBConnexion>;
    }
    class Donnees {
        static calculerTailleDonnee(pData: any): number;
        static compareValues(pValeur1: any, pValeur2: any): number;
    }
    function tracer(pBaseNom: string, loggerObject: Loggers.ILogger, pNiveau: Loggers.LEVEL, pTrace: string, ...pArgs: any[]): void;
    class Connexion {
        private static listenersConnexionsTerminees;
        private static CLASS_NAME;
        private static logger;
        static avertirTouteConnexionTerminee(): IPromesse<void>;
        static updateBase(pBase: IDBBase, pVersionCourante: number, pConnexion: IDBConnexion): IPromesse<IDBConnexion>;
        static ouvrireBase(pTables: Array<IDBTable<any, any>>, pMode: MODE_OUVERTURE_BASE, pDBBaseImpl: IDBBaseConnexion): IPromesse<IDBConnexion>;
        static connexionsBasesEnCours: {
            [key: string]: Array<() => void>;
        };
        static debloquerConnexion(pBase: IDBBase): void;
        private static actionOuvrirBase(pTables, pMode, pDefer, pDBBaseImpl);
        private static connexionSuivante(pTables);
        private static checkLecturesEcrituresEnCours();
    }
}


declare module fwkManager.Services.BaseDeDonnees.Generique.Impl.Memory {
    var reset: (pParams?: IResetParameters) => IPromesse<void>;
    class MemoryStorage {
        private _storage;
        getBase(pNom: string): MemoryBase;
        creerBase(pNom: string): MemoryBase;
        supprimerBase(pNom: string): void;
        getBases(): string[];
    }
    class MemoryBase {
        private _nom;
        private _version;
        private _tables;
        private _tablesParIndex;
        constructor(pNom: string);
        nom: string;
        version: number;
        getTable(pNom: string): MemoryTable<any, any>;
        getTables(): MemoryTable<any, any>[];
        creerTable(pNom: string, pParams: MemoryTableParametres): MemoryTable<any, any>;
        supprimerTable(pNom: string): MemoryTable<any, any>;
        setTable(pTable: MemoryTable<any, any>): MemoryTable<any, any>;
    }
    interface MemoryTableParametres {
        cleAutoincrement?: boolean;
        clePath?: string;
        autoIncrementValue?: number;
    }
    class MemoryTable<Pk extends string | number, T> {
        private _nom;
        private _cleEstAutoincrement;
        private _clePath;
        private _donnees;
        private _indexes;
        private _indexesStorage;
        private _autoincrementValeur;
        indexes: IIndex[];
        primaryKey: AbstractCleType;
        constructor(pNom: string, pParams: MemoryTableParametres);
        private rechercherSurClePrimaire;
        private rechercherSurIndex(pIndex);
        nom: string;
        autoincrementValeur: number;
        private clone(pElement);
        ajouter(pValeur: T, pRowId?: number): Pk;
        ajouterAndFixRowId(pValeur: T, pRowId: number, pValeurAutoincrement: number): void;
        supprimer(pCle: Pk): T;
        supprimerRowId(pRowId: number): T;
        mettreAJour(pValeur: T, pCle?: Pk): T;
        mettreAJourParRowid(pValeur: T, pRowId: number): T;
        get(pCle: Pk): T;
        count(pCriteres?: RequeteCritere): number;
        find(pCriteres?: RequeteCritere, pMax?: number): DatabaseEntry<Pk, T>[];
        ajouterIndex(pIndex: IIndex): void;
        supprimerIndex(pNom: string): IIndex;
        getRowId(pPk: Pk): number;
    }
    var database: MemoryStorage;
    class AbstractDBImplementation {
        protected dbBase: IDBBase;
        protected typeBase: TYPE_BASE;
        constructor(dbBase: IDBBase);
    }
    class DBBaseImplementation extends AbstractDBImplementation implements IDBBaseImplementation, Utilities.IDBBaseConnexion {
        connexionBase(pBase: IDBBase, pMode: Utilities.MODE_OUVERTURE_BASE, pTables: IDBTable<any, any>[]): IPromesse<IDBConnexion>;
        getTailleBase(pBase: IDBBase): IPromesse<number>;
        forcerRecalculTailleBase(pBase: IDBBase): IPromesse<number>;
        private verifierOrigineTablesAOuvrir(pTables);
        ouvrirEnLecture(...pTables: Array<IDBTable<any, any>>): IPromesse<IDBConnexion>;
        ouvrirEnEcriture(...pTables: Array<IDBTable<any, any>>): IPromesse<IDBConnexion>;
        getTables(pBase: IDBBase): IPromesse<Array<IDBTable<any, any>>>;
    }
    class DBBaseUpgradeImplementation extends AbstractDBImplementation implements IDBBaseUpgradeImplementation {
        ajouterTable(pConnexion: IDBConnexion, pBase: IDBBase, pNom: string, pCle: AbstractCleType, pIndexs?: Array<IIndex>): void;
        supprimerTable(pConnexion: IDBConnexion, pBase: IDBBase, pNom: string): void;
        ajouterIndexs(pConnexion: IDBConnexion, pBase: IDBBase, pNomTable: string, pIndexs: Array<IIndex>): void;
        supprimerIndexs(pConnexion: IDBConnexion, pBase: IDBBase, pNomTable: string, pIndexs: Array<string>): void;
        upgradeEtFixVersion(pBase: IDBBase, pMisesAJour: messages.DB_UPGRADE_ACTION[], pVersion: number): IPromesse<void>;
    }
    class DBTableImplementation<Pk, T> extends AbstractDBImplementation implements IDBTableImplementation<Pk, T> {
        count(pConnexion: IDBConnexion, pTable: IDBTable<Pk, T>, pCriteres?: RequeteCritere): IPromesse<number>;
        ajouter(pConnexion: IDBConnexion, pTable: IDBTable<Pk, T>, pObjet: T): IPromesse<Pk>;
        supprimer(pConnexion: IDBConnexion, pTable: IDBTable<Pk, T>, pCle: Pk): IPromesse<void>;
        mettreAJour(pConnexion: IDBConnexion, pTable: IDBTable<Pk, T>, pCle: Pk, pNouvelleValeur: T): IPromesse<void>;
        getParId(pConnexion: IDBConnexion, pTable: IDBTable<Pk, T>, pCle: Pk): IPromesse<T>;
        findParCriteres(pConnexion: IDBConnexion, pTable: IDBTable<Pk, T>, pCriteres: RequeteCritere, pMax?: number): IPromesse<DatabaseEntry<Pk, T>[]>;
        getAll(pConnexion: IDBConnexion, pTable: IDBTable<Pk, T>): IPromesse<DatabaseEntry<Pk, T>[]>;
    }
}


/**
 * Base d'implémentation de model de bae de données
 */
declare module fwkManager.Services.BaseDeDonnees.Generique.Model {
    /**
     * Implémentation par défaut de l'interface IDBBase
     */
    class DBBase implements IDBBase {
        private _nom;
        private _version;
        private _capacite;
        private _dbImpl;
        private _dbUpgradeImpl;
        /**
         * Constructeur
         *
         * @param nom Nom de la base de données
         * @param version Version courante de la base de données
         * @param dbImpl Implémentation d'accès à la base de données pour les opérations "classiques"
         * @param dbUpgradeImpl Implémentation d'accès à la base de données pour les opérations de mise à jour de schéma de base
         */
        constructor(_nom: string, _version: number, _capacite: CAPACITE);
        mettreAJour(pVersionActuelle: number, pVersionVoulue: number): Array<IMiseAJourBase>;
        nom: string;
        version: number;
        capacite: CAPACITE;
        dbImpl: IDBBaseImplementation;
        protected dbUpgradeImpl: IDBBaseUpgradeImplementation;
    }
    /**
     * Implémentation par défaut de l'interface IDBTable
     */
    class DBTable<Pk, T, B extends IDBBase> implements IDBTable<Pk, T> {
        private _base;
        private _nom;
        private _primaryKey;
        private _indexes;
        protected _dbImpl: IDBTableImplementation<Pk, T>;
        constructor(_base: B, _nom: string, _primaryKey: AbstractCleType, _indexes: IIndex[]);
        primaryKey: AbstractCleType;
        indexes: IIndex[];
        protected dbImpl: IDBTableImplementation<Pk, T>;
        base: B;
        nom: string;
    }
    /**
     * Seconde implémentation par défaut de l'interface IDBTable avec un CRUD public
     */
    class DBTableAvecCRUD<Pk, T, B extends IDBBase> extends DBTable<Pk, T, B> {
        constructor(base: B, nom: string, primaryKey: AbstractCleType, indexes: IIndex[]);
        count(pCriteres?: RequeteCritere): IPromesse<number>;
        ajouter(pObjet: T): IPromesse<Pk>;
        supprimer(pCle: Pk): IPromesse<void>;
        mettreAJour(pCle: Pk, pNouvelleValeur: T): IPromesse<void>;
        getParId(pCle: Pk): IPromesse<T>;
        getAll(): IPromesse<Array<CleValeur<Pk, T>>>;
        findParCriteres(pCriteres: RequeteCritere): IPromesse<Array<CleValeur<Pk, T>>>;
    }
}

declare module fwkManager.Services.BaseDeDonnees.Generique {
    class DBBaseTechnique extends Generique.Model.DBBase {
        static DB_VERSION: number;
        static DB_NAME: string;
        private _tableTailleDB;
        private _dbImplTableTailleDB;
        constructor();
        mettreAJour(pVersionActuelle: number, pVersionVoulue: number): Array<IMiseAJourBase>;
        setDbImplTableTailleDB(pDbImpl: IDBTableImplementation<string, TailleDB.ITailleDBEnregistrement>): void;
        tableTailleDB: TailleDB.DBBaseTechniqueTableTailleDB;
    }
    var dbTechnique: DBBaseTechnique;
}

declare module fwkManager.Services.BaseDeDonnees.Generique.TailleDB {
    class TailleAlerte {
        static DBTailleBase: {
            [key: string]: ITailleDBEnregistrement;
        };
        static retirerTousLesListeners(): void;
        static ajouterListenerGlobal(pListener: (pTypeBase: TYPE_BASE, pTaille: number, pSeuilAlerte: number) => void): void;
        static retirerListenerGlobal(pListener: (pTypeBase: TYPE_BASE, pTaille: number, pSeuilAlerte: number) => void): void;
        static ajouterListenerBase(pNom: string, pListener: (pTypeBase: TYPE_BASE, pNom: string, pTaille: number, pSeuilAlerte: number) => void): void;
        static retirerListenerBase(pNom: string, pListener: (pTypeBase: TYPE_BASE, pNom: string, pTaille: number, pSeuilAlerte: number) => void): void;
        static ajouterLimiteBase(pNom: string, pTaille: number): void;
        static getLimiteBase(pNom: string): number;
        static retirerLimiteBase(pNom: string): void;
        static ajouterLimiteTypeBase(pType: TYPE_BASE, pTaille: number): void;
        static getLimiteTypeBase(pType: TYPE_BASE): number;
        static retirerLimiteTypeBase(pType: TYPE_BASE): void;
    }
    interface ITailleDBEnregistrement {
        type: TYPE_BASE;
        nom: string;
        taille: number;
    }
    class DBBaseTechniqueTableTailleDB extends Generique.Model.DBTable<string, ITailleDBEnregistrement, DBBaseTechnique> {
        static indexTypeBase: IIndex;
        constructor(pBase: DBBaseTechnique);
        private taillesLimitesParTypeDeBase;
        private requetesChangeTailleBaseEnCours;
        private requetesGetTailleBaseEnCours;
        changerTailleBase(pTypeBase: TYPE_BASE, pNomBase: string, pValeurAAjouter: number): void;
        setTailleBase(pTypeBase: TYPE_BASE, pNomBase: string, pValeur: number): void;
        getTailleBase(pNomBase: string): number;
        private verifierTailleBase(pTypeBase);
        getTailleBaseComplete(pTypeBase: TYPE_BASE): number;
    }
}


/**
 * Couche d'accès aux bases de données de manière générique
 *
 * La philosophie est "Je ne connais pas l'implémentation qui est derrière, je sais juste que j'ai les fonctionnalités".
 *
 * Tout d'abord voyons ce qui se passe pour l'initialisation d'un accès à la base de données
 * <uml alt="Séquence d'initialisation">
 *  title Séquence d'initialisation
 *
 *  actor Metier as Metier
 *  participant "Generique.Factory" as Factory
 *  participant "Generique.Impl.*" as Impl
 *
 *  == Récupération de l'implémentation ==
 *
 *  Metier -> Factory: Demande de l'implémentation
 *  alt Si pas d'implémentation disponible case
 *      Metier <-- Factory: Lance une exception
 *  else Si une implémentation est disponible
 *      Metier <-- Factory: Retourne une implémentation disponible
 *  end
 *  ||100||
 *
 *  == Utilisation de l'implémentation ==
 *      Metier -> Metier: Instanciation d'un "Generique.IDBBase"\net de ses "Generique.IDBTable"
 *      note over Metier, Factory : Des implémentations par défaut sont disponibles dans le package "Generique.Model"
 *  ||100||
 *
 *  == Interrogation de la base de données ==
 *      Metier -> Impl: Utilisation des méthodes des interfaces, fournies par le package "Generique.Impl.*"
 *
 * </uml>
 *
 * Maintenant voyons comment nous pouvons ouvrir une transaction afin de réaliser des opérations
 *
 * <uml alt="Fonctionnement d'une requête">
 *  title Fonctionnement d'une requête
 *
 *  actor Metier as Metier
 *  participant "Generique.IDBBaseImplementation" as BaseImpl
 *  participant "Generique.IDBTableImplementation" as TableImpl
 *  participant "Connexion DB" as Connexion
 *
 *  ref over Metier, BaseImpl, TableImpl, Connexion : Voir schéma "Séquence d'initialisation" pour commencer
 *  ||100||
 *
 *  == Ouverture de la connexion ==
 *  Metier -> BaseImpl: ouvrirEnLecture(table1, table2, ...)
 *  note right: Ou ouvrirEnEcriture(...) si c'est pour de l'écriture
 *
 *  Metier <-- BaseImpl: promesseConnexion = IPromesse<Generique.IDBConnexion>
 *
 *  BaseImpl -> Connexion: Connexion ouverte
 *  activate Connexion
 *  Metier <-- BaseImpl: promesseConnexion.resolve()
 *  ||100||
 *
 *  == Exploitation de la connexion ==
 *  Metier -> TableImpl: ajouter(IDBConnexion, table1, elementAAjouter)
 *  Metier <-- TableImpl: IPromesse<Clé primaire>
 *  note over Metier, BaseImpl : L'ensemble des appels fonctionne sur le même schéma
 *  ||100||
 *
 *  == Fermeture de la connexion ==
 *  Metier -> BaseImpl: IDBConnexion.close()
 *  Metier <-- BaseImpl: promesseDeconnexion = IPromesse<void>
 *
 *  BaseImpl -> Connexion: Connexion fermée
 *  deactivate Connexion
 *  Metier <-- BaseImpl: promesseDeconnexion.resolve()
 * </uml>
 *
 * Voici un exemple d'implémentation
 * ~~~ts
 *
 * interface IObjetStocke {
 *     cle: string;
 *     valeur: stirng;
 * }
 * class BaseDeDonnees extends Generique.Model.DBBase {
 *     private _table1: Table1 = null;
 *     private _table2: Table2 = null;
 *
 *     constructor () {
 *         super("BaseDeTest", 2, Generique.CAPACITE.MULTI_ENREGISTREMENT);
 *     }
 *
 *     public mettreAJour(pConnexion: IDBConnexion, pVersionActuelle: number, pVersionVoulue: number): Array<IMiseAJourBase> {
 *         var lMisesAJour: Array<IMiseAJourBase> = [];
 *         if (pVersionActuelle < 1 && pVersionVoulue >= 1) {
 *             lMisesAJour.push({
 *                 structure: (pConnexion: IDBConnexion) => {
 *                     this.dbUpgradeImpl.ajouterTable(pConnexion, "table 1", new Generique.PathCle("cle"));
 *                 }
 *             });
 *         }
 *         if (pVersionActuelle < 2 && pVersionVoulue >= 2) {
 *             lMisesAJour.push({
 *                 structure: (pConnexion: IDBConnexion) => {
 *                     this.dbUpgradeImpl.ajouterTable(pConnexion, "table 2", new Generique.AutoincrementCle(), [Table2.indexValeur]);
 *                 }
 *             });
 *         }
 *         return lMisesAJour;
 *     }
 *
 *     public get table1(): Table1 {
 *         if (!this._table1) {
 *             this._table1 = new Table1(this);
 *         }
 *         return this._table1;
 *     }
 *
 *     public get table2(): Table2 {
 *         if (!this._table2) {
 *             this._table2 = new Table2(this);
 *         }
 *         return this._table2;
 *     }
 * }
 *
 * class Table1 extends Generique.Model.DBTable<string, IObjetStocke, BaseDeDonnees> {
 *     constructor(base: BaseDeDonnees) {
 *         super(base, "table1");
 *     }
 *
 *     public ajouter(pConnexion: Generique.IDBConnexion, pElement: IObjetStocke): IPromesse<string> {
 *         return this.dbImpl.ajouter(pConnexion, pElement);
 *     }
 *
 *     public supprimer(pConnexion: Generique.IDBConnexion, pCle: string): IPromesse<void> {
 *         return this.dbImpl.supprimer(pCle);
 *     }
 * }
 *
 * class Table2 extends Generique.Model.DBTable<number, IObjetStocke, BaseDeDonnees> {
 *     public static indexValeur: IIndex = {
 *         nom: 'indexValeur',
 *         proprietes: ['valeur'],
 *         isUnique: false
 *     }
 *
 *     constructor(base: BaseDeDonnees) {
 *         super(base, "table2");
 *     }
 *
 *     public ajouter(pConnexion: Generique.IDBConnexion, pElement: IObjetStocke): IPromesse<number> {
 *         return this.dbImpl.ajouter(pConnexion, this, pElement);
 *     }
 *
 *     public supprimer(pConnexion: Generique.IDBConnexion, pCle: number): IPromesse<void> {
 *         return this.dbImpl.supprimer(pConnexion, this, pCle);
 *     }
 *
 *     public rechercherParValeurMinimum(pConnexion: Generique.IDBConnexion, pValeurMin: string): IPromesse<Array<IObjetStocke>> {
 *         var critere: RequeteCritereSimpleBorne = new RequeteCritereSimpleBorne(
 *                 DBTableWithImplementation.indexValeur.nom,
 *                 Generique.CURSEUR_DIRECTION.SUIVANT,
 *                 [pValeurMin],
 *                 Generique.CRITERE_MODE_SIMPLE_BORNE.SUPERRIEUR_AU_CRITERE,
 *                 true
 *             );
 *         return this.dbImpl.findParCriteres(pConnexion, this, critere);
 *     }
 * }
 * ~~~
 *
 * Et pour utiliser cela :
 *
 * ~~~ts
 * var db = new BaseDeDonnees();
 * db.ouvrirEnEcriture(db.table1, db.table2).then((pConnexion: Generique.IDBConnexion) => {
 *     db.table1.ajouter({cle: "cle1", valeur: "valeur"}).then(() => {
 *         db.table2.ajouter({cle: "cle2", valeur: "abcde"}).then(() => {
 *             db.table2.rechercherParValeurMinimum(pConnexion, "a").then((mesObjets: Array<IObjetStocke>) => {
 *                 pConnexion.close();
 *             }, (pErreur: Erreur) => {
 *                 console.log("Je n'ai pas pu rechercher l'element");
 *                 pConnexion.close();
 *             });
 *         }, (pErreur: Erreur) => {
 *             console.log("Je n'ai pas pu ajouter le second élément");
 *             pConnexion.close();
 *         });
 *     }, (pErreur: Erreur) => {
 *         console.log("Je n'ai pas pu ajouter le premier élément");
 *         pConnexion.close();
 *     });
 * }, (pErreur: Erreur) => {
 *     console.log("Impossible de se connecter à la base de données");
 * });
 * ~~~
 */
declare module fwkManager.Services.BaseDeDonnees.Generique {
    /**
     * Base de données
     */
    interface IDBBase {
        /** Nom de la base */
        nom: string;
        /** version de la base */
        version: number;
        /** Type de capacite */
        capacite: CAPACITE;
        /**
         * Méthode appelée lorsque la base de données doit être mise à jour
         *
         * @param pVersionActuelle Version actuelle
         * @param pVersionVoulue Version désirée
         */
        mettreAJour(pVersionActuelle: number, pVersionVoulue: number): Array<IMiseAJourBase>;
        /** Implémentation de la base pour les opérations "courantes */
        dbImpl: IDBBaseImplementation;
    }
    /**
     * Table de base de données
     */
    interface IDBTable<Pk, T> {
        /** Base de données dans laquelle est stockée la table */
        base: IDBBase;
        /** Nom de la table */
        nom: string;
        primaryKey: AbstractCleType;
        indexes: Array<IIndex>;
    }
    interface IMiseAJourBase {
        structure?: (pConnexion: IDBConnexion) => void;
        donnees?: (pConnexion: IDBConnexion) => IPromesse<void>;
    }
    interface CleValeur<Cle, Valeur> {
        cle: Cle;
        valeur: Valeur;
    }
    interface DatabaseEntry<Pk, T> {
        cle: Pk;
        valeur: T;
        rowid: number;
    }
    /** Interface d'accès aux table d'une base de données */
    interface IDBTableImplementation<Pk, T> {
        /**
         * Compter les lignes d'une base de données
         *
         * @param pConnexion Connexion courante à la base de données
         * @param pTable Table à interroger
         * @param pCriteres [optionel] Critères de la recherche afin de ne pas prendre tous les éléments lors du décompte
         * @return Promesse contenant le nombre d'élements recherché
         */
        count(pConnexion: IDBConnexion, pTable: IDBTable<Pk, T>, pCriteres?: RequeteCritere): IPromesse<number>;
        /**
         * Ajouter un élément en base de données
         *
         * @param pConnexion Connexion courante à la base de données
         * @param pTable Table à interroger
         * @param pObjet Objet à ajouter
         * @return Promesse contenant la clé de l'objet ajouté
         */
        ajouter(pConnexion: IDBConnexion, pTable: IDBTable<Pk, T>, pObjet: T): IPromesse<Pk>;
        /**
         * Supprimer un élément de la base de données
         *
         * @param pConnexion Connexion courante à la base de données
         * @param pTable Table à interroger
         * @param pCle Clé de l'objet à supprimer
         * @return Promesse vide
         */
        supprimer(pConnexion: IDBConnexion, pTable: IDBTable<Pk, T>, pCle: Pk): IPromesse<void>;
        /**
         * Mets à jour un élément de la base de données
         *
         * @param pConnexion Connexion courante à la base de données
         * @param pTable Table à interroger
         * @param pCle Clé de l'objet à remplacer
         * @param pNouvelleValeur Nouvel objet à placer
         * @param pCleEstAutoincrement Indique si la clé est de type autoincrement ou pas
         * @return Promesse vide
         */
        mettreAJour(pConnexion: IDBConnexion, pTable: IDBTable<Pk, T>, pCle: Pk, pNouvelleValeur: T): IPromesse<void>;
        /**
         * Récuperer un élément de la base de données par son identifiant
         *
         * @param pConnexion Connexion courante à la base de données
         * @param pTable Table à interroger
         * @param pCle Clé de l'objet voulu
         * @return Promesse contenant l'objet recherché (ou null si pas trouvé)
         */
        getParId(pConnexion: IDBConnexion, pTable: IDBTable<Pk, T>, pCle: Pk): IPromesse<T>;
        /**
         * Rechercher des éléments se trouvant en base de données
         *
         * @param pConnexion Connexion courante à la base de données
         * @param pTable Table à interroger
         * @param pCriteres Criteres de recherche
         * @return Promesse contenant les objets correspondant aux critères
         */
        findParCriteres(pConnexion: IDBConnexion, pTable: IDBTable<Pk, T>, pCriteres: RequeteCritere, pMax?: number): IPromesse<DatabaseEntry<Pk, T>[]>;
        /**
         * Récupérer tous les éléments d'une table
         *
         * @param pConnexion Connexion courante à la base de données
         * @param pTable Table à interroger
         * @return Promesse contenant les objets recherchés
         */
        getAll(pConnexion: IDBConnexion, pTable: IDBTable<Pk, T>): IPromesse<DatabaseEntry<Pk, T>[]>;
    }
    /** Interface de mise à jour du schéma d'une base de données */
    interface IDBBaseUpgradeImplementation {
        /**
         * Ajout d'une table
         *
         * @param pConnexion Connexion courante à la base de données
         * @param pBase Base de données ciblée
         * @param pNom Nom de la nouvelle table
         * @param pCle Type de la clé primaire
         * @param pIndexs [optionnel] Tableau d'indexes à ajouter
         */
        ajouterTable(pConnexion: IDBConnexion, pBase: IDBBase, pNom: string, pCle: AbstractCleType, pIndexs?: Array<IIndex>): void;
        /**
         * Suppression d'une table
         *
         * @param pConnexion Connexion courante à la base de données
         * @param pBase Base de données ciblée
         * @param pNom Nom de la table à supprimer
         */
        supprimerTable(pConnexion: IDBConnexion, pBase: IDBBase, pNom: string): void;
        /**
         * Ajout d'indexs
         *
         * @param pConnexion Connexion courante à la base de données
         * @param pBase Base de données ciblée
         * @param pNom Nom de la table ciblée
         * @param pIndexs Tableau d'indexes à ajouter
         */
        ajouterIndexs(pConnexion: IDBConnexion, pBase: IDBBase, pNomTable: string, pIndexs: Array<IIndex>): void;
        /**
         * Ajout d'une table
         *
         * @param pConnexion Connexion courante à la base de données
         * @param pBase Base de données ciblée
         * @param pNom Nom de la table ciblée
         * @param pIndexs Tableau des noms des indexes à supprimer
         */
        supprimerIndexs(pConnexion: IDBConnexion, pBase: IDBBase, pNomTable: string, pIndexs: Array<string>): void;
        /**
         * Fais des modifications de base de données complètement arbitraires
         *
         * @param pMisesAJour Liste des actions à faire pour mettre à jour la base
         * @param pVersion Version finale désirée après les mises à jour
         */
        upgradeEtFixVersion(pBase: IDBBase, pMisesAJour: messages.DB_UPGRADE_ACTION[], pVersion: number): IPromesse<void>;
    }
    /** Interface d'accès à une base de données */
    interface IDBBaseImplementation {
        /**
         * Connaitre la taille d'une base de données
         *
         * @param pBase Base de données à interroger
         * @return Promesse contenant la taille désirée
         */
        getTailleBase(pBase: IDBBase): IPromesse<number>;
        /**
         * Forcer le recalcul de la taille d'une base de données
         *
         * @param pBase Base de données à interroger
         * @return Promesse contenant la taille désirée
         */
        forcerRecalculTailleBase(pBase: IDBBase): IPromesse<number>;
        /**
         * Ouverture d'une transaction en mode lecture
         *
         * @param pBase Base de données à interroger
         * @return Promesse contenant l'objet de conenxion
         */
        ouvrirEnLecture(...pTables: Array<IDBTable<any, any>>): IPromesse<IDBConnexion>;
        /**
         * Ouverture d'une transaction en mode ecriture
         *
         * @param pBase Base de données à interroger
         * @return Promesse contenant l'objet de conenxion
         */
        ouvrirEnEcriture(...pTables: Array<IDBTable<any, any>>): IPromesse<IDBConnexion>;
        getTables(pBase: IDBBase): IPromesse<Array<IDBTable<any, any>>>;
    }
    /** Objet supportant une connexion à une base de données */
    interface IDBConnexion {
        /**
         * Fermeture de la connexion
         *
         * @return Promesse vide
         */
        close(): IPromesse<void>;
        /** Paramètres de connexion utilisés en interne */
        parametresConnexion: any;
    }
    /** Classe abstraite définissant un type de clé primaire */
    class AbstractCleType {
        private _estAutoincrement;
        constructor(_estAutoincrement: boolean);
        estAutoincrement: boolean;
    }
    /** Clé primaire de type autoincrement */
    class AutoincrementCle extends AbstractCleType {
        constructor();
    }
    /** Clé primaire de type "Chemin" : La clé est une des propriétés de l'objet stocké */
    class PathCle extends AbstractCleType {
        propriete: string;
        /**
         * Constructeur
         *
         * @param propriete Nom de la propriété qui servira de clé primaire
         */
        constructor(propriete: string);
    }
    /** Index sur une table */
    interface IIndex {
        nom: string;
        proprietes: string[];
        isUnique?: boolean;
    }
    /** Type de critère quand il n'y a qu'une seule valeur de référence */
    export const enum CRITERE_MODE_SIMPLE_BORNE {
        /** L'objet doit avec la MÊME VALEUR que le critère */
        EQUAL = 20,
        /** L'objet doit être inferrieur au critère */
        INFERRIEUR_AU_CRITERE = 30,
        /** L'objet doit être superrieur au critère */
        SUPERRIEUR_AU_CRITERE = 40,
    }
    /** Enumération permettant de définir le sens de parcours d'un curseur sur une plage de données */
    export const enum CURSEUR_DIRECTION {
        /** Vers l'avant */
        SUIVANT = 10,
        /** Vers l'avant et ignore les doublons */
        SUIVANT_UNIQUE = 20,
        /** En arrière */
        PRECEDENT = 30,
        /** En arrière et ignore les doublons */
        PRECEDENT_UNIQUE = 40,
    }
    /** Classe définissant un critère de recherche */
    class RequeteCritere {
        index: IIndex;
        curseurDirection: CURSEUR_DIRECTION;
        /**
         * Constructeur
         *
         * @param nomIndex Nom de l'index
         * @param curseurDirection Sens de lecture
         */
        constructor(index: IIndex, curseurDirection: CURSEUR_DIRECTION);
    }
    /** Classe définissant un critère de recherche de type "Simple borne" (egal/inferrieur/supperrieur) */
    class RequeteCritereSimpleBorne extends RequeteCritere {
        valeurIndex: Array<any>;
        critereMode: CRITERE_MODE_SIMPLE_BORNE;
        inclureValeurReference: boolean;
        /**
         * Constructeur
         *
         * @param nomIndex Nom de l'index
         * @param curseurDirection Sens de lecture
         * @param valeurIndex Valeur de référence
         * @param critereMode Critere de comparaison
         * @param inclureValeurReference [optionel, defaut=true] Inclue (true) ou non (false) la valeur de référence dans la recherche. Pas d'effet sur le "egal"
         */
        constructor(index: IIndex, curseurDirection: CURSEUR_DIRECTION, valeurIndex: Array<any>, critereMode: CRITERE_MODE_SIMPLE_BORNE, inclureValeurReference?: boolean);
    }
    /** Classe définissant un critère de recherche de type "Entre borne" (situé entre valeur1 et valeur2) */
    class RequeteCritereEntreBornes extends RequeteCritere {
        minValeurIndex: Array<any>;
        maxValeurIndex: Array<any>;
        inclureValeurMin: boolean;
        inclureValeurMax: boolean;
        /**
         * Constructeur
         *
         * @param nomIndex Nom de l'index
         * @param curseurDirection Sens de lecture
         * @param minValeurIndex Valeur minimum de référence
         * @param maxValeurIndex Valeur maximum de référence
         * @param inclureValeurMin Inclue (true) ou non (false) la valeur minimum de référence dans la recherche
         * @param inclureValeurMax Inclue (true) ou non (false) la valeur maximum de référence dans la recherche
         */
        constructor(index: IIndex, curseurDirection: CURSEUR_DIRECTION, minValeurIndex: Array<any>, maxValeurIndex: Array<any>, inclureValeurMin: boolean, inclureValeurMax: boolean);
    }
}


declare module fwkManager.Services.Display {
    class FrameModel {
        FrameId: string;
        private _baseFrameElement;
        private displayManager;
        private static CLASS_NAME;
        private static logger;
        private _frameElement;
        FrameUrl: string;
        IsMyWayUrl: boolean;
        IsProducteur: boolean;
        ProcessId: string;
        PreviousFrame: FrameModel;
        TempId: string;
        IsHidden: boolean;
        Redirected: boolean;
        capaciteChat: boolean;
        SimulateAppIFrame: boolean;
        constructor(FrameId: string, _baseFrameElement: HTMLIFrameElement, displayManager: DisplayManager);
        FrameElement: HTMLIFrameElement;
        CreateFrameElement(): void;
        RemoveFrameElement(): void;
        SetUrl(url: string): boolean;
        Show(): boolean;
        Hide(): void;
        SetId(): void;
        GetWindow(): Window;
    }
    class DisplayManagerExtended {
        private manager;
        constructor(manager: DisplayManager);
        onNotificationDeMessage: (message: IMessage) => void;
        onFermerModalMessage: () => void;
        onAffichageModalMessage: (TitreMessage: string, ContenuMessage: string, boutons: string, delai: number, callback: (retour: any) => void, onModaleOuverte?: () => void) => void;
        onAffichageModalAide: (TitreMessage: string, ContenuMessage: string, CodeEtape: string, IdFlashcode: number) => void;
        AfficherUrl(url: string, processId: string): IPromesse<boolean>;
        OuvrirUrl(url: string): Window;
        onChangementDeFrame: (frame: FrameModel) => void;
    }
    class DisplayManager extends Component.ComponentManagerBase {
        private appIFrameId;
        private static CLASS_NAME;
        private static logger;
        Library: ManagerLibrary;
        private _logOnUrl;
        checkTimeoutHandle: number;
        Frames: FrameModel[];
        BaseFrame: FrameModel;
        CurrentFrame: FrameModel;
        SavedUrl: string;
        SavedFrameId: string;
        SavedProcessId: string;
        onNotificationDeMessage: (message: IMessage) => void;
        onFermerModalMessage: () => void;
        onAffichageModalAide: (TitreMessage: string, ContenuMessage: string, CodeEtape: string, IdFlashcode: number) => void;
        onShowFrame: (frame: FrameModel) => void;
        onAffichageModalMessage: (TitreMessage: string, ContenuMessage: string, boutonsAAfficher: Object, delai: number, callback: (retour: any) => void, onModaleOuverte?: () => void) => void;
        constructor(managerLibrary: ManagerLibrary, appIFrameId: string, logOnUrl?: string);
        /**
         * Affiche l'url dans la frame correspondant au processus
         *
         * Si l'id de processus est vide, affiche l'url dans la frame de base
         *
         * @url {string} url à afficher
         * @processId {string} id du processus
         */
        AfficherUrl(url: string, processId: string, nouvelleIFrame?: boolean): IPromesse<boolean>;
        /**
         * Ouvre une nouvelle instance de navigateur avec l'url (get) du correspondante
         */
        OuvrirUrl(url: string): Window;
        DisplayBaseFrame(): void;
        /**
         * Affiche la fenêtre de logOn si elle a été précisée et n'est pas déjà affichée
         */
        DisplayLogOn(): void;
        Redirect(url?: string, previousFrame?: FrameModel, frameId?: string): IPromesse<boolean>;
        Redirect(url?: string, previousUrl?: string): IPromesse<boolean>;
        CleanFrames(processes: Context.IProcess[]): void;
        CleanLastProcessFrame(): void;
        /**
         * Supprime la frame correspondant à un processus
         * @processId {string} id du processus
         */
        RemoveProcessIFrame(processId: string): void;
        DisplayMessage(message: IMessage): void;
        FermerModalMessage(): void;
        /**
         * Permet de lancer l'événement d'affichage d'une modale
         * @param {string}  TitreMessage     Titre de la modale
         * @param {string}  ContenuMessage   Contenu de la modale
         * @param {string}  boutonsAAfficher Objet précisant les différents boutons à afficher
         * @param {number}  delai            Délai d'affichage de la modale
         * @param {any) =>               void}        callback        [description]
         * @param {()   =>               void}        onModaleOuverte [description]
         */
        AfficherModalMessage(TitreMessage: string, ContenuMessage: string, boutonsAAfficher: string, delai: number, callback: (retour: any) => void, onModaleOuverte?: () => void): void;
        AfficherModalAide(TitreMessage: string, ContenuMessage: string, CodeEtape: string, IdFlashcode: number): void;
        HandleMessage(event: MessageEvent, sendResponseCallback: Component.ResponseCallback): void;
        getMyIFrameId(pWindow: Window): string;
        private DisplayIFrameUrl(url, displayedProcessId, nouvelleIFrame, callback);
        private DisplayBaseUrl(url);
        /**
         * Récupère le modèle de frame par son id
         * @id {string} id de la frame
         */
        private GetFrameModelById(id);
        private GetLastFrameModelByProcessId(processId);
        private GetFrameModelsByProcessId(processId);
        /**
         * Masque toutes les frames sauf celle correspondant à l'id donné
         * @iframeId {string} id de la frame à montrer
         */
        private ShowOnlyIFrame(iframeId, forceShowFrame?);
        /**
         * Ajoute une frame pour un processus donné avec l'url donnée
         * Si la frame existe déjà, l'url de cette frame est juste modifiée
         * @url {string} url à mettre dans la frame
         * @processId {string} id du processus
         */
        private AddProcessIFrame(url, processId, nouvelleIFrame, redirected, needStart);
        private AddTempId(frame, processId, tempId);
        private ExecuteJS(jsUrl);
        private RedirectInStep(url);
        PrepareSubmit(url: any): void;
        FinishSubmit(): void;
    }
}


declare module fwkManager.Services.DonneesDelocalisees.DonneesDelocaliseesConfigurationDb {
    var DB_STORE_TDT: string;
    var DB_STORE_DATA: string;
}


declare module fwkManager.Services.DonneesDelocalisees {
    interface IDonneeDelocaliseeTDT {
        datemaj: string;
        id: string;
        tables: IDonneeDelocaliseeTDTTable[];
    }
    interface IDonneeDelocaliseeTDTTable {
        datemaj: string;
        nom: string;
        referentiel: string;
        utildonneesperimees?: string;
    }
    interface IDonneeDelocaliseeData {
        datemaj: string;
        id: string;
        nom: string;
        referentiel: string;
        donnees: any[];
    }
}


declare module fwkManager.Services.DonneesDelocalisees {
    class DBDonneesDelocs extends BaseDeDonnees.Generique.Model.DBBase {
        static DB_VERSION: number;
        static DB_NAME: string;
        private _tdt;
        private _data;
        constructor();
        mettreAJour(pVersionActuelle: number, pVersionVoulue: number): Array<BaseDeDonnees.Generique.IMiseAJourBase>;
        private versionV0ToV1();
        tableTDT: DBDonneesDelocsTDT;
        tableData: DBDonneesDelocsData;
        reset(): IPromesse<void>;
    }
    class DBDonneesDelocsTDT extends BaseDeDonnees.Generique.Model.DBTable<string, IDonneeDelocaliseeTDT, DBDonneesDelocs> {
        constructor(pDB: DBDonneesDelocs);
        getTDT(pConnexion: BaseDeDonnees.Generique.IDBConnexion, pId: string): IPromesse<IDonneeDelocaliseeTDT>;
        setTDT(pConnexion: BaseDeDonnees.Generique.IDBConnexion, pTableDesTables: IDonneeDelocaliseeTDT): IPromesse<void>;
        supprimerTDT(pConnexion: BaseDeDonnees.Generique.IDBConnexion, pId: string): IPromesse<void>;
        reset(pConnexion: BaseDeDonnees.Generique.IDBConnexion): IPromesse<any>;
    }
    class DBDonneesDelocsData extends BaseDeDonnees.Generique.Model.DBTable<string, IDonneeDelocaliseeData, DBDonneesDelocs> {
        constructor(pDB: DBDonneesDelocs);
        getData(pConnexion: BaseDeDonnees.Generique.IDBConnexion, pId: string): IPromesse<IDonneeDelocaliseeData>;
        setData(pConnexion: BaseDeDonnees.Generique.IDBConnexion, pTable: IDonneeDelocaliseeData): IPromesse<void>;
        reset(pConnexion: BaseDeDonnees.Generique.IDBConnexion): IPromesse<any>;
    }
}


/**
* Module de gestion des données délocalisées
* @module fwkManager.Services.DonneesDelocalisees
* Dépendances: Controle, Donnees, indexedDB
* classe : DonneesDelocaliseesManager - public - Classe permettant la gestion des données délocalisées
* classe : DonneesDelocaliseesTools - public - Classe encapsulant les outils de debug et de diagnostics des données délocalisées - Ne doit pas être utilisé en production
* interface : ObjectDataDescription – privé - Description d'un objet de données
*/
declare module fwkManager.Services.DonneesDelocalisees {
    class DonneesDelocaliseesManagerExtended {
        private manager;
        constructor(manager: DonneesDelocaliseesManager);
        /**
        * Permet de récupérer des données délocalisées
        * @param numEtablissement {string} identifiant de la Table des tables (numéro d'établissement). Si null, c'est celui du contexte qui est utilisé.
        * @param objectDataName {string} nom de l'objet de données
        */
        getDonneesDelocalisees(numEtablissement: string, objectDataName: string): IPromesse<any>;
        /**
        * Permet de récupérer une liste de données délocalisées
        * @param numEtablissement {string} Numéro d'établissement. Si null, c'est celui du contexte qui est utilisé.
        * @param objectDataNames {Array<string>} Liste des noms d'objets de données
        */
        getListeDonneesDelocalisees(numEtablissement: string, objectDataNames: string[]): IPromesse<any[]>;
        /**
        * Permet de récupérer le libellé du code d'un objet de données
        * @param numEtablissement {string} identifiant de la Table des tables (numéro d'établissement)
        * @param objectDataName {string} nom de l'objet de données
        * @param code {string} code pour lequel on veut obtenir le libellé
        */
        getRubriqueLibelle(numEtablissement: string, objectDataName: string, code: string): IPromesse<string>;
        /**
        * Permet de récupérer les données d'un objet de données correspondant aux critères choisis
        * @param numEtablissement {string} identifiant de la Table des tables (numéro d'établissement)
        * @param objectDataName {string} nom de l'objet de données
        * @param criteres {Array<ObjectDataCritere>} critères de recherche des données
        */
        getDonneesParCriteres(numEtablissement: string, objectDataName: string, criteres: Array<ObjectDataCritere>): IPromesse<any>;
    }
    /**
    * Classe permettant la gestion des données délocalisées
    * @classe DonneesDelocaliseesManager
    * fonction : getDonneesDelocalisees – public - Permet de récupérer des données délocalisées
    * fonction : getListeDonneesDelocalisees – public - Récupère une liste de données délocalisées correspondantes à la liste de noms d'objets de données et au numéro d'établissement passés en paramètres
    * fonction : getRubriqueLibelle - public - Permet de récupérer le libellé du code d'un objet de données rubrique
    * fonction : getDonneesParCriteres - public - Permet de récupérer les données d'un objet de données correspondant aux critères choisis
    * fonction : openIDBAndGetDistantTDTAndCloseIDB – public - Permet d'ouvrir IDB, de récupérer et stocker la dernière version d'un objet TDT via une REST API du serveur intermédiaire et de fermer IDB
    * fonction : HandleMessage - public - Traite les messages provenants de l'agent DonneesDelocaliseesAgent
    * fonction : _getCodeEtablissement - privé - Permet de récupérer le code établissement du contexte
    * fonction : getDonneesDelocaliseesIDB – privé - Permet de récupérer des données délocalisées depuis une base données délocalisées IndexedDB
    * fonction : getTDTIDB – privé - Permet de récupérer un objet TDT stocké dans le storeTDT d'une base données délocalisées IndexedDB
    * fonction : getDistantTDT – privé - Permet de récupérer un objet TDT via une REST API du serveur intermédiaire
    * fonction : getObjectDataIDB – privé - Permet de récupérer un objet de données stocké dans le storeData d'une base données délocalisées IndexedDB
    * fonction : getDistantObjectData – privé - Permet de récupérer un objet de données via une REST API du serveur intermédiaire
    * fonction : getRefData – privé - Permet de récupérer les informations d'un objet de données dont la date de dernière mise à jour dans un objet TDT
    */
    class DonneesDelocaliseesManager extends Component.ComponentManagerBase {
        private static CLASS_NAME;
        private static logger;
        Library: ManagerLibrary;
        dbBase: DBDonneesDelocs;
        /**
        * Constructeur de la classe DonneesDelocaliseesManager
        * @param managerLibrary {ManagerLibrary}
        */
        constructor(managerLibrary: ManagerLibrary);
        /**
        * Récupère les données délocalisées correspondantes au nom de l'objet de données et au numéro d'établissement passés en paramètres
        * Et si nécessaire met à jour la base de données DonneesDelocalisees dans indexedDB
        * Si le navigateur utilisé ne supporte pas indexedDB alors on appelle les WS REST à chaque fois que l'on veut récupérer un objet de données
        * Une fois les données récupérées, la fonction callback passée en paramètre est executée avec en paramètre objectData (l'objet de données demandé)
        * En cas d'erreur, la fonction callbackError passée en paramètre est executée avec en paramètre messageErreur (le message de description de l'erreur)
        * @param numEtablissement {string} Numéro d'établissement. Si null, c'est celui du contexte qui est utilisé.
        * @param objectDataName {string} Nom de l'objet de données
        * @param callback {function} Action à exécuter une fois les données récupérées (l'objet de données est passé en paramètre: objectData)
        * @param callbackError {function} Action à exécuter en cas d'erreur (le message d'erreur est passé en paramètres: messageErreur)
        */
        getDonneesDelocalisees(numEtablissement: string, objectDataName: string): IPromesse<any>;
        /**
        * Récupère une liste de données délocalisées correspondantes à la liste de noms d'objets de données et au numéro d'établissement passés en paramètres
        * @param numEtablissement {string} Numéro d'établissement. Si null, c'est celui du contexte qui est utilisé.
        * @param objectDataNames {Array<string>} Liste des noms d'objets de données
        * @param callback {function} Action à exécuter une fois les données récupérées (la liste d'objets de données est passée en paramètre: Array<objectData>)
        * @param callbackError {function} Action à exécuter en cas d'erreur (le message d'erreur est passé en paramètres: messageErreur)
        */
        getListeDonneesDelocalisees(numEtablissement: string, objectDataNames: string[]): IPromesse<any>;
        /**
        * Permet de récupérer le libellé du code d'un objet de données
        * @param numEtablissement {string} identifiant de la Table des tables (numéro d'établissement). Si null, c'est celui du contexte qui est utilisé.
        * @param objectDataName {string} nom de l'objet de données
        * @param code {string} code pour lequel on veut obtenir le libellé
        * @param callback {function} action à exécuter une fois le libellé récupéré (le libellé récupéré est transmis en paramètre: stringData)
        * @param callbackError {function} action à exécuter en cas d'erreur (le message d'erreur est transmis en paramètre: messageErreur)
        */
        getRubriqueLibelle(numEtablissement: string, objectDataName: string, code: string): IPromesse<any>;
        /**
        * Permet de récupérer les données d'un objet de données correspondant aux critères choisis
        * @param numEtablissement {string} identifiant de la Table des tables (numéro d'établissement). Si null, c'est celui du contexte qui est utilisé.
        * @param objectDataName {string} nom de l'objet de données
        * @param criteres {Array<ObjectDataCritere>} critères de recherche des données
        * @param callback {function} action à exécuter une fois les données récupérées (les données sont transmises en paramètre: objectData)
        * @param callbackError {function} action à exécuter en cas d'erreur (le message d'erreur est transmis en paramètre: messageErreur)
        */
        getDonneesParCriteres(numEtablissement: string, objectDataName: string, criteres: Array<ObjectDataCritere>): IPromesse<any>;
        /**
        * Permet d'ouvrir IDB, de récupérer et stocker la dernière version d'un objet TDT via une REST API du serveur intermédiaire et de fermer IDB
        * @param numEtablissement {string} identifiant de la Table des tables (numéro d'établissement). Si null, c'est celui du contexte qui est utilisé.
        * @param callback {function} action à exécuter une fois l'objet TDT récupéré
        * @param callbackError {function} action à exécuter en cas d'erreur (le message d'erreur est transmis en paramètre: messageErreur)
        */
        openIDBAndGetDistantTDTAndCloseIDB(numEtablissement: string): IPromesse<any>;
        /**
        * Traite les messages provenants de l'agent DonneesDelocaliseesAgent
        * @param event {Event} évènement
        * @param sendResponseCallback {ResponseCallback} objet contenant le callback de retour
        */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
        /**
        * Récupère le code établissement depuis le contexte
        * @param callbackError {function} Action à exécuter en cas d'erreur (le message d'erreur est passé en paramètres: messageErreur)
        * @return string code établissement
        */
        private _getCodeEtablissement(callbackError);
        /**
        * Permet de récupérer des données délocalisées depuis une base données délocalisées IndexedDB
        * @param numEtablissement {string} identifiant de la Table des tables (numéro d'établissement)
        * @param objectDataName {string} nom de l'objet de données
        * @param callback {function} action à exécuter une fois les données récupérées (les données récupérées sont transmis en paramètre: objectData)
        * @param callbackError {function} action à exécuter en cas d'erreur (le message d'erreur est transmis en paramètre: messageErreur)
        */
        private getDonneesDelocaliseesIDB(numEtablissement, objectDataName);
        /**
        * Permet de récupérer un objet TDT stocké dans le storeTDT d'une base données délocalisées IndexedDB
        * @param idTDT {string} identifiant de l'objet TDT à récupérer dans le storeTDT
        * @param callback {function} action à exécuter une fois l'objet TDT récupéré (l'objet TDT récupéré est transmis en paramètre: objectTDT)
        * @param callbackError {function} action à exécuter en cas d'erreur (le message d'erreur est transmis en paramètre: messageErreur)
        */
        private getTDTIDB(idTDT);
        /**
        * Permet de récupérer un objet TDT via une REST API du serveur intermédiaire
        * @param numEtablissement {string} identifiant de la Table des tables (numéro d'établissement)
        * @param callback {function} action à exécuter une fois l'objet TDT récupéré (l'objet TDT récupéré est transmis en paramètre: objectTDT)
        * @param callbackError {function} action à exécuter en cas d'erreur (le message d'erreur est transmis en paramètre: messageErreur)
        */
        private getDistantTDT(numEtablissement);
        /**
        * Permet de récupérer un objet de données stocké dans le storeData d'une base données délocalisées IndexedDB
        * @param numEtablissement {string} identifiant de la Table des tables (numéro d'établissement)
        * @param objectDataDescription {ObjectDataDescription} description de l'objet de données
        * @param callback {function} action à exécuter une fois l'objet de données récupéré (l'objet de données récupéré est transmis en paramètre: objectData)
        * @param callbackError {function} action à exécuter en cas d'erreur (le message d'erreur est transmis en paramètre: messageErreur)
        */
        private getObjectDataIDB(numEtablissement, objectDataDescription);
        /**
        * Permet de récupérer un objet de données via une REST API du serveur intermédiaire
        * @param numEtablissement {string} identifiant de la Table des tables (numéro d'établissement)
        * @param objectDataName {string} nom de l'objet de données
        * @param callback {function} action à exécuter une fois l'objet de données récupéré (l'objet de données récupéré est transmis en paramètre: objectData)
        * @param callbackError {function} action à exécuter en cas d'erreur (le message d'erreur est transmis en paramètre: messageErreur)
        */
        private getDistantObjectData(numEtablissement, objectDataName);
        /**
        * Permet de récupérer la date de dernière mise à jour d'un objet de données dans un objet TDT
        * @param objectTDT {any} objet TDT pour lequel on veut obtenir la date de dernière mise à jour
        * @param objectDataName {string} nom de l'objet de données
        */
        private getRefData(objectTDT, objectDataName);
        /**
        * Permet de supprimer et de réinitialiser la base de données IndexedDB des données délocalisées
        * @param callback {function} action à exécuter une fois les données supprimées
        * @param callbackError {function} action à exécuter en cas d'erreur (le message d'erreur est transmis en paramètre: messageErreur)
        */
        private reInitDbDonneesDelocalisees();
        /**
        * Permet de récupérer l'objet TDT correspondant à l'identifiant passé en paramètre dans le storeTDT
        * @param idTDT {string} identifiant du TDT à récupérer dans le storeTDT
        * @param callback {function} action à exécuter une fois que l'objet TDT a été récupérer (l'objet TDT récupéré est transmis en paramètre: objectTDT)
        * @param callbackError {function} action à exécuter en cas d'erreur (le message d'erreur est transmis en paramètre: messageErreur)
        */
        private getTDTById(idTDT);
        /**
        * Permet de supprimer l'objet TDT correspondant à l'identifiant passé en paramètre dans le storeTDT
        * @param idTDT {string} identifiant du TDT à supprimer dans le storeTDT
        * @param callback {function} action à exécuter une fois que l'objet TDT a été supprimé
        * @param callbackError {function} action à exécuter en cas d'erreur (le message d'erreur est transmis en paramètre: messageErreur)
        */
        private deleteTDTById(idTDT);
        /**
        * Retourne l'export const enum CRITERES_OPERATEUR
        * @param callback {function} action à exécuter pour renvoyer l'export const enum
        */
        private getEnumCriteresOperateur();
    }
}


declare module fwkManager.Services.DonneesDelocalisees {
    interface IDonneesDelocaliseesApi {
        getDistantObjectData(settings: IRequestSettings): IPromesse<any>;
        getDistantTDT(settings: IRequestSettings): IPromesse<any>;
        getTDTById(settings: IRequestSettings): IPromesse<any>;
        sendRequest(settings: IRequestSettings): IPromesse<any>;
    }
}


declare module fwkManager.Services.DonneesDelocalisees {
    class DonneesDelocaliseesApi implements IDonneesDelocaliseesApi {
        constructor();
        getDistantObjectData(settings: IRequestSettings): IPromesse<any>;
        getDistantTDT(settings: IRequestSettings): IPromesse<any>;
        getTDTById(settings: IRequestSettings): IPromesse<any>;
        sendRequest(settings: IRequestSettings): IPromesse<any>;
    }
}


/**
* Module de gestion des exports
* @module fwkManager.Services.Export
* @author Laurie Marchaterre
*/
declare module fwkManager.Services.Export {
    /**
    *  Classe permettant d'accéder aux données de mobilité
    */
    class ExportManager extends Component.ComponentManagerBase {
        private _managerLibrary;
        Library: ManagerLibrary;
        private contextKey;
        private static CLASS_NAME;
        private static logger;
        constructor(managerLibrary: ManagerLibrary);
        private verificationDonneesAExporter(pDonnees);
        private convertionDonneesEnCsv(donnees, options);
        private telechargerFichier(donneesTraitees, options);
        /**
         * Permet d'exporter un tableau de données Json dans un fichier.
         * @param {IDonneesAExporter}   donnees        Données Json à exporter dans un fichier
         * @param {FORMAT_FICHIER} format       Format du fichier exporté
         * @param {OptionsExportFichier} options        Options d'exportation du fichier
         * @return {IPromesse<void>}
         *
         * ~~~ts
         * serviceAgent.export.exporterFichier(donnees: IDonneesAExporter, format: FORMAT_FICHIER, options: IOptionsExportFichier).then(() => {
         * // Le fichier a été exporté
         * ...
         * * }).catch((erreur: fwkManager.Services.Erreur) => {
         * // Renvoi une erreur
         * ...
         * });
         * ~~~
         */
        exporterFichier(donneesTableau: IDonneesAExporter, format: FORMAT_FICHIER, options: IOptionsExportFichier): IPromesse<void>;
        /**
        * Traite les messages provenants de l'agent ExportAgent
        * @param event {Event} évènement
        * @param sendResponseCallback {ResponseCallback} objet contenant le callback de retour
        */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}

declare module fwkManager.Services.Fichier {
    interface IFichierApi {
        save(data: any, type: string, nomFichier: string): void;
    }
}

declare module fwkManager.Services.Fichier {
    class FichierApi implements IFichierApi {
        private _isIE;
        constructor();
        private saveAs(data, type, nomFichier);
        save(data: any, type: string, nomFichier: string): void;
    }
}


declare module fwkManager.Services.Fichier {
    /**
    * Classe gestion des fichiers
    * @classe FichierManager
    * fonction : saveAs – public - Permet de sauvegarder un fichier sur le filesystem
    * fonction : b64toBlob – private - Renvoie un Blob à partir d'une chaine base64
    * fonction : HandleMessage - public - Traite les messages provenants de l'agent FichierAgent
    */
    class FichierManager extends Component.ComponentManagerBase implements Component.IComponentManager {
        private static CLASS_NAME;
        private static logger;
        Library: ManagerLibrary;
        constructor(library: ManagerLibrary);
        /**
        * Permet de télécharger un fichier
        * @param data {any} données du fichier
        * @param type {TYPE_FICHIER} type du fichier à télécharger
        * @param nomFichier {string} nom attribué au fichier téléchargé
        * @param typeDonnees {TYPE_DONNEES_A_SAUVER} type de données à enregistrer (Optionnel: par défaut TYPE_DONNEES_A_SAUVER.BLOB)
        */
        saveAs(data: any, type: TYPE_FICHIER, nomFichier: string, typeDonnees: TYPE_DONNEES_A_SAUVER, callback: () => void, callbackError: (erreur: Erreur) => void): void;
        /**
        * Renvoie un Blob à partir d'une chaine base64.
        * @param b64Data {string} données encodés en base 64.
        * @param contentType {string=} type MIME des données.
        * @param {number=} sliceSize taille du découpage pour la conversion en tableau d'entiers non signés.
        * @returns {Blob} Blob.
        */
        private b64toBlob(b64Data, contentType?, sliceSize?, callbackError?);
        /**
        * Traite les messages provenants de l'agent DonneesDelocaliseesAgent
        * @param event {Event} évènement
        * @param sendResponseCallback {ResponseCallback} objet contenant le callback de retour
        */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
        /**
        * Retourne le format MIME du fichier en fonction du type passé en paramètre
        * @param type {TYPE_FICHIER} type du fichier
        */
        getFormatFichier(type: TYPE_FICHIER): string;
    }
}


/**
* Module de gestion des habilitations
* @module fwkManager.Services.Habilitation
* @author Mathieu Dartigues
* classe : HabilitationManager - public - Classe permettant la gestion des habilitations
*/
declare module fwkManager.Services.Habilitation {
    class HabilitationManagerExtended {
        private manager;
        constructor(manager: HabilitationManager);
        EstHabilite(codes: string[]): IPromesse<boolean[]>;
        ChargerHabilitations(): IPromesse<HabilitationModel[]>;
        chargerHabilitationsTypee(type: EHabilitationType, forcerRechargement?: boolean): IPromesse<HabilitationModel[]>;
    }
    /**
     * Classe permettant la gestion des habilitations
     */
    class HabilitationManager extends Component.ComponentManagerBase {
        private _managerLibrary;
        Library: ManagerLibrary;
        contextKey: string;
        maximumTimeBeforeReload: number;
        private static CLASS_NAME;
        private static logger;
        constructor(managerLibrary: ManagerLibrary);
        /**
         * Transforme l'objet DTO du contexte en une liste d'habilitations (Clé/Valeur)
         *
         * @param  {HabilitationDTOModel}       dto l'objet DTO du contexte
         * @return {Object}                     Tableau d'objet avec comme clé le code de l'habilitation, et comme valeur la valeur de l'habilitation
         */
        private transformContextDTOIntoArray(dto);
        /**
         * Extrait de l'objet DTO les codes habilitations (autorisées) dans un tableau d'habilitations
         *
         * @param  {IHabilitationDTO}       dto l'objet DTO retourné par l'API
         * @return {Object[]}               Tableau d'objet avec comme clé le code de l'habilitation, et comme valeur la valeur de l'habilitation
         */
        private extractCodesDTOIntoArray(dto);
        /**
         * Concaténation des différents domaines des habilitations
         *
         * @param  {IHabilitationDTO}       dto l'objet DTO retourné par l'API
         * @return {string[]}               Tableau d'habilitations
         */
        private concatHabilitations(dto);
        private _HabilitationsOK(habilitations);
        /**
         * Permet d'obtenir l'état d'une ou plusieurs habilitations à partir de leurs codes
         *
         * @param  {string[]}                 codes Tableau de code habilitation
         * @return {IPromesse<boolean[]>}     Promesse renvoyant un tableau de booléen correspondant dans l'ordre aux habilitations demandées
         */
        EstHabilite(codes: string[]): IPromesse<boolean[]>;
        /**
         * Appelle l'API des habilitations pour récupérer les habilitations du central.
         * Permet aussi de réinitialiser les habilitations de l'utilisateur connecté.
         *
         * @return {IPromesse<any>} Promesse contenant un tableau d'habilitation
         */
        ChargerHabilitations(): IPromesse<HabilitationModel[]>;

        chargerHabilitationsTypee(type: EHabilitationType, forcerRechargement?: boolean): IPromesse<HabilitationModel[]>;

        /**
         * Obtient l'ensemble des habilitations stockées en local (contexte)
         *
         * @return {IPromesse<any>} Promesse contenant un tableau d'habilitations
         */
        ObtenirHabilitations(): IPromesse<any>;
        /**
         * Obtient une habilitation à partir de son code
         *
         * @param  {string}                         code Code de l'habilitation demandée
         * @return {IPromesse<HabilitationModel>}   Promesse contenant l'habilitation demandée (couple code / valeur)
         */
        ObtenirHabilitation(code: string): IPromesse<HabilitationModel>;
        /**
         * Modifie une habilitation localement, à partir du code habilitation et de sa valeur
         *
         * @param  {string}                       code   Le code habilitation à modifier
         * @param  {boolean}                      valeur La valeur cible
         * @return {IPromesse<HabilitationModel>}        Promesse contenant la nouvelle habilitation (couple code / valeur)
         */
        ModifierHabilitation(code: string, valeur: boolean): IPromesse<HabilitationModel>;
        /**
         * Supprime les habilitations du contexte
         *
         * @return {boolean} indique si l'opération de suppression s'est bien déroulée (true) ou pas (false)
         */
        SupprimerHabilitations(): boolean;
        /**
        * Traite les messages provenants de l'agent HabilitationAgent
        *
        * @param event {Event} évènement
        * @param sendResponseCallback {ResponseCallback} objet contenant le callback de retour
        */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}


declare module fwkManager.Services.Habilitation {
    interface IHabilitationApi {
        GetHabilitations(mysys: boolean, iam: boolean, cultureNet: boolean, infosUserPoste: fwkManager.Services.Context.InfosUserPoste, authentificationInfo: fwkManager.Services.Context.AuthentificationInfo): IPromesse<any>;
    }
}


/**
* Module de gestion des habilitations
* @module fwkManager.Services.Habilitation
* classe : HabilitationManager - public - Classe permettant la gestion des habilitations
*/
declare module fwkManager.Services.Habilitation {
    /**
    * Classe permettant la gestion des habilitations
    */
    class HabilitationApi extends Component.ComponentApiBase implements IHabilitationApi {
        private _habilitationUrl;
        constructor();
        /**
         * Permet de récupérer les habilitations
         *
         * @param  {boolean}                        mysys                       Domaine d'habilitation mysys
         * @param  {boolean}                        iam                         Domaine d'habilitation iam
         * @param  {boolean}                        cultureNet                  Domaine d'habilitation cultureNet
         * @param  {string}                         userAD                      Nom Active Directrory de l'utilisateur
         * @param  {string}                         domaineUtilisateur          Domaine Active Directrory de l'utilisateur
         * @param  {AuthentificationInfo}           authentificationInfo        Données personnelles de l'utilisateur
         * @return {IPromesse<IHabilitationDTO>}    DTO reçu par le service REST
         */
        GetHabilitations(mysys: boolean, iam: boolean, cultureNet: boolean, infosUserPoste: fwkManager.Services.Context.InfosUserPoste, authentificationInfo: fwkManager.Services.Context.AuthentificationInfo): IPromesse<IHabilitationsDTO>;
    }
}


/**
* Module de gestion des habilitations
* @module fwkManager.Services.Habilitation
* classe : HabilitationAgent - public - Classe permettant la gestion des habilitations
*/
declare module fwkManager.Services.Habilitation {
    /**
    * Classe permettant la gestion des habilitations
    */
    class PhantomHabilitationAgent implements IHabilitationAgent {
        private serviceManager;
        /**
         * Constructeur de la classe HabilitationAgent
         * @param {AgentLibrary}   agentLibrary  [description]
         * @param {ErreurCallback} errorCallback [description]
         */
        constructor(serviceManager: fwkManager.Services.ServiceManager);
        /**
         * Permet de récupérer une habilitation pour un utilisateur.
         *
         * Cette méthode ne prend qu'un seul code habilitation en paramètre.
         *
         * ~~~ts
         *
         * // Récupération de l'habilitation 'SHOP24' pour l'utilisateur authentifié
         * serviceAget.Habilitation.EstHabilite('SHOP24').then((result: boolean) => {
         * ...
         * }).catch((rreur: fwkManager.Services.Erreur) => {
         * ...
         * });
         * ~~~
         *
         * @param  {string}             codeHabilitation
         *
         * Code de la fonction, du processus,... exemple : SHOP24
         *
         * @return {IPromesse<boolean>}
         *
         * Promesse indiquant si oui(true) ou non(false) l'utilisateur est habilité au code habilitation passé en paramètre
         *
         */
        EstHabilite(codeHabilitation: string): IPromesse<boolean>;
        /**
         * Permet de récupérer plusieurs habilitations pour un utilisateur (Méthode à privilégier pour la récupération de plusieurs codes dans un même traitement)
         *
         * ~~~ts
         *
         * // Récupération des habilitations 'SHOP24', 'SHOMW1', 'SHOMW2' pour l'utilisateur authentifié
         * serviceAgent.Habilitation.EstHabilite(['SHOP24','SHOMW1','SHOMW2']).then((result: boolean []) => {
         * ...
         * }).catch((erreur: fwkManager.Services.Erreur) => {
         * ...
         * });
         * ~~~
         *
         * @param  {string[]}             codesHabilitation
         *
         * Codes des fonctions, des processus,... exemple : [‘SHOP24’,’SHOMW1’]
         *
         * @return {IPromesse<boolean[]>}
         *
         * Promesse indiquant si oui(true) ou non(false) l'utilisateur est habilité à chaque code habilitation passé en paramètre
         *
         */
        EstHabilite(codesHabilitation: string[]): IPromesse<boolean[]>;
    }
}


/**
* Module de gestion des impressions
* @module fwkManager.Services.Impression
* @methode controleGenerer – public - Permet de contrôler la génération de document d'impression
* @methode controleImprimer – public - Permet de contrôler le lancement d'une impression
* @methode controleGenererImprimer – public - Permet de contrôler la générétion et le lancement d'une impression
* @methode controleParametreActiveX – public - Permet de contrôler les paramètres envoyé à l'ActiveX pour le lancement d'une impression
*/
declare module fwkManager.Services.Impression {
    /**
    * Permet de contrôler la génération de document d'impression
    * @param data {any} Données à envoyer pour la génération du document d'impression
    * @param generationParams {GenerationParams} Paramètres pour la génération du document d'impression
    * @param callback {function} Action à executer une fois la génération effectuée
    * @param callbackError {function} Action à executer en cas d'erreur lors de la génération
    */
    function controleGenerer(data: any, generationParams: GenerationParams, callback: (fichier?: DocumentGenere) => void, callbackError: (erreur: Erreur) => void): string;
    /**
    * Permet de contrôler le lancement d'une impression
    * @param data {any} Données à envoyer pour l'impression du document
    * @param impressionParams {ImpressionParams} Paramètres pour l'impression du document
    * @param callback {function} Action à executer une fois l'impression effectuée
    * @param callbackError {function} Action à executer en cas d'erreur lors de l'impression
    */
    function controleImprimer(data: any, impressionParams: ImpressionParams, callback: (fichier?: DocumentGenere) => void, callbackError: (erreur: Erreur) => void): string;
    /**
    * Permet de contrôler le lancement d'une impression
    * @param data {any} Données à envoyer pour l'impression du document
    * @param generationParams {ImpressionParams} Paramètres pour l'impression du document
    * @param callback {function} Action à executer une fois l'impression effectuée
    * @param callbackError {function} Action à executer en cas d'erreur lors de l'impression
    */
    function controleImprimerLot(data: DocumentImpressionLot[], callback: () => void, callbackError: (erreur: Erreur) => void, parametresActiveXGlobaux?: ParametresActiveXGlobaux): string;
    /**
    * Permet de contrôler le lancement le contenu d'un lot d'impression
    * @param data {DocumentImpressionLot} L'un des documents du lot à imprimer
    * @param callback {function} Action à executer une fois l'impression effectuée
    * @param callbackError {function} Action à executer en cas d'erreur lors de l'impression
    */
    function controleDocumentImpressionLot(data: DocumentImpressionLot): string;
    /**
    * Permet de controler les paramètres d'impression
    * @param impressionParams {ImpressionParams} Paramètres pour l'impression du document
    */
    function controleImpressionParams(impressionParams: ImpressionParams): string;
    /**
    * Permet de contrôler la générétion et le lancement d'une impression
    * @param data {any} Données à envoyer pour la génération et l'impression d'un document
    * @param generationParams {GenerationParams} Paramètres pour la génération et l'impression d'un document
    * @param callback {function} Action à executer une fois la génération et l'impression effectuée
    * @param callbackError {function} Action à executer en cas d'erreur lors de la génération et/ou de l'impression
    */
    function controleGenererImprimer(data: any, generationImpressionParams: GenerationImpressionParams, callback: (fichier?: DocumentGenere) => void, callbackError: (erreur: Erreur) => void): string;
    /**
    * Permet de controler les paramètres ActiveX
    * @param params {ImpressionParams|GenerationParams} Paramètres pour l'impression et/ou la génération d'un document
    */
    function controleParametreActiveX(params: ImpressionParams | GenerationImpressionParams): string;
    /**
    * Permet de contrôler les paramètres individuels de l'ActiveX
    * @param params {ImpressionParams|GenerationParams} Paramètres pour l'impression et/ou la génération d'un document
    */
    function controleParametreActiveXIndividuels(params: ImpressionParams | GenerationImpressionParams): string;
    /**
    * Permet de contrôler les paramètres globaux de l'Active
    * @param params {ImpressionParams|GenerationParams|ParametresActiveXGlobaux} Paramètres pour l'impression ou la génération d'un document ou paramètres globaux pour l'ActiveX
    */
    function controleParametreActiveXGlobaux(parametresActiveXGlobaux: ParametresActiveXGlobaux): string;
}


/**
* Module de gestion des impressions
* @module fwkManager.Services.Impression
* @classe ImpressionManager - public - Classe permettant la gestion impressions
* @classe ImpressionParamObligatoires - public - Classe permettant de définir les paramètres d'impression
*/
declare module fwkManager.Services.Impression {
    /**
    * Classe permettant la gestion des impressions
    * @classe ImpressionManager
    * @methode gererErreur – private - Permet de gérer les erreurs captés
    * @methode generer – public - Permet de lancer une génération de document
    * @methode imprimer – public - Permet de lancer une impression de document
    * @methode imprimerLot - public - Permet de lancer une impression de document par lot
    * @methode genererImprimer – public - Permet de lancer une génération de document et une impression
    * @methode HandleMessage - public - Traite les messages provenant de l'agent ImpressionAgent
    */
    class ImpressionManager extends Component.ComponentManagerBase {
        private static CLASS_NAME;
        private static logger;
        /**
        * Constructeur de la classe ImpressionManager
        * @param managerLibrary {ManagerLibrary} La librairie d'impression du manager
        */
        constructor(managerLibrary: ManagerLibrary);
        /**
        * Obtenir les informations d'authentification
        * @param callbackError {function} Action à executer en cas d'erreur lors de l'obtention des informations d'authentification
        */
        getAuthentificationInfo(callbackError?: (erreur: Erreur) => void): fwkManager.Services.Context.AuthentificationInfo;
        /**
        * Permet de gérer les erreurs captés
        * @param erreur {string} Le message d'erreur
        * @param callbackError {function} Action à executer en cas d'erreur lors de la génération
        */
        gererErreur(libelleErreur: string, callbackError?: (erreur: Erreur) => void): void;
        /**
        * Permet de lancer une génération de document
        * @param data {any} Données à envoyer pour la génération du document d'impression
        * @param generationParams {GenerationParams} Paramètres pour la génération du document d'impression
        * @param callback {function} Action à executer une fois la génération effectuée
        * @param callbackError {function} Action à executer en cas d'erreur lors de la génération
        */
        generer(data: any, generationParams: GenerationParams, callback: (fichier?: DocumentGenere) => void, callbackError: (erreur: Erreur) => void): void;
        /**
        * Permet de lancer une impression de document
        * @param data {any} Données à envoyer pour l'impression (uniquement PDF)
        * @param impressionParams {ImpressionParams} Paramètres d'impression du document
        * @param callback {function} Action à executer une fois l'impression effectuée
        * @param callbackError {function} Action à executer en cas d'erreur lors de l'impression
        */
        imprimer(data: any, impressionParams: ImpressionParams, callback: () => void, callbackError: (erreur: Erreur) => void): void;
        /**
        * Permet de lancer une impression de document par lot
        * @param data {DocumentImpressionLot[]} Lot de documents à envoyer pour l'impression (uniquement PDF, avec possibilité de les récupérer en GED)
        * @param parametresActiveXGlobaux {ParametresActiveXGlobaux} Paramètres globaux de l'ActiveX d'impression
        * @param callback {function} Action à executer une fois l'impression effectuée
        * @param callbackError {function} Action à executer en cas d'erreur lors de l'impression
        */
        imprimerLot(data: DocumentImpressionLot[], parametresActiveXGlobaux: ParametresActiveXGlobaux, callback: () => void, callbackError: (erreur: Erreur) => void): void;
        /**
        * Permet de lancer une génération document et une impression
        * @param data {any} Données à envoyer pour la génération et l'impression
        * @param generationImpressionParams {generationImpressionParams} Paramètres de génération et d'impression du document
        * @param callback {function} Action à executer une fois la génération et l'impression effectuée
        * @param callbackError {function} Action à executer en cas d'erreur lors de la génération ou de l'impression
        */
        genererImprimer(data: any, generationImpressionParams: GenerationImpressionParams, callback: (fichier?: DocumentGenere) => void, callbackError: (erreur: Erreur) => void): void;
        /**
         *
         * @param data
         */
        getJsonConverti(data: any): IPromesse<{}>;
        /**
        * Traite les messages provenant de l'agent ImpressionAgent
        * @param event {Event} Evènement
        * @param sendResponseCallback {ResponseCallback} Objet contenant le callback de retour
        */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}

declare module fwkManager.Services.Impression {
    interface IImpressionApi {
        genererDocument(data: any, params: any, authentificationInfo: Context.AuthentificationInfo, callback: (fichier?: DocumentGenere) => void, callbackError: ErreurCallback): any;
        getJsonConverti(data: any): IPromesse<string>;
        imprimerDocument(data: any, params: any, callback: () => void, callbackError: ErreurCallback): any;
        imprimerDocumentLot(data: DocumentImpressionLot[], callback: () => void, callbackError: ErreurCallback, parametresActiveXGlobaux?: ParametresActiveXGlobaux): any;
        getDocumentGEDLot(documents: DocumentImpressionLot[], authentificationInfo: Context.AuthentificationInfo): IPromesse<any>;
    }
}


declare module fwkManager.Services.Impression {
    class ImpressionApiBase implements IImpressionApi {
        private static CLASS_NAME;
        protected static logger: Loggers.ILogger;
        private _urlDistantGeneration;
        private _urlGetFichierFromGED;
        constructor();
        isLocal(): boolean;
        genererDocument(data: any, params: any, authentificationInfo: Context.AuthentificationInfo, callback: (fichier?: DocumentGenere) => void, callbackError: ErreurCallback): void;
        convertJson(data: any): string;
        getJsonConverti(data: any): IPromesse<string>;
        imprimerDocument(data: any, params: any, callback: () => void, callbackError: ErreurCallback): void;
        imprimerDocumentLot(data: DocumentImpressionLot[], callback: () => void, callbackError: ErreurCallback, parametresActiveXGlobaux?: ParametresActiveXGlobaux): void;
        getDocumentGEDLot(documents: DocumentImpressionLot[], authentificationInfo: Context.AuthentificationInfo): IPromesse<any>;
        /**
        * Permet de gérer les erreurs captés
        * @param erreur {string} Le message d'erreur
        * @param callbackError {function} Action à executer en cas d'erreur lors de la génération
        */
        gererErreur(libelleErreur: string, callbackError?: (erreur: Erreur) => void): void;
    }
}


declare module fwkManager.Services.Impression {
    class ImpressionApiFullWeb extends ImpressionApiBase {
        constructor();
        imprimerDocument(data: any, params: any, callback: () => void, callbackError: ErreurCallback): void;
        imprimerDocumentLot(data: DocumentImpressionLot[], callback: () => void, callbackError: ErreurCallback, parametresActiveXGlobaux?: ParametresActiveXGlobaux): void;
    }
}


declare module fwkManager.Services.Impression {
    class ImpressionApiPetra extends ImpressionApiBase {
        private _urlLocal;
        constructor();
        imprimerDocument(data: any, params: any, callback: () => void, callbackError: ErreurCallback): void;
        imprimerDocumentLot(data: DocumentImpressionLot[], callback: () => void, callbackError: ErreurCallback, parametresActiveXGlobaux?: ParametresActiveXGlobaux): void;
        private _imprimerDocument(data, params, callback, callbackError);
        private _imprimerDocumentLot(data, callback, callbackError, parametresActiveXGlobaux?);
    }
}


declare module fwkManager.Services.Interop {
    class InteropManagerExtended {
        private manager;
        constructor(manager: InteropManager);
    }
    class InteropManager extends Component.ComponentManagerBase {
        private static CLASS_NAME;
        private static logger;
        private _messageBus;
        private _connectionId;
        private _disableStorageEvent;
        PortalType: string;
        static TempFolderPath: string;
        constructor(library: ManagerLibrary, portalType: string);
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
        Lancer(executableWrapper: Interop.ExecutableWrapper, contexte: Interop.ContexteMyway, parametres: string[], sync: boolean, event: MessageEvent, errorCallback: ErreurCallback): void;
        AddToContextInterop(level: string, key: string, value: string, event: MessageEvent, sendResponseCallback: Message.ResponseCallback, errorCallback: ErreurCallback): void;
        AddListToContextInterop(level: string, datas: fwkManager.Services.Context.IContextKeyValuePair[], event: MessageEvent, sendResponseCallback: Message.ResponseCallback, errorCallback: ErreurCallback): void;
        GetFromContextInterop(level: string, key: string, event: MessageEvent, sendResponseCallback: Message.ResponseCallback, errorCallback: ErreurCallback): void;
        GetListFromContextInterop(level: string, datas: string[], event: MessageEvent, sendResponseCallback: Message.ResponseCallback, errorCallback: ErreurCallback): void;
        EndTransition: (processCode: any) => void;
        EndStep(): void;
        NotifyEndProcessus(processId: string): void;
        private _notifierFinProcessusInterop(processId, datas);
        NotifyBeginProcessus(processId: string): void;
        NotifierChangementNomProcessus(processId: string, nomProcessus: string): void;
        AfficherWindowParHandle(handle: string, affiche: boolean): void;
        AfficherWindowParPid(pid: string, affiche: boolean): void;
        AfficherSynthese(numeroClient: string): void;
        ActiverApplicationAppelante(numeroPlan: string): void;
        GetVarEnv(nom: string, callback: (nom: string) => void, errorCallback: ErreurCallback): void;
        GetRegistryValue(niveau: string, souscle: string, nom: string, callback: (any) => void, errorCallback: ErreurCallback): void;
        LireFichier(pathFichier: string, callback: (data: string) => void, errorCallback: ErreurCallback): void;
        GetInfoFichier(pathFichier: string, callback: (data: InfoFichier) => void, errorCallback: ErreurCallback): void;
        EcrireFichier(pathFichier: string, fluxdonnees: string, ajouter: boolean, creeDir: boolean, callback: (retour: string) => void, errorCallback: ErreurCallback): void;
        private _subscribeToEvent(processesId);
        private static _instance;
        private static _onEvent(event, callback);
        private static _onAcceptEvent(event);
        private static _onConnection(connectionId);
        private _shelveEvent(event);
        Deliver(event: InteropMessageEvent, successCallback: any, unsuccessCallback: () => void): void;
        DeliverUndeliveredMessage(stepId: string, callback: () => void): void;
        private _deliverMessages(messageEvents, callback);
        private _deliverMessage(event, successCallback, unsuccessCallback);
        private _handlePortalMessage(event, successCallback, unsuccessCallback);
        ClearBus(): void;
        Bus: InteropMessageBus;
        OnInteropMessageBusStorageChanged(): void;
        TestLocalService(): void;
        TriggerNotifications(event: MessageEvent, sendResponse: Message.ResponseCallback): void;
    }
}


declare module fwkManager.Services.Interop {
    interface IInteropApi {
        Lancer(executableWrapper: Interop.ExecutableWrapper, contexte: Interop.ContexteMyway, parametres: string[], sync: boolean, callback: ErreurCallback): any;
        AddToContextInterop(level: string, key: string, value: string, callback: (any) => void, errorCallback: ErreurCallback): any;
        AddListToContextInterop(level: string, datas: fwkManager.Services.Context.IContextKeyValuePair[], callback: (any) => void, errorCallback: ErreurCallback): any;
        GetVarEnv(nom: string, callback: (valeur: string) => void, errorCallback: ErreurCallback): any;
        GetRegistryValue(niveau: string, souscle: string, nom: string, callback: (any) => void, errorCallback: (error) => void): any;
        EcrireFichier(pathFichier: string, fluxdonnees: string, ajouter: boolean, creeDir: boolean, callback: (retour: string) => void, errorCallback: ErreurCallback): any;
        LireFichier(pathFichier: string, callback: (data: string) => void, errorCallback: ErreurCallback): any;
        GetInfoFichier(pathFichier: string, callback: (infoFichier: Interop.InfoFichier) => void, errorCallback: ErreurCallback): any;
        AfficherWindowParHandle(handle: string, affiche: boolean): any;
        AfficherWindowParPid(pid: string, affiche: boolean): any;
        AfficherSynthese(numeroClient: string): any;
        ActiverApplicationAppelante(numeroPlan: string): any;
        NotifierFinStep(stepId: string): any;
        NotifierEtatProcessus(processId: string, etat: string): any;
        NotifierFinProcessus(processId: string, datas: fwkManager.Services.Context.IContextKeyValuePair[]): any;
        NotifierChangementNomProcessus(processid: string, nomProcessus: string): any;
        SubscribeToEvent(onEvent: (event: fwkManager.Services.Interop.InteropMessageEvent, callback: () => void) => void, onAcceptEvent: (event: fwkManager.Services.Interop.InteropMessageEvent) => boolean, onConnection: (connectionId: string) => void): any;
        TestLocalService(): any;
        GetListFromContextInterop(level: string, datas: string[], callback: (returnDatas: fwkManager.Services.Context.IContextKeyValuePair[]) => void, errorCallback: ErreurCallback): any;
        GetFromContextInterop(level: string, key: string, callback: (returnData: string) => void, errorCallback: ErreurCallback): any;
        GetCommonDataInteropToUpdate(callback: (dataInterop: string[]) => void): any;
    }
}


declare module fwkManager.Services.Interop {
    class InteropApi implements IInteropApi {
        constructor();
        Lancer(executableWrapper: Interop.ExecutableWrapper, contexte: Interop.ContexteMyway, parametres: string[], sync: boolean, callback: ErreurCallback): void;
        AddToContextInterop(level: string, key: string, value: string, callback: (any) => void, errorCallback: ErreurCallback): void;
        AddListToContextInterop(level: string, datas: fwkManager.Services.Context.IContextKeyValuePair[], callback: (any) => void, errorCallback: ErreurCallback): void;
        GetListFromContextInterop(level: string, datas: string[], callback: (returnDatas: fwkManager.Services.Context.IContextKeyValuePair[]) => void, errorCallback: ErreurCallback): void;
        GetFromContextInterop(level: string, key: string, callback: (returnData: string) => void, errorCallback: ErreurCallback): void;
        GetVarEnv(nom: string, callback: (valeur: string) => void, errorCallback: ErreurCallback): void;
        GetRegistryValue(niveau: string, souscle: string, nom: string, callback: (any) => void, errorCallback: (error) => void): void;
        EcrireFichier(pathFichier: string, fluxdonnees: string, ajouter: boolean, creeDir: boolean, callback: (retour: string) => void, errorCallback: ErreurCallback): void;
        LireFichier(pathFichier: string, callback: (data: string) => void, errorCallback: ErreurCallback): void;
        GetInfoFichier(pathFichier: string, callback: (infoFichier: Interop.InfoFichier) => void, errorCallback: ErreurCallback): void;
        AfficherWindowParHandle(handle: string, affiche: boolean): void;
        AfficherWindowParPid(pid: string, affiche: boolean): void;
        AfficherSynthese(numeroClient: string): void;
        ActiverApplicationAppelante(numeroPlan: string): void;
        ActiverWindow(handle: string): void;
        NotifierFinStep(stepId: string): void;
        NotifierEtatProcessus(processId: string, etat: string): void;
        NotifierFinProcessus(processId: string, datas: fwkManager.Services.Context.IContextKeyValuePair[]): void;
        NotifierChangementNomProcessus(processId: string, nomProcessus: string): void;
        ActiverApplication(handle: string, active: boolean): void;
        GetHandlePetra(callback: (handle) => void): void;
        SubscribeToEvent(onEvent: (event: fwkManager.Services.Interop.InteropMessageEvent, callback: () => void) => void): void;
        TestLocalService(): void;
        SendConnectionInfo(portalType: string, processesId: string[]): void;
        GetCommonDataInteropToUpdate(callback: (dataInterop: string[]) => void): void;
    }
}

declare module fwkManager.Services.Interop {
    class InteropMessageBus {
        private _messages;
        StorageNotification: Persistence.StorageInstance<any>;
        constructor();
        private _setMessages();
        private _init();
        Notify(): void;
        Add(event: InteropMessageEvent): void;
        SpliceByStepId(processStepId: any): InteropMessageEvent[];
        Clear(): void;
        Messages: InteropMessageEvent[];
    }
    class InteropMessageEvent {
        ProcessStepId: string;
        DeliverTries: number;
        Subject: string;
        Contenu: any;
    }
}


declare module fwkManager.Services.Interop {
    class InteropApiWindows extends Component.ComponentApiBase implements IInteropApi {
        private _localServiceUrl;
        private _connectionId;
        private _onEvent;
        private _onAcceptEvent;
        private _onConnection;
        constructor();
        TestLocalService(): void;
        Lancer(executableWrapper: Interop.ExecutableWrapper, contexte: Interop.ContexteMyway, parametres: string[], sync: boolean, callback: ErreurCallback): void;
        AddToContextInterop(level: string, key: string, value: string, callback: (any) => void, errorCallback: ErreurCallback): void;
        AddListToContextInterop(level: string, datas: fwkManager.Services.Context.IContextKeyValuePair[], callback: (any) => void, errorCallback: ErreurCallback): void;
        GetFromContextInterop(level: string, key: string, callback: (returnData: string) => void, errorCallback: ErreurCallback): void;
        GetListFromContextInterop(level: string, datas: string[], callback: (returnDatas: fwkManager.Services.Context.IContextKeyValuePair[]) => void, errorCallback: ErreurCallback): void;
        GetVarEnv(nom: string, callback: (any) => void, errorCallback: ErreurCallback): void;
        GetRegistryValue(niveau: string, souscle: string, nom: string, callback: (valeur: string) => void, errorCallback: ErreurCallback): void;
        LireFichier(pathFichier: string, callback: (data: string) => void, errorCallback: ErreurCallback): void;
        GetInfoFichier(pathFichier: string, callback: (infoFichier: Interop.InfoFichier) => void, errorCallback: ErreurCallback): void;
        EcrireFichier(pathFichier: string, fluxdonnees: string, ajouter: boolean, creeDir: boolean, callback: (valeur: string) => void, errorCallback: ErreurCallback): void;
        AfficherWindowParHandle(handle: string, affiche: boolean): void;
        AfficherWindowParPid(pid: string, affiche: boolean): void;
        AfficherSynthese(numeroClient: string): void;
        ActiverApplicationAppelante(numeroPlan: string): void;
        NotifierFinStep(stepId: string): void;
        NotifierEtatProcessus(processId: string, etat: string): void;
        NotifierFinProcessus(processId: string, datas: fwkManager.Services.Context.IContextKeyValuePair[]): void;
        NotifierChangementNomProcessus(processId: string, nomProcessus: string): void;
        NotifierNomProcessus(name: string, processId: string): void;
        SubscribeToEvent(onEvent: (event: fwkManager.Services.Interop.InteropMessageEvent, callback: () => void) => void, onAcceptEvent: (event: fwkManager.Services.Interop.InteropMessageEvent) => boolean, onConnection: (connectionId: string) => void): void;
        GetCommonDataInteropToUpdate(callback: (dataInterop: string[]) => void): void;
        private _setConnection(id);
        private _treatMessage(message);
        private _disconnect();
    }
}


/**
* Module de gestion des jab
* @module fwkManager.Services.JAB
* classe : JABManager - public - Classe permettant la gestion des Journaux d'Archivage Bancaires
*/
declare module fwkManager.Services.JAB {
    /**
    * Classe permettant la gestion des habilitations
    */
    class JABManager extends Component.ComponentManagerBase {
        private static CLASS_NAME;
        private static logger;
        constructor(managerLibrary: ManagerLibrary);
        Enregistrer(data: string): IPromesse<boolean>;
        /**
        * Traite les messages provenants de l'agent JABAgent
        * @param event {Event} évènement
        * @param sendResponseCallback {ResponseCallback} objet contenant le callback de retour
        */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}


declare module fwkManager.Services.JAB {
    interface IJABApi {
        Enregistrer(data: string): IPromesse<boolean>;
    }
}


/**
* Module de gestion des habilitations
* @module fwkManager.Services.JAB
* classe : JABManager - public - Classe permettant la gestion des habilitations
*/
declare module fwkManager.Services.JAB {
    /**
    * Classe permettant la gestion des habilitations
    */
    class JABApi extends Component.ComponentApiBase implements IJABApi {
        private _jabUrl;
        constructor();
        Enregistrer(data: string): IPromesse<boolean>;
    }
}


declare module fwkManager.Services.Libelle {
    class LibelleManager extends Component.ComponentManagerBase {
        private static CLASS_NAME;
        private static logger;
        private _managerLibrary;
        constructor(managerLibrary: ManagerLibrary);
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
        constituerLibelle(codeLibelle: string, valeurs?: string[]): string;
        private codeValeurs(codeLibelle, valeurs?);
        afficherMessage(codeLibelle: string, typeAffichage: TYPE_AFFICHAGE, valeurs?: string[], delai?: number, callback?: (retour: any) => void, onModaleOuverte?: () => void): void;
        afficherMessageAsync(codeLibelle: string, typeAffichage: TYPE_AFFICHAGE, success: (retour: any) => void, valeurs?: string[], delai?: number): void;
        Notify(notification: NotificationMessage, success: () => void): void;
    }
}


declare module fwkManager.Services.Lisa {
    class ResultBase {
        ProchaineEtape: EtapeResult;
        ProcessDemarre: ProcessResult;
        Init(data: any): void;
    }
    class NextResult extends ResultBase {
        CodeEtape: string;
        ValeurSortie: number;
        FinProcess: boolean;
        ValeurFinProcess: number;
        constructor(nextData: any);
    }
    class StartResult extends ResultBase {
        CodeProcessus: string;
        constructor(startData: any);
    }
    class ProcessResult {
        Code: string;
        Nom: string;
        EtapesConnues: string[];
        CodeEtape: string;
        OptionsProcess: string;
        OptionsProcessAsEtape: string;
        Actions: ActionResult[];
        constructor(processData: any);
    }
    class EtapeResult {
        TypeApplication: string;
        ValeurEntree: number;
        CodeApplication: string;
        NomApplication: string;
        CodeEtape: string;
        CodeMetier: string;
        Icone: string;
        LocalisationAbsolue: string;
        LocalisationRelative: string;
        Contrats: ContratResult[];
        Actions: ActionResult[];
        OptionsEtape: string;
        OptionsPointEntree: string;
        constructor(etapeData: any);
    }
    class ContratResult {
        Code: string;
        Type: string;
        Longueur: number;
        Nullable: boolean;
        Mode: string;
        OptionsContrat: string;
        constructor(contratData: any);
    }
    class ActionResult {
        ValeurSortie: number;
        EstExterne: boolean;
        NomExterne: string;
        OptionsAction: string;
        ValeursFinProcessPossibles: number[];
        constructor(actionData: any);
    }
    class ApplicationResult {
        Nom: string;
        Icone: string;
        Url: string;
        constructor(Nom: string, Icone: string, Url: string);
    }
}


declare module fwkManager.Services.Lisa {
    class LisaManagerExtended {
        private manager;
        constructor(manager: LisaManager);
        StartProcess(processCode: string, standAlone?: boolean, initData?: IInitialisationData, valeurDepart?: number): IPromesse<LisaCallbackResult>;
        StartUrl(name: string, url: string, standAlone?: boolean): IPromesse<LisaCallbackResult>;
        Next(valeurSortie: number): IPromesse<LisaCallbackResult>;
    }
    class LisaManager extends Component.ComponentManagerBase {
        private _modeVerificationProcessus;
        private static CLASS_NAME;
        private static logger;
        private _authorizedDomains;
        private _currentStepCode;
        Library: ManagerLibrary;
        appIFrame: JQuery;
        appIFrameUrl: string;
        onFinProcessus: (processId: string) => void;
        private _logOnUrl;
        DisplayProcessesOnProcessEnd: boolean;
        constructor(managerLibrary: ManagerLibrary, _modeVerificationProcessus: ModeVerificationProcessus);
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
        EndTransition: (res: LisaCallbackResult) => void;
        StartStandaloneProcessWithInitialisation(processCode: string, initData: IInitialisationData, callback: (res: LisaCallbackResult) => void, errorCallback: ErreurCallback): any;
        StartStandaloneProcessWithInitialisation(processCode: string, valeurDepart: number, initData: IInitialisationData, callback: (res: LisaCallbackResult) => void, errorCallback: ErreurCallback): any;
        StartUrl(name: string, url: string, callback: (res: LisaCallbackResult) => void, errorCallback: ErreurCallback): void;
        Next(valeurSortie: number, callback: (res: LisaCallbackResult) => void, errorCallback: ErreurCallback, previous?: boolean): void;
        ReplaceTokens(url: any, codeContrats: string[]): string;
        Start(processCode: string, callback: (res: LisaCallbackResult) => void, errorCallback: ErreurCallback): any;
        Start(processCode: string, valeurDepart: number, callback: (res: LisaCallbackResult) => void, errorCallback: ErreurCallback): any;
        StartStandaloneProcess(processCode: string, callback: (res: LisaCallbackResult) => void, errorCallback: ErreurCallback): any;
        StartStandaloneProcess(processCode: string, valeurDepart: number, callback: (res: LisaCallbackResult) => void, errorCallback: ErreurCallback): any;
        Previous(callback: (res: LisaCallbackResult) => void, errorCallback: ErreurCallback): void;
        private _getPrevious(currentProcess, currentStep);
        private _startSubProcess(processCode, valeurDepart?);
        /**
         * Méthode permettant le démarrage d'un processus Lisa
         * - récupère les données du processus auprès de l'API Lisa
         * - récupère les données de l'aide flash
         * - démarre le processus
         * @param {string}                 processCode   Code du processus Lisa
         * @param {number}                 valeurDepart  [description]
         * @param {string}                 inProcessType [description]
         * @param {IInitialisationData}    initData      [description]
         * @param {LisaCallbackResult) =>            void}        callback Callback de succès
         * @param {ErreurCallback}         errorCallback [description]
         */
        private _start(processCode, valeurDepart, inProcessType, initData, callback, errorCallback);
        private _getProcesses(callback, errorCallback?);
        /**
        * Récupère les codes des processus LISA
        */
        private _getCodesProcessus();
        /**
        * Récupère les infos d'un processus LISA
        * @param {string}   codeProcessus
        * code du processus
        */
        private _getInfoProcessus(codeProcessus);
        private _getTools(callback, errorCallback?);
        private _sendMessageToCurrentStep(currentStep, recipient, subject, content, callback, errorCallback?);
        private _handleNext(stepCode, valeurSortie, next, callback, errorCallback);
        private _notifyEndProcessus();
        private _launchNextStep(next, inProcessType, initData, callback);
        private _evaluateUrl(etape);
        private _addModeMyWay(url);
        private _finalizeCallbackResultValues(callbackResult);
        private _handlePreviousSteps(next, currentProcess);
        private _translateContext(codeContrats, level);
        private _prepareNavigation(nextEtapes, processId, callback);
        private static _setNextSteps(lisaClientPortailInstance, managerLibrary, stepId, nextEtapes, boundId, endCallback);
        private static _setNextStep(lisaClientPortailInstance, managerLibrary, step, nextEtape, nextEtapes, boundId, continueCallback, endCallback);
    }
}


declare module fwkManager.Services.Lisa {
    interface ILisaApi {
        Next(codeEtape: string, valeurSortie: number): IPromesse<NextResult>;
        Start(codeProcess: string, valeurDepart: number): IPromesse<StartResult>;
        GetProcesses(callback: (processes: ProcessResult[]) => void, errorCallback?: ErreurCallback): any;
        GetTools(callback: (tools: ApplicationResult[]) => void, errorCallback?: ErreurCallback): any;
        /**
        * Récupère les codes des processus LISA
        */
        GetCodesProcessus(): IPromesse<string[]>;
        /**
        * Récupère les infos d'un processus LISA
        * @param {string}   codeProcessus
        * code du processus
        */
        GetInfoProcessus(coeProcessus: string): IPromesse<IInfoProcessus>;
        GetHabilitationProcessus(codeProcessus: string): IPromesse<string>;
        GetAddOns(): IPromesse<IAddOns>;
    }
}


declare module fwkManager.Services.Lisa {
}


declare module fwkManager.Services.Lisa {
    class LisaComposantApplicatif {
        Nom: string;
        LocalisationAbsolue: string;
        Type: string;
        constructor(nom: string, localisationAbsolue: string, type: string, placeholders?: any);
    }
    interface ElementDeProcessus {
        Code: string;
        Nom: string;
        Type: string;
        Options: string;
    }
    class LisaPointEntree implements ElementDeProcessus {
        ComposantApplicatif: LisaComposantApplicatif;
        Nom: string;
        Code: string;
        Icone: string;
        LocalisationRelative: string;
        Type: string;
        EstUnOutil: boolean;
        Options: string;
        constructor(composantApplicatif: LisaComposantApplicatif, nom: string, code: string, icone: string, localisationRelative: string, estUnOutil?: boolean);
    }
    class LisaProcess implements ElementDeProcessus {
        Code: string;
        Nom: string;
        Type: string;
        Options: string;
        Habilitation: string;
        constructor(code: string, nom: string, options: string, habilitation: string);
    }
    class LisaEtape {
        Code: string;
        CodeMetier: string;
        ElementDeProcessus: ElementDeProcessus;
        InProcess: LisaProcess;
        ValeurEntree: number;
        ValeurDepartProcessus: number;
        Options: string;
        Actions: LisaAction[];
        constructor(code: string, elementDeProcessus: ElementDeProcessus, codeMetier: string, inProcess: LisaProcess, valeurEntree: number, valeurDepartProcessus: number, options: string);
    }
    class LisaAction {
        Etape: LisaEtape;
        ValeurSortie: number;
        VersEtape: LisaEtape;
        EstExterne: boolean;
        NomExterne: string;
        FinProcess: boolean;
        ValeurFinProcess: number;
        ValeursFinProcessPossibles: number[];
        constructor(etape: LisaEtape, valeurSortie: number, versEtape: LisaEtape, estExterne: boolean, nomExterne: string, finProcess?: boolean, valeurFinProcess?: number);
    }
    class LisaContrat {
        PointEntree: LisaPointEntree;
        Code: string;
        Longueur: number;
        Mode: string;
        Nullable: boolean;
        Type: string;
        constructor(pointEntree: LisaPointEntree, code: string, longueur: number, mode: string, nullable: boolean, type: string);
    }
    class FakeLisaApi implements ILisaApi {
        private _isLocalServiceAvailable;
        composantsApplicatifs: LisaComposantApplicatif[];
        pointDEntrees: LisaPointEntree[];
        contrats: LisaContrat[];
        etapes: LisaEtape[];
        actions: LisaAction[];
        processes: LisaProcess[];
        addOns: IAddOns;
        constructor(environment: string, placeholders: any, isLocalServiceAvailable?: boolean, authorizedDomains?: string[]);
        AddSettingsFromJSON(environment: string, placeholders: any): void;
        Next(codeEtape: string, valeurSortie: number): IPromesse<NextResult>;
        Start(codeProcessus: string, valeurDepart: number): IPromesse<StartResult>;
        GetProcesses(callback: (processes: ProcessResult[]) => void, errorCallback?: ErreurCallback): void;
        GetTools(callback: (tools: ApplicationResult[]) => void, errorCallback?: ErreurCallback): void;
        SetSequencePE(etape: LisaEtape): Services.Lisa.EtapeResult;
        SetSequencePR(process: LisaProcess, valeurDepart: number): Services.Lisa.EtapeResult;
        GetDepart(codeProcess: string, valeurDepartProcessus?: number): LisaEtape;
        GetEtape(codeEtape: string): LisaEtape;
        getActionsForAStep(codeProcess: string, codeProcessElement: string): LisaAction[];
        getKnownSteps(codeProcess: string): string[];
        getSortiesPossiblesPourEtapeEtSortie(etape: LisaEtape, valeurSortie: number): number[];
        getSortiesPossiblesPourEtape(etape: LisaEtape): number[];
        /**
        * Récupère les codes des processus LISA
        */
        GetCodesProcessus(): IPromesse<string[]>;
        /**
        * Récupère les infos d'un processus LISA
        * @param {string}   codeProcessus
        * code du processus
        */
        GetInfoProcessus(coeProcessus: string): IPromesse<IInfoProcessus>;
        GetHabilitationProcessus(codeProcessus: string): IPromesse<string>;
        GetAddOns(): IPromesse<IAddOns>;
    }
}


declare module fwkManager.Services.Lisa {
    class LisaApiBase extends FakeLisaApi implements ILisaApi {
        private _lisaUrl;
        private _referentielProcessusSiUrl;
        constructor(environment: string, placeholders: any, isLocalServiceAvailable?: boolean, authorizedDomains?: string[]);
        Next(codeEtape: string, valeurSortie: number): IPromesse<NextResult>;
        Start(codeProcessus: string, valeurDepart: number): IPromesse<StartResult>;
        private _next(codeEtape, valeurSortie);
        private _start(codeProcessus, valeurDepart);
        private _handleSubProcess(next, addOn);
        GetProcesses(callback: (processes: ProcessResult[]) => void, errorCallback?: ErreurCallback): void;
        GetTools(callback: (tools: ApplicationResult[]) => void, errorCallback?: ErreurCallback): void;
        /**
        * Récupère les codes des processus LISA
        */
        GetCodesProcessus(): IPromesse<string[]>;
        /**
        * Récupère les infos d'un processus LISA
        * @param {string}   codeProcessus
        * code du processus
        */
        GetInfoProcessus(codeProcessus: string): IPromesse<IInfoProcessus>;
        GetHabilitationProcessus(codeProcessus: string): IPromesse<string>;
        GetAddOns(): IPromesse<IAddOns>;
        private _getEtapeAddOn(codeEtape);
    }
}


declare module fwkManager.Services.Lisa {
    class LisaApiFullWeb extends LisaApiBase {
        constructor();
    }
}


declare module fwkManager.Services.Lisa {
    class LisaApiWindows extends LisaApiBase {
        private _surchargeNext;
        private _surchargeStart;
        private _localServiceUrl;
        constructor();
        Next(codeEtape: string, valeurSortie: number): IPromesse<NextResult>;
        Start(codeProcessus: string, valeurDepart: number): IPromesse<StartResult>;
        GetProcesses(callback: (processes: ProcessResult[]) => void, errorCallback?: ErreurCallback): void;
        private GetSurchargeNext(callback);
        private GetSurchargeStart(callback);
    }
}


declare module fwkManager.Services.Lisa {
    class PhantomLisaAgent implements ILisaAgent {
        private serviceManager;
        constructor(serviceManager: fwkManager.Services.ServiceManager);
        Next(valeurSortie: number): IPromesse<LisaCallbackResult>;
        NextWithStep(stepCode: string, valeurSortie: number): IPromesse<LisaCallbackResult>;
    }
}


declare module fwkManager.Services.Message {
    class MessageManagerBase extends MessageBase {
        private static _instance;
        private _iframesServicesAgents;
        constructor(library: Component.IComponentLibrary, otherWindow: Window, uri: string);
        Dispose(): void;
        setServiceAgentSurIframe(pIIFrameId: string, pServiceAgentId: string): void;
        protected postMessage(pMessage: IFrameMessage, pTargetWindow: Window, pTargetDomain: string, pIIFrameId: string): void;
        protected _postMessage(pMessage: IFrameMessage, pTargetWindow: Window, pTargetDomain: string, pIIFrameId: string): void;
        protected transmettreMessageAvecOrdre(event: MessageEvent): void;
    }
    class MessageManager extends MessageManagerBase implements IMessageService {
        constructor(library: Component.IComponentLibrary);
    }
    class MobileMessageManager extends MessageManagerBase implements IMessageService {
        constructor(library: Component.IComponentLibrary);
        protected _postMessage(pMessage: IFrameMessage, pTargetWindow: Window, pTargetDomain: string, pIIFrameId: string): void;
    }
    class MessageManagerFactory {
        static CreateMessageManager(library: Component.IComponentLibrary): void;
    }
}


/**
* Module de gestion de la mobilité : Permet de récupérer les informations de l'environnement utilisateur
* @module fwkManager.Services.Mobilite
* @author Laurie Marchaterre
*/
declare module fwkManager.Services.Mobilite {
    /**
    *  Classe permettant d'accéder aux données de mobilité
    */
    class MobiliteManager extends Component.ComponentManagerBase {
        private _managerLibrary;
        Library: ManagerLibrary;
        private contextKey;
        private static CLASS_NAME;
        private static logger;
        constructor(managerLibrary: ManagerLibrary);
        /**
         * Méthode qui récupère dans le context (parametresCompatables) si on a une caisse automatique connectées
         * @return {boolean} retourne 'true' si on a une caisse connectée sinon 'false'
         */
        private getCaisseAuto();
        /**
         * Méthode qui vérifie que l'écran de l'utilisateur est tactile
         * @return {IPromesse<boolean>}   Si true, on a un écran tactile, on retourne false.
         */
        private getEcranTactile();
        /**
         * Méthode qui récupère dans le navigateur utilisé par l'utilisateur
         * @return {object} INavigateur : retourne le nom et la version du navigateur
         */
        private getNavigateur();
        /**
         * Méthode qui récupère dans la plateforme (système d'exploitation) du poste utilisateur
         * @return {export const enum} PLATEFORME : retourne le type de plateforme
         */
        private getPlateforme();
        /**
         * Méthode qui retourne la résolution de l'écran du poste utilisateur
         * @return
         */
        private getResolutionEcran();
        /**
         * Méthode qui récupère la liste les informations de la machine de l'utilisateur.
         * Les informations retournées sont :
         *     - La plateforme
         *     - La largeur de l'écran
         *     - La hauteur de l'écran
         *     - La résolution Minimale MyWay (boolean)
         *     - Ecran tactile (boolean)
         *     - Le navigateur
         * @return {IPromesse<IInfoMachine>} : IInfoMachine
         * ~~~ts
         * serviceManager.mobilite.getInfoMachine().then((result: IInfoMachine) => {
         *  // Renvoi les infos machine
         * }).catch((erreur: fwkManager.Services.Erreur) => {
         *  // Renvoi une erreur
         * });
         * ~~~
         */
        getInfoMachine(): IPromesse<IInfoMachine>;
        /**
         * Permet de savoir si on est connecté à un réseau
         * @return {IPromesse<string>} : retourne 'true' si on est connecté, sinon 'false'
         */
        private estConnecte();
        /**
         * Détermine à quel type de réseau correspond l'adresse IP.
         * @param {string} : adresse IP Client
         * @return {TYPE_RESEAU} : retourne le type de réseau sur lequel on est connecté
         */
        private determinerTypeReseau(adresseIpClient);
        /**
         * Détermine si l'adresse IP (1er param) fait partir de la plage réseau (2ème param).
         * @param {string} : adresse IP Client convertir en binaire
         * @param {Array<IPlageReseau>} : tableau contenant les plages réseaux interne
         * @return {boolean} : retourne 'true' si l'adresse fait partie de la plage réseau
         */
        private existeDansPlagesReseau(adresseBinaireClient, plagesReseau);
        /**
         * Permet de savoir à quel type de réseau on est connecté.
         * @return {IPromesse<TYPE_RESEAU>}
         *      - CONNECTE : Connecté (réseau inconnu)
         *      - OFFLINE: Déconnecté
         *
         * ~~~ts
         * serviceManager.mobilite.getReseau().then((result: TYPE_RESEAU) => {
         * // Renvoi le type de connexion
         * ...
         * * }).catch((erreur: fwkManager.Services.Erreur) => {
         * // Renvoi une erreur
         * ...
         * });
         * ~~~
         */
        getReseau(): IPromesse<TYPE_RESEAU>;
        /**
         * Méthode qui récupère la liste des périphériques connectés.
         * Les périphériques retournées sont :
         *     - Les caisses auto
         *     - Les tablettes de signature Wacom
         * @return {IPromesse<IPeripherique[]>} liste de IPeripherique
         * ~~~ts
         * serviceManager.mobilite.getPeripheriques().then((result: IPeripherique[]) => {
         *  // Renvoi un tableau de Peripherique
         * }).catch((erreur: fwkManager.Services.Erreur) => {
         *  // Renvoi une erreur
         * });
         * ~~~
         */
        getPeripheriques(): IPromesse<IPeripherique[]>;
        /**
         * Méthode qui récupère la liste des périphériques connectés par Type.
         * @return {IPromesse<T[]>} liste de périphériques du type demandé
         * ~~~ts
         * serviceManager.mobilite.getPeripheriquesParType().then((result: T[]) => {
         *  // Renvoi un tableau de Peripherique
         * }).catch((erreur: fwkManager.Services.Erreur) => {
         *  // Renvoi une erreur
         * });
         * ~~~
         */
        getPeripheriquesParType<T extends IPeripherique>(type: TYPE_PERIPHERIQUE): IPromesse<T[]>;
        /**
         * Méthode qui appel le Service Local pour savoir si on a des tablettes de signatures Wacom connectées
         * @return {ITabletteSignature[]} retourne  les listes des tablettes de signature Wacom connectées
         */
        private getTablettesSignatures();
        /**
        * Traite les messages provenants de l'agent MobiliteAgent
        * @param event {Event} évènement
        * @param sendResponseCallback {ResponseCallback} objet contenant le callback de retour
        */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}


declare module fwkManager.Services.Mobilite {
    interface IMobiliteApi {
        estConnecte(): IPromesse<boolean>;
        estEcranTactile(): IPromesse<boolean>;
        listeTablettesSignatures(): IPromesse<Mobilite.ITabletteSignature[]>;
        getPlateforme(): IPromesse<PLATEFORME>;
        getResolutionEcran(): IPromesse<IResolutionEcranDTO>;
    }
    interface ITabletteSignatureDTO {
        TypePeripherique: number;
        Info: string;
    }
    interface IResolutionEcranDTO {
        largeur: number;
        hauteur: number;
    }
    class ResolutionEcranDTO implements IResolutionEcranDTO {
        protected _largeur: number;
        protected _hauteur: number;
        constructor(_largeur?: number, _hauteur?: number);
        largeur: number;
        hauteur: number;
    }
}


/**
* Module de gestion de la mobilite
* @module fwkManager.Services.Mobilite
*/
declare module fwkManager.Services.Mobilite {
    /**
    *  Classe permettant d'accéder aux données de mobilité
    */
    class MobiliteApiBase extends Component.ComponentApiBase implements IMobiliteApi {
        constructor();
        /**
         * Méthode qui vérifie si on est connecté.
         * @return {IPromesse<boolean>}   Si true, on est bien connecté, on retourne false.
         */
        estConnecte(): IPromesse<boolean>;
        /**
         * Méthode qui vérifie que l'écran de l'utilisateur est tactile.
         * @return {IPromesse<boolean>}   Si true, on a un écran tactile, on retourne false.
         */
        estEcranTactile(): IPromesse<boolean>;
        /**
          * Méthode qui récupère la résolution de l'écran.
          * @return {IPromesse<IResolutionEcranDTO>}   Retourne un object de type IResolutionEcranDTO
          */
        getResolutionEcran(): IPromesse<IResolutionEcranDTO>;
        /**
         * Méthode qui récupère la liste des périphériques connectés.
         * @return {IPromesse<IPeripherique[]>} liste d'objet IPeripherique
         */
        listePeripheriques(): IPromesse<Mobilite.IPeripherique[]>;
        /**
         * Méthode qui récupère la liste des tablettes de signatures connectées.
         * @return {IPromesse<ITabletteSignature[]>} liste d'objet ITabletteSignature
         */
        listeTablettesSignatures(): IPromesse<Mobilite.ITabletteSignature[]>;
        /**
         * Methode qui récupère le type de plateforme du poste.
         * @return {IPromesse<PLATEFORME>} Retourne le type de plateforme
         */
        getPlateforme(): IPromesse<PLATEFORME>;
    }
}


/**
* Module de gestion de la mobilite
* @module fwkManager.Services.Mobilite
* classe : MobiliteManager - public - Classe permettant la gestion de la mobilite
*/
declare module fwkManager.Services.Mobilite {
    /**
    *  Classe permettant d'accéder aux données de mobilité
    */
    class MobiliteApiFullWeb extends MobiliteApiBase {
        constructor();
        /**
          * Méthode qui récupère la liste des tablettes de signatures connectées.
          * @return {IPromesse<ITabletteSignature[]>} liste d'objet ITabletteSignature
          */
        listeTablettesSignatures(): IPromesse<Mobilite.ITabletteSignature[]>;
        /**
          * Méthode qui récupère la résolution de l'écran.
          * @return {IPromesse<ResolutionEcranDTO>}   Retourne un object de type ResolutionEcranDTO
          */
        getResolutionEcran(): IPromesse<IResolutionEcranDTO>;
        /**
         * Methode qui récupère le type de plateforme du poste.
         * @return {IPromesse<PLATEFORME>} Retourne le type de plateforme
         */
        getPlateforme(): IPromesse<PLATEFORME>;
    }
}


/**
* Module de gestion de la mobilite
* @module fwkManager.Services.Mobilite
* classe : MobiliteManager - public - Classe permettant la gestion de la mobilite
*/
declare module fwkManager.Services.Mobilite {
    /**
    *  Classe permettant d'accéder aux données de mobilité
    */
    class MobiliteApiWindows extends MobiliteApiBase {
        protected _periphUrl: string;
        protected _contexteUrl: string;
        constructor();
        /**
         * Méthode qui récupère la liste des tablettes de signatures connectées.
         * @return {IPromesse.ITabletteSignatureDTO >} liste d'objet ITabletteSignatureDTO
         */
        listeTablettesSignatures(): IPromesse<ITabletteSignature[]>;
        getResolutionEcran(): IPromesse<IResolutionEcranDTO>;
        /**
         * Methode qui récupère le type de plateforme du poste.
         * @return {IPromesse<PLATEFORME>} Retourne le type WINDOWS car on a le service locale
         */
        getPlateforme(): IPromesse<PLATEFORME>;
    }
}


/**
* Module de gestion de la mobilite
* @module fwkManager.Services.Mobilite
* classe : MobiliteManager - public - Classe permettant la gestion de la mobilite
*/
declare module fwkManager.Services.Mobilite {
    /**
    *  Classe permettant d'accéder aux données de mobilité
    */
    class MobiliteApiSIRIS extends MobiliteApiWindows {
        constructor();
        getPlateforme(): IPromesse<PLATEFORME>;
    }
}


/**
* Module de gestion de la numérisation
* @module fwkManager.Services.Numerisation
* classe : NumerisationManager - public - Classe permettant la gestion de la numérisation
* classe : NumerisationParamObligatoires - public - Classe permettant de définir les paramètres de numérisation
*/
declare module fwkManager.Services.Numerisation {
    /**
    * Classe permettant la gestion de la numérisation
    * @classe NumerisationManager
    * fonction : numeriser – public - Permet de lancer une numérisation
    */
    class NumerisationManager extends Component.ComponentManagerBase {
        private static CLASS_NAME;
        private static logger;
        /**
        * Constructeur de la classe NumerisationManager
        * @param managerLibrary {ManagerLibrary}
        * @param serviceApi {IServiceApi}
        */
        constructor(managerLibrary: ManagerLibrary);
        /**
        * Permet de lancer une numérisation
        * @param data {string} données à envoyer pour la numérisation (xml sérializé)
        * @param numerisationParams {NumerisationParams} paramètres de numérisation du document
        * @param callback {function} action à executer une fois la numérisation effectuée
        * @param callbackError {function} action à executer en cas d'erreur de numérisation
        *
        * ~~~ts
        * serviceManager.Numerisation.numeriser(documentData, documentParams)
        *    .then(() => {
        *       // Numérisation OK
        *    }).catch((erreur: fwkManager.Services.Erreur) => {
        *       // Numérisation KO: traitement de l'erreur
        * });
        * ~~~
        */
        numeriser(data: string, numerisationParams: NumerisationParams, callback: () => void, callbackError: (erreur: Erreur) => void): void;
        /**
        * Permet de savoir si le jeton d'activation SpiFactory est présent sur le serveur d'agence
        * @param callback {function} action à executer une fois le statut d'activation récupéré
        * @param callbackError {function} action à executer en cas d'erreur
        * ~~~ts
        * serviceManager.Numerisation.getSpiFactoryActivationStatut()
        *    .then((jetonSpiFactory) => {
        *       // Traitement
        *    }).catch((erreur: fwkManager.Services.Erreur) => {
        *       // Traitement en cas d'erreur
        * });
        * ~~~
        */
        getSpiFactoryActivationStatut(callback: (spiFactoryActivationStatut: boolean) => void, callbackError: (erreur: Erreur) => void): void;
        /**
        * Permet de lancer une numérisation avec Spifactory Arcade
        * @param data {string} données à envoyer pour la numérisation (xml sérializé)
        * @param numerisationParams {any} paramètres de numérisation du document
        * @param callback {function} action à executer une fois la numérisation effectuée
        * @param callbackError {function} action à executer en cas d'erreur de numérisation
        * ~~~ts
        * serviceManager.Numerisation.numeriserArcade(documentData, null)
        *    .then(() => {
        *       // Numérisation Arcade OK
        *    }).catch((erreur: fwkManager.Services.Erreur) => {
        *       // Numérisation Arcade KO: traitement de l'erreur
        * });
        * ~~~
        */
        numeriserArcade(data: string, numerisationParams: any, callback: () => void, callbackError: (erreur: Erreur) => void): void;
        /**
        * Traite les messages provenants de l'agent NumerisationAgent
        * @param event {Event} évènement
        * @param sendResponseCallback {ResponseCallback} objet contenant le callback de retour
        */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
        /**
        * Délocalise les données nécessaires au fonctionnement de SpiFactory (fonction récursive)
        * @param numEtablissement {string} Code de l'établissement pour lequel il faut récupérer les données
        * @param donneesNumerisation {NumerisationData} Objet de données numérisation à compléter
        * @param action {string} Nom de l'objet de données délocalisées à récupérer
        * @param callback {function} action à executer une fois l'ensemble des données récupérées
        * @param callbackError {function} action à executer en cas d'erreur de lors de la récupération des données
        */
        private getDonneesDelocaliseesNumerisation(numEtablissement, donneesNumerisation, action, callback, callbackError);
        /**
        * Délocalise les données nécessaires au fonctionnement de SpiFactory Arcade (fonction récursive)
        * @param numEtablissement {string} Code de l'établissement pour lequel il faut récupérer les données
        * @param donneesNumerisationArcade {NumerisationDataArcade} Objet de données numérisation à compléter
        * @param action {string} Nom de l'objet de données délocalisées à récupérer
        * @param callback {function} action à executer une fois l'ensemble des données récupérées
        * @param callbackError {function} action à executer en cas d'erreur de lors de la récupération des données
        */
        private getDonneesDelocaliseesNumerisationArcade(numEtablissement, donneesNumerisationArcade, action, callback, callbackError);
    }
}

declare module fwkManager.Services.Numerisation {
    interface INumerisationApi {
        numeriserDocument(data: any, params: any, callback: () => void, callbackError: ErreurCallback): any;
        getSpiFactoryActivationStatutOnServeur(callback: (statut: boolean) => void, callbackError: ErreurCallback): any;
        numeriserDocumentArcade(data: any, params: any, callback: () => void, callbackError: ErreurCallback): any;
    }
}


declare module fwkManager.Services.Numerisation {
    class NumerisationApiBase implements INumerisationApi {
        private _url;
        constructor(url: string);
        numeriserDocument(data: NumerisationData, params: any, callback: () => void, callbackError: ErreurCallback): void;
        getSpiFactoryActivationStatutOnServeur(callback: (statut: boolean) => void, callbackError: ErreurCallback): void;
        numeriserDocumentArcade(data: NumerisationData, params: any, callback: () => void, callbackError: ErreurCallback): void;
    }
}


declare module fwkManager.Services.Numerisation {
    class NumerisationApiFullWeb extends NumerisationApiBase {
        constructor();
    }
}


declare module fwkManager.Services.Numerisation {
    class NumerisationApiWindows extends NumerisationApiBase {
        constructor();
    }
}


declare module fwkManager.Services.Persistence {
    class PersistenceManager extends Component.ComponentManagerBase {
        private CURRENT_ID_EMETTEUR;
        private keysWatched;
        constructor(managerLibrary: ManagerLibrary);
        initialize(): void;
        dispose(): void;
        addStorage<T>(pKey: string, pCallback: (pElement: T) => void): StorageInstance<T>;
        private listener;
        private removeListener(pKey, pEventListener);
        private addElementToStore(pStore, pElement);
    }
    class StorageInstance<T> {
        private keyStorage;
        private callbackToDisposeListener;
        private callbackToSave;
        private callbackOnEvent;
        constructor(pKeyStorage: string, pCallbackToDisposeListener: () => void, pCallbackToSave: (pObject: T) => void, pCallbackOnEvent: (pElement: T) => void);
        saveValue(pObject: T): void;
        getValue(): T;
        onEvent(pElement: T): void;
        disposeListener(): void;
    }
}


declare module fwkManager.Services.Preferences {
    enum PreferencesMessageSubject {
        LirePreference = 0,
        EcrirePreference = 1,
        LireMultiPreference = 2,
    }
    interface IPreferencesMessageContentLireMultiPreferenceRequest extends IPreferencesMessageContent {
        codesPreference: string[];
    }
    interface IPreferencesMessageContentLireMultiPreferenceResponse extends IPreferencesMessageContent {
        preferences: IPreferenceUtilisateur[];
    }
    interface IPreferencesMessageContentLirePreferenceRequest extends IPreferencesMessageContent {
        nomVariable: string;
    }
    interface IPreferencesMessageContentLirePreferenceResponse extends IPreferencesMessageContent {
        valeurVariable: string;
    }
    interface IPreferencesMessageContentEcrirePreferenceRequest extends IPreferencesMessageContent {
        preferences: IPreferenceUtilisateur[];
    }
    interface IPreferencesMessageContentEcrirePreferenceResponse extends IPreferencesMessageContent {
    }
    interface IPreferencesMessageContent {
    }
        
    class PreferencesManagerExtended {
        private manager;
        constructor(manager: PreferencesManager);
        // LirePreference(nomVariable: any): IPromesse<string>;
        // LireMultiPreference(codesPreference: string[]): IPromesse<IPreferencesMessageContentLireMultiPreferenceResponse>;
        LirePreference(nomVariable: string): IPromesse<string>;
        EcrirePreference(nomVariable: string, valeurVariable: string): IPromesse<void>;
        lireMultiPreference(codesPreference: string[]): IPromesse<IPreferenceUtilisateur[]>;
        ecrireMultiPreference(preferences: IPreferenceUtilisateur[]): IPromesse<void>;
    }
    class PreferencesManager extends Component.ComponentManagerBase {
        private _managerLibrary;
        Library: ManagerLibrary;
        private static CLASS_NAME;
        private static logger;
        constructor(managerLibrary: ManagerLibrary);
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
        ObtenirPreferences(callback?: (data: IPreferenceUtilisateur[]) => void, errorCallback?: (error: fwkManager.Services.Erreur) => void): void;
        LirePreference(codePreference: string, callback: (data: string) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): void;
        EcrirePreference(codePreference: string, valeurPreference: string, callback?: () => void, errorCallback?: (error: fwkManager.Services.Erreur) => void): void;
        private internalGetPreferences(pCallback);
        private internalSavePreferences(pPreferences);
        private internalMettreAJourDonnee(pPreferences, pCle, pValeur);
        private isJson(str);
    }
}


declare module fwkManager.Services.Preferences {
    interface IPreferenceUtilisateur {
        cle: string;
        valeur: string;
    }
    interface IPreferencesApi {
        ObtenirPreferences(nomPoste: any, callback: (data: IPreferenceUtilisateur[]) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): any;
        EcrirePreference(nomPoste: any, cle: any, valeur: any, callback: () => void, errorCallback: (error: fwkManager.Services.Erreur) => void): any;
    }
}


declare module fwkManager.Services.Preferences {
    /**
    * Classe permettant la gestion des preferences
    */
    class PreferencesApi extends Component.ComponentApiBase implements IPreferencesApi {
        private ServiceUrl;
        constructor();
        ObtenirPreferences(codeAgent: string, callback: (data: IPreferenceUtilisateur[]) => void, errorCallback: (error: fwkManager.Services.Erreur) => void): void;
        EcrirePreference(codeAgent: string, cle: any, valeur: any, callback: () => void, errorCallback: (error: fwkManager.Services.Erreur) => void): void;
    }
}

declare module fwkManager.Services.Trace {
    var DB_STORE_TRACES: string;
    var DB_STORE_TRACES_INDEX_NIVEAU: string;
    var DB_STORE_TRACES_INDEX_DATETIME: string;
    var TIMEOUT_ENVOI_TRACE: number;
    var NB_ESSAIS_MAX_TRACES: number;
}


declare module fwkManager.Services.Trace {
    interface TraceEnregistrement {
        dateDernierEnvoi: number;
        nbEssais: number;
        trace: TraceModel;
    }
    class BDTrace extends BaseDeDonnees.Generique.Model.DBBase {
        static DB_VERSION: number;
        static DB_NAME: string;
        private _tableTraces;
        private _dbImplTableTraces;
        constructor();
        setDbImplTableTailleDB(pDbImpl: BaseDeDonnees.Generique.IDBTableImplementation<number, TraceEnregistrement>): void;
        mettreAJour(pVersionActuelle: number, pVersionVoulue: number): Array<BaseDeDonnees.Generique.IMiseAJourBase>;
        private miseAJourV0ToV1();
        private miseAJourV1ToV2();
        private miseAJourV2ToV3();
        private miseAJourV3ToV4();
        private miseAJourV4ToV5();
        tableTraces: BDTraceTableMain;
    }
    class BDTraceTableMain extends BaseDeDonnees.Generique.Model.DBTable<number, TraceEnregistrement, BDTrace> {
        static indexNiveau: BaseDeDonnees.Generique.IIndex;
        static indexDatetime: BaseDeDonnees.Generique.IIndex;
        constructor(bd: BDTrace);
        reset(pConnexion: BaseDeDonnees.Generique.IDBConnexion): IPromesse<void>;
        ajouterTrace(pConnexion: BaseDeDonnees.Generique.IDBConnexion, pTrace: TraceEnregistrement): IPromesse<number>;
        getToutesLesTracesNonPurgees(pConnexion: BaseDeDonnees.Generique.IDBConnexion): IPromesse<BaseDeDonnees.Generique.CleValeur<number, TraceEnregistrement>[]>;
        mettreAJourTrace(pConnexion: BaseDeDonnees.Generique.IDBConnexion, pCle: number, pTrace: TraceEnregistrement): IPromesse<void>;
        supprimerTrace(pConnexion: BaseDeDonnees.Generique.IDBConnexion, pCle: number): IPromesse<void>;
    }
}


declare module fwkManager.Services.Trace {
    interface INiveauKeyValuePair {
        Key: string;
        Value: number;
    }
    class TraceManagerExtended {
        private manager;
        private static CLASS_NAME;
        private static logger;
        constructor(manager: TraceManager);
        debug(message: string, action?: string, detail?: any): void;
        info(message: string, action?: string, detail?: any): void;
        warning(message: string, action?: string, detail?: any): void;
        error(message: string, action?: string, detail?: any): void;
    }
    class TraceManager extends Component.ComponentManagerBase {
        private static CLASS_NAME;
        private static logger;
        Library: ManagerLibrary;
        private _timerPurgeId;
        dbInstance: BDTrace;
        private createPrivateTrace(niveau, action, message, details?);
        constructor(managerLibrary: ManagerLibrary);
        private startTimerPurge();
        Dispose(): IPromesse<void>;
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
        private traceToLogger(pTrace);
        private traceModelToLogger(pTrace);
        private recupererInfosContexte(trace);
        sendMultipleTraces(pTraces: TraceModel[]): IPromesse<void>;
        /**
         * Enregistre une trace en base IndexedDB,
         * l'affiche si demandé
         * @param {TraceModel} trace      trace à enregistrer
         * @param {boolean}    display    affiche ou non la trace
         */
        send(trace: TraceModel, display?: boolean, pConnexion?: BaseDeDonnees.Generique.IDBConnexion): IPromesse<void>;
        /**
         * Enregistre dans les traces techniques les traces 'indépendantes'
         */
        recordCheckpoints(pTraces?: TraceModel[]): void;
        private recordInIDB(trace, pConnexion?);
        private gererPurge();
        purgerTraces(): void;
        private finDePurgeOk(pTraces);
        private finDePurgeFail(pTraces);
        private reInitDbTraces(callback, callbackError);
        sendDiagnostic(diagnostic: ApplicationDiagnostic): void;
        private _modeDebugDuration;
        initializeModeDebug(): void;
        setModeDebug(active: boolean): void;
    }
}


declare module fwkManager.Services.Trace {
    interface ITraceApi {
        envoyerTraces(traces: Trace.TraceModel[], authentInfo: Context.AuthentificationInfo): IPromesse<void>;
        setModeDebug(timeToLive: number): IPromesse<any>;
    }
    interface ITraceDTO {
        level: string;
        message: string;
        details: ITraceDetailsDTO;
    }
    interface ITraceDetailsDTO {
        /** Date de création de la trace */
        DateTime?: number;
        /** Numero station de travail (P0SEC243) */
        IdentifiantPoste?: string;
        /** IdProcessus */
        IdentifiantProcessus?: string;
        /** cheminIntances */
        IdentifiantEtape?: string;
        /** Agence de rattachement (1057604) */
        AgenceRattachement?: string;
        /** Niveau de la trace, par défaut INFO */
        NiveauTrace?: string;
        /** COCXBQ (11315) */
        CodeEtablissement?: string;
        /** numeroInterneEds */
        PosteFonctionnelAgent?: string;
        /** Nom de l'application ou nom du composant provoquant la trace */
        NomComposant?: string;
        /** Par défaut est à 01 */
        TypeCanal?: string;
        /** version du composant (v17.01) */
        VersionComposant?: string;
        /** Par défaut est à 01 */
        TypeDevice?: string;
        /** referenceExterneAgent (A0077541) */
        IdentifiantConnexionAgent?: string;
        Autres?: any;
    }
}


/**
* Module de gestion des traces techniques
* @module fwkManager.Services.Trace
*/
declare module fwkManager.Services.Trace {
    class TraceApiBase implements ITraceApi {
        private _url;
        constructor();
        /**
         * Méthode qui fait la correspondance entre l'export const enum NIVEAUX_TRACE et l'attribut "level" de la ressource REST
         * @param {export const enum} : NIVEAUX_TRACE
         * @return {string} level d'erreur
         */
        private convertirEnumNiveau(niveau);
        /**
        * Méthode qui fait la correspondance entre "TraceModel" et l'attribut "ITraceDTO" de la ressource REST
        * @param {Trace.TraceModel[]} : Objet généré lors de l'écrire d'un trace
        * @param {Context.AuthentificationInfo} : Données d'authentifications
        * @return {ITraceDTO} Modèle de trace attendu par la ressource REST
        */
        private convertirTraceModel(traces, authentificationInfo);
        /**
        * Méthode qui envoie les traces vers le serveur Kibana
        * @param {Trace.TraceModel[]} : Objet généré lors de l'écrire d'un trace
        * @param {Context.AuthentificationInfo} : Données d'authentifications
        * @return {IPromesse<void>}
        */
        envoyerTraces(traces: Trace.TraceModel[], authentInfo: Context.AuthentificationInfo): IPromesse<void>;
        setModeDebug(timeToLive: number): IPromesse<any>;
    }
}


/**
* Module de gestion des traces techniques
* @module fwkManager.Services.Trace
*/
declare module fwkManager.Services.Trace {
    class TraceApiFullWeb extends TraceApiBase {
        constructor();
    }
}


/**
* Module de gestion des traces techniques
* @module fwkManager.Services.Trace
*/
declare module fwkManager.Services.Trace {
    class TraceApiWindows extends TraceApiBase {
        constructor();
        /**
        * Méthode qui envoie les traces vers le service local et le serveur Kibana
        * @param {Trace.TraceModel[]} : Objet généré lors de l'écrire d'un trace
        * @param {Context.AuthentificationInfo} : Données d'authentifications
        * @return {IPromesse<void>}
        */
        envoyerTraces(traces: Trace.TraceModel[], authentInfo: Context.AuthentificationInfo): IPromesse<void>;
        setModeDebug(timeToLive: number): IPromesse<any>;
    }
}


declare module fwkManager.Services.TraceSuivi {
    var VERSION_BASE: number;
    var DB_TRACES_NAME: string;
    var DB_TABLE_TRACES: string;
}


declare module fwkManager.Services.TraceSuivi {
    interface TraceSuiviEnregistrement {
        datePurge?: number;
        nbEssais?: number;
        purgeId?: string;
        data: TraceSuiviModel;
    }
}


declare module fwkManager.Services.TraceSuivi {
    class BDTraceSuivi extends BaseDeDonnees.Generique.Model.DBBase {
        static DB_VERSION: number;
        static DB_NAME: string;
        private _tableTraces;
        constructor();
        mettreAJour(pVersionActuelle: number, pVersionVoulue: number): Array<BaseDeDonnees.Generique.IMiseAJourBase>;
        private miseAJourV0ToV8();
        /**
         * Mise à jour v8 vers v9
         *
         * Cette mise à jour change les objets stockés de TraceSuiviModel vers TraceSuiviEnregistrement afin de ne pas mélanger les données et les métadonnées
         */
        private miseAJourV8ToV9();
        /**
         * Ajoute un index sur "datePurge"
         */
        private miseAJourV9ToV10();
        tableTraces: TableTraces;
    }
}


declare module fwkManager.Services.TraceSuivi {
    class TableTraces extends BaseDeDonnees.Generique.Model.DBTable<number, TraceSuiviEnregistrement, BDTraceSuivi> {
        static indexDatePurge: BaseDeDonnees.Generique.IIndex;
        constructor(pBase: BDTraceSuivi);
        ajouter(pConnexion: BaseDeDonnees.Generique.IDBConnexion, pObjet: TraceSuiviEnregistrement): IPromesse<number>;
        getNombreTraces(pConnexion: BaseDeDonnees.Generique.IDBConnexion): IPromesse<number>;
        supprimer(pConnexion: BaseDeDonnees.Generique.IDBConnexion, pCle: number): IPromesse<any>;
        getAll(pConnexion: BaseDeDonnees.Generique.IDBConnexion): IPromesse<Array<BaseDeDonnees.Generique.CleValeur<number, TraceSuiviEnregistrement>>>;
        mettreAJour(pConnexion: BaseDeDonnees.Generique.IDBConnexion, pCle: number, pNouvelleValeur: TraceSuiviEnregistrement): IPromesse<void>;
        getTracesAnciennesOuJamaisPurgees(pConnexion: BaseDeDonnees.Generique.IDBConnexion, pAnciennete: number): IPromesse<BaseDeDonnees.Generique.CleValeur<number, TraceSuiviEnregistrement>[]>;
        getNombreTracesAnciennesOuJamaisPurgees(pConnexion: BaseDeDonnees.Generique.IDBConnexion, pAnciennete: number): IPromesse<number>;
    }
}


declare module fwkManager.Services.TraceSuivi {
    class TraceSuiviManager extends Component.ComponentManagerBase {
        private static CLASS_NAME;
        private static logger;
        private _managerLibrary;
        Library: ManagerLibrary;
        private estEnPurge;
        private dateDebutPurge;
        private tempsDePurgeMax;
        private nombreMaximumDeTraceAvantPurge;
        db: BDTraceSuivi;
        private purgesEnAttente;
        constructor(managerLibrary: ManagerLibrary);
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
        /**
         * Complète l'objet de trace fourni en paramètre
         * @param {TraceSuiviModel} trace L'objet à compléter
         */
        private recupererInfos(trace, pLaisserValeursDefaut);
        SetProcessAndStepId(trace: TraceSuivi.TraceSuiviModel, currentPath: string, pLaisserValeursDefaut: boolean): void;
        private GetCodeAndUId(id, separator);
        private CleanProcessId(processId, max);
        private CleanStepId(stepId, max1, max2);
        /**
         * Complète l'objet de trace (sauf si spécifié) et l'envoie à l'API de trace de suivi si IndexedDB indisponible, ou l'enregistre si présent
         * @param trace L'objet à compléter et tracer
         * @param pCompleterTrace Indique s'il faut ou pas compléter l'objet trace. Si explicitement FALSE alors la trace ne sera pas complétée.
         * @return Une promesse d'écriture
         */
        tracer(trace: TraceSuiviModel, pCompleterTrace?: boolean): IPromesse<number>;
        /**
         * Enregistre une trace
         * @param {TraceSuiviModel} trace L'objet à tracer
         */
        private recordInIDB(trace);
        private callbackPurgerSuivant();
        /**
         * Vérifie la taille de la base IndexedDB de trace de suivi
         * Si la taille excède le nombreMaximumDeTraceAvantPurge, lance une purge
         */
        checkTailleDB(pForcerPurger?: boolean): IPromesse<number>;
        /**
         * Obtient le nombre de traces de suivi en base de donnée IndexedDB
         */
        getNombreTracesSuiviDB(): IPromesse<number>;
        /**
         * Obtient le nombre de traces de suivi en base de donnée IndexedDB
         */
        getNombreTracesSuiviAEmettreDB(): IPromesse<number>;
        /**
         * Purge les traces de suivi en les émettant à l'API de Trace de Suivi
         */
        purgerTraces(): IPromesse<number>;
    }
}


declare module fwkManager.Services.TraceSuivi {
    /**
     * Composant portail pour les traces de suivis
     */
    class TraceSuiviManagerExtended {
        private manager;
        constructor(manager: TraceSuiviManager);
        /**
         * Ecrit une trace de suivi personalisée.
         * Attention : Aucun contrôle n'est fait, elle sera envoyée parmis les autres traces de suivis
         *
         * @param pTrace Trace à écrire
         * @return Une promesse résolue à la fin de l'écriture de la trace
         */
        forcerTrace(pTrace: fwkManager.Services.TraceSuivi.TraceSuiviModel): IPromesse<void>;
        /**
         * Déclenchement manuel de la purge des traces
         *
         * @return Une promesse qui indique le nombre de traces purgées
         */
        purgerTraces(): IPromesse<number>;
    }
}


declare module fwkManager.Services.TraceSuivi {
    interface ITraceSuiviApi {
        envoyerTracesSuivi(traces: TraceSuiviModel[], pAuthentificationInfo: Context.AuthentificationInfo): IPromesse<void>;
    }
}


declare module fwkManager.Services.TraceSuivi {
    class TraceSuiviApiBase extends Component.ComponentApiBase implements ITraceSuiviApi {
        private _url;
        constructor();
        envoyerTracesSuivi(traces: TraceSuiviModel[], pAuthentificationInfo: Context.AuthentificationInfo): IPromesse<void>;
    }
}


/**
* Module de gestion des jab
* @module fwkManager.Services.JAB
* classe : JABManager - public - Classe permettant la gestion des Journaux d'Archivage Bancaires
*/
declare module fwkManager.Services.TraitementNsdk {
    /**
    * Classe permettant la gestion des habilitations
    */
    class TraitementNsdkManager extends Component.ComponentManagerBase {
        private static CLASS_NAME;
        private static logger;
        constructor(managerLibrary: ManagerLibrary);
        Lancer(traitement: string, data: string): IPromesse<string>;
        /**
        * Traite les messages provenants de l'agent TraitementNsdkAgent
        * @param event {Event} évènement
        * @param sendResponseCallback {ResponseCallback} objet contenant le callback de retour
        */
        HandleMessage(event: MessageEvent, sendResponseCallback: Message.ResponseCallback): void;
    }
}


declare module fwkManager.Services.TraitementNsdk {
    interface ITraitementNsdkApi {
        Lancer(traitement: string, data: string): IPromesse<string>;
    }
}


/**
* Module de gestion des traitements NSDK depuis MyWay
* @module fwkManager.Services.TraitementNsdk
* classe : TraitementNsdkManager - public - Classe permettant la gestion des traitements NSDK depuis MyWay
*/
declare module fwkManager.Services.TraitementNsdk {
    /**
    * Classe permettant la gestion des traitements NSDK depuis MyWay
    */
    class TraitementNsdkApi extends Component.ComponentApiBase implements ITraitementNsdkApi {
        constructor();
        Lancer(traitement: string, data: string): IPromesse<string>;
    }
}


declare module fwkManager.Services.Storage {
    class BaseStorage {
        Key: string;
        static LocalStorageLimitInKb: number;
        static IndexedDBStorageLimitInKb: number;
        onStorageLimit: (lsSize: number, idbSize: number) => void;
        constructor(Key: string);
        onInternalStorageChanged: (rev: string) => void;
        Set(value: string): void;
        Get(): string;
        static EvaluateStorageSize(onStorageLimit: (lsSize: number, idbSize: number) => void): void;
    }
    class ContextStorage {
        private static _baseStorage;
        static Key: string;
        static onInternalStorageChanged: (rev: string) => void;
        static onStorageLimit: (lsSize: number, idbSize: number) => void;
        static Set(value: string): void;
        static Get(): string;
    }
    class InteropMessageBusStorage {
        private static _baseStorage;
        static Key: string;
        static onInternalStorageChanged: (rev: string) => void;
        static onStorageLimit: (lsSize: number, idbSize: number) => void;
        static Set(value: string): void;
        static Get(): string;
    }
}
